<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>IO多路复用-多线程并发通信 | Maxswordsman</title><meta name="author" content="Maxswordsman"><meta name="copyright" content="Maxswordsman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IO多路复用-多线程并发通信文档转自：IO多路复用之select&#x2F;poll IO多路转接也称为IO多路复用，它是一种网络通信的手段（机制），通过这种方式可以同时监测多个文件描述符并且这个过程是阻塞的，一旦检测到有文件描述符就绪（ 可以读数据或者可以写数据）程序的阻塞就会被解除，之后就可以基于这些（一个或多个）就绪的文件描述符进行通信了。通过这种方式在单线程&#x2F;进程的场景下也可">
<meta property="og:type" content="article">
<meta property="og:title" content="IO多路复用-多线程并发通信">
<meta property="og:url" content="https://maxswordsman.github.io/2023/08/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="Maxswordsman">
<meta property="og:description" content="IO多路复用-多线程并发通信文档转自：IO多路复用之select&#x2F;poll IO多路转接也称为IO多路复用，它是一种网络通信的手段（机制），通过这种方式可以同时监测多个文件描述符并且这个过程是阻塞的，一旦检测到有文件描述符就绪（ 可以读数据或者可以写数据）程序的阻塞就会被解除，之后就可以基于这些（一个或多个）就绪的文件描述符进行通信了。通过这种方式在单线程&#x2F;进程的场景下也可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://maxswordsman.github.io/image/head2.webp">
<meta property="article:published_time" content="2023-08-28T15:15:00.000Z">
<meta property="article:modified_time" content="2023-08-28T15:15:00.000Z">
<meta property="article:author" content="Maxswordsman">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://maxswordsman.github.io/image/head2.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://maxswordsman.github.io/2023/08/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%80%9A%E4%BF%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'IO多路复用-多线程并发通信',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-28 23:15:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/head2.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Maxswordsman"><span class="site-name">Maxswordsman</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">IO多路复用-多线程并发通信</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-28T15:15:00.000Z" title="发表于 2023-08-28 23:15:00">2023-08-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-28T15:15:00.000Z" title="更新于 2023-08-28 23:15:00">2023-08-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/">C</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="IO多路复用-多线程并发通信"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />

<h2 id="IO多路复用-多线程并发通信"><a href="#IO多路复用-多线程并发通信" class="headerlink" title="IO多路复用-多线程并发通信"></a>IO多路复用-多线程并发通信</h2><p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/select/">文档转自：IO多路复用之select&#x2F;poll</a></p>
<p>IO多路转接也称为IO多路复用，它是一种网络通信的手段（机制），通过这种方式<strong>可以同时监测多个文件描述符并且这个过程是阻塞的</strong>，一旦检测到有文件描述符就绪（ 可以读数据或者可以写数据）程序的阻塞就会被解除，之后就可以基于这些（一个或多个）就绪的文件描述符进行通信了。通过这种方式在单线程&#x2F;进程的场景下也可以在服务器端实现并发。常见的IO多路转接方式有：<code>select</code>、<code>poll</code>、<code>epoll</code></p>
<p>下面先对多线程&#x2F;多进程并发和IO多路转接的<strong>并发处理流程进行对比</strong>（服务器端）：</p>
<p><strong>服务端用于监听的文件描述符只有一个，而用于通信的文件描述符有多个</strong></p>
<p><strong>多线程&#x2F;多进程并发</strong>：</p>
<ul>
<li>主线程&#x2F;主进程：调用<code>accept()</code>检测客户端请求<ul>
<li><code>accept</code>函数检测用于监听的文件描述符的读缓冲区,若没有数据表示 没有新的客户端的连接请求，当前线程&#x2F;进程会阻塞</li>
<li>有数据表示有新的客户端的连接请求解除阻塞，建立连接</li>
</ul>
</li>
<li>子线程&#x2F;子进程：和建立连接的客户端通信<ul>
<li>调用<code> read() / recv()</code> 接收客户端发送的通信数据（读缓冲区），如果没有通信数据，当前线程&#x2F;进程会阻塞，数据到达之后阻塞自动解除</li>
<li>调用<code>write() / send()</code>给客户端发送数据，如果写缓冲区已满，当前线程&#x2F;进程会阻塞，否则将待发送数据写入写缓冲区中</li>
</ul>
</li>
</ul>
<p><strong>IO多路转接并发</strong>：</p>
<ul>
<li><p>使用IO多路转接函数委托内核检测服务器端所有的文件描述符（通信和监听两类），这个检测过程会导致进程&#x2F;线程的阻塞，如果检测到已就绪的文件描述符阻塞解除，并将这些已就绪的文件描述符传出</p>
</li>
<li><p>根据类型对传出的所有已就绪文件描述符进行判断，并做出不同的处理</p>
<ul>
<li><p>监听的文件描述符：和客户端建立连接</p>
<p>此时调用<code>accept()</code>是不会导致程序阻塞的，因为监听的文件描述符是已就绪的（有新请求）</p>
</li>
<li><p>通信的文件描述符：调用通信函数和已建立连接的客户端通信</p>
<p>调用 <code>read() / recv() </code>不会阻塞程序，因为通信的文件描述符是就绪的，读缓冲区内已有数据</p>
<p>调用 <code>write() / send() </code>不会阻塞程序，因为通信的文件描述符是就绪的，写缓冲区不满，可以往里面写数据</p>
</li>
</ul>
</li>
<li><p>对这些文件描述符继续进行下一轮的检测（循环往复。。。）</p>
</li>
</ul>
<p><strong>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销</strong></p>
<h3 id="一、select"><a href="#一、select" class="headerlink" title="一、select"></a>一、select</h3><p>使用<code>select</code>这种IO多路转接方式需要调用一个同名函数<code>select</code>，这个函数是跨平台的，<code>Linux、Mac、Windows</code>都是支持的。通过调用这个函数可以<strong>委托内核帮助我们检测若干个文件描述符的状态</strong>，其实就是<code>检测这些文件描述符对应的读写缓冲区的状态</code>：</p>
<ul>
<li>读缓冲区：检测里边有没有数据，如果有数据该缓冲区对应的文件描述符就绪</li>
<li>写缓冲区：检测写缓冲区是否可以写(有没有容量)，如果有容量可以写，缓冲区对应的文件描述符就绪</li>
<li>读写异常：检测读写缓冲区是否有异常，如果有该缓冲区对应的文件描述符就绪</li>
</ul>
<p>委托检测的文件描述符被遍历检测完毕之后，已就绪的这些满足条件的文件描述符会通过<code>select()</code>的参数分3个集合传出，设计人员可以得到这几个集合之后就可以分情况依次处理了</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">           fd_set *exceptfds, <span class="keyword">struct</span> timeval * timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>nfds</code>：委托内核检测的这三个集合中最大的文件描述符 + 1<ul>
<li>内核需要线性遍历这些集合中的文件描述符，这个值是循环结束的条件</li>
<li>在Window中这个参数是无效的，指定为-1即可</li>
</ul>
</li>
<li><code>readfds</code>：文件描述符的集合, <strong>内核只检测这个集合中文件描述符对应的读缓冲区</strong><ul>
<li><strong>传入传出参数</strong>，读集合一般情况下都是需要检测的，这样才知道通过哪个文件描述符接收数据</li>
</ul>
</li>
<li><code>writefds</code>：文件描述符的集合,<strong>内核只检测这个集合中文件描述符对应的写缓冲区</strong><ul>
<li><strong>传入传出参数</strong>，如果不需要使用这个参数可以指定为NULL</li>
</ul>
</li>
<li><code>exceptfds</code>：文件描述符的集合, 内核检测集合中文件描述符是否有异常状态<ul>
<li><strong>传入传出参数</strong>，如果不需要使用这个参数可以指定为NULL</li>
</ul>
</li>
<li><code>timeout</code>：超时时长，用来强制解除<code>select()</code>函数的阻塞的<ul>
<li>NULL：函数检测不到就绪的文件描述符会一直阻塞</li>
<li>等待固定时长（秒）：函数检测不到就绪的文件描述符，在指定时长之后强制解除阻塞，函数返回0</li>
<li>不等待：函数不会阻塞，直接将该参数对应的结构体初始化为0即可</li>
</ul>
</li>
</ul>
<p>返回值：</p>
<ul>
<li>大于0：成功，返回集合中已就绪的文件描述符的总个数</li>
<li>等于-1：函数调用失败</li>
<li>等于0：超时，没有检测到就绪的文件描述符</li>
</ul>
<p>另外<strong>初始化<code>fd_set</code>类型的参数还需要使用相关的一些列操作函数</strong>，具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0        </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="1-细节描述"><a href="#1-细节描述" class="headerlink" title="1.细节描述"></a>1.细节描述</h4><p>在<code>select()</code>函数中第<code>2、3、4</code>个参数都是<code>fd_set</code>类型，它表示一个文件描述符的集合，类似于信号集<code> sigset_t</code>，这个类型的数据有<code>128</code>个字节（一个字节8位），也就是<code>1024</code>个标志位，和内核中文件描述符表中的文件描述符个数（1024个）是一样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(fd_set) = <span class="number">128</span> 字节 * <span class="number">8</span> = <span class="number">1024</span> bit      <span class="comment">// int [32] --&gt; 四字节 一个整型 --&gt; 大小为128/4 = 32的整型数组</span></span><br></pre></td></tr></table></figure>

<p>这块<strong>内存中的每一个bit 和 文件描述符表中的每一个文件描述符是一一对应的关系</strong>，这样就可以使用最小的存储空间将要表达的意思描述出来了</p>
<p>下图中的<code>fd_set</code>中存储了要委托内核检测读缓冲区的文件描述符集合</p>
<ul>
<li>下图中的<code>fd_set</code>中存储了要委托内核检测读缓冲区的文件描述符集合</li>
<li>如果集合中的标志位为<code>1</code>代表检测这个文件描述符状态</li>
</ul>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240515144111.png" alt="image-20240515144111847"></p>
<p><strong>内核在遍历这个读集合的过程中，如果被检测的文件描述符对应的读缓冲区中没有数据，内核将修改这个文件描述符在读集合<code>fd_set</code>中对应的标志位，改为0，如果有数据那么这个标志位的值不变，还是1</strong></p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240515144327.png" alt="image-20240515144327522"></p>
<p>当<code>select()</code>函数解除阻塞之后，<strong>被内核修改过的读集合通过参数传出，此时集合中只要标志位的值为1，那么它对应的文件描述符肯定是就绪的</strong>，我们就可以基于这个文件描述符和客户端建立新连接或者通信了</p>
<h4 id="2-select并发处理"><a href="#2-select并发处理" class="headerlink" title="2.select并发处理"></a>2.<code>select</code>并发处理</h4><p>单线程&#x2F;单进程，使用<code>select</code>实现并发</p>
<h5 id="（1）处理流程"><a href="#（1）处理流程" class="headerlink" title="（1）处理流程"></a>（1）处理流程</h5><p>如果在服务器基于<code>select</code>实现并发，其处理流程如下：</p>
<ol>
<li><p>创建监听的套接字<code> lfd = socket()</code>;</p>
</li>
<li><p>将监听的套接字和本地的<code>IP</code>和端口绑定<code> bind()</code></p>
</li>
<li><p>给监听的套接字设置监听<code> listen()</code></p>
</li>
<li><p>创建一个文件描述符集合<code> fd_set</code>，用于存储需要检测读事件的所有的文件描述符</p>
<ul>
<li><p>通过 <code>FD_ZERO()</code> 初始化</p>
</li>
<li><p>通过 <code>FD_SET()</code>将监听的文件描述符放入检测的读集合中</p>
</li>
</ul>
</li>
<li><p>循环调用<code>select()</code>，周期性的对所有的文件描述符进行检测</p>
</li>
<li><p><code>select()</code> 解除阻塞返回，<strong>得到内核传出的满足条件的就绪的文件描述符集合</strong></p>
<ul>
<li>通过<code>FD_ISSET()</code> 判断集合中的标志位是否为 1<ul>
<li>如果这个文件描述符是监听的文件描述符，调用<code>accept()</code>和客户端建立连接<ul>
<li>将得到的新的通信的文件描述符，通过<code>FD_SET()</code> 放入到检测集合中</li>
</ul>
</li>
<li>如果这个文件描述符是通信的文件描述符，调用通信函数和客户端通信<ul>
<li>如果客户端和服务器断开了连接，使用<code>FD_CLR()</code>将这个文件描述符从检测集合中删除</li>
<li>如果没有断开连接，正常通信即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>重复第6步</p>
</li>
</ol>
<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240515160027.png" alt="image-20240515160027718"></p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240515160101.png" alt="image-20240515160101081"></p>
<h5 id="（2）通信代码"><a href="#（2）通信代码" class="headerlink" title="（2）通信代码"></a>（2）通信代码</h5><p><strong>服务端代码</strong>：</p>
<p><code>server_Iomultiplexing.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的fd</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> cfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">1989</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字属性 快速释放被占用的端口</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的fd的状态检测委托给内核检测</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line">    <span class="comment">// 初始化检测的读集合--集合有去重操作</span></span><br><span class="line">    fd_set rdset;  <span class="comment">// 原始集合</span></span><br><span class="line">    fd_set rdtemp;</span><br><span class="line">    <span class="comment">// 清零</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    <span class="comment">// 将监听的lfd设置到检测的读集合中</span></span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    <span class="comment">// 通过select委托内核检测读集合中的文件描述符状态, 检测read缓冲区有没有数据</span></span><br><span class="line">    <span class="comment">// 如果有数据, select解除阻塞返回</span></span><br><span class="line">    <span class="comment">// 应该让内核持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 默认阻塞</span></span><br><span class="line">        <span class="comment">// rdset 中是委托内核检测的所有的文件描述符</span></span><br><span class="line">        rdtemp = rdset;</span><br><span class="line">        <span class="comment">// 参数1：最大的文件描述符值+1  参数2：读集合  参数3：写集合为NULL</span></span><br><span class="line">        <span class="type">int</span> num = select(maxfd+<span class="number">1</span>, &amp;rdtemp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// rdset中的数据被内核改写了, 只保留了发生变化的文件描述的标志位上的1, 没变化的改为0</span></span><br><span class="line">        <span class="comment">// 只要rdset中的fd对应的标志位为1 -&gt; 缓冲区有数据了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断读集合中的监听套接字文件描述符的标志位是否为1</span></span><br><span class="line">        <span class="comment">// 监听的套接字文件描述符，是否有连接</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rdtemp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接受连接请求, 这个调用不阻塞</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">            <span class="type">int</span> cliLen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            <span class="comment">// 此时accept不会阻塞，因为该监听的套接字文件描述符读缓冲区有数据，为就绪状态</span></span><br><span class="line">            cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliLen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到了有效的文件描述符</span></span><br><span class="line">            <span class="comment">// 通信的文件描述符添加到读集合</span></span><br><span class="line">            <span class="comment">// 在下一轮select检测的时候, 就能得到通信的套接字文件描述符读缓冲区的状态</span></span><br><span class="line">            FD_SET(cfd, &amp;rdset);</span><br><span class="line">            <span class="comment">// 重置最大的文件描述符</span></span><br><span class="line">            maxfd = cfd &gt; maxfd ? cfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有新连接, 通信</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;maxfd+<span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 判断从监听的文件描述符之后到maxfd这个范围内的文件描述符是否读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(i != lfd &amp;&amp; FD_ISSET(i, &amp;rdtemp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="comment">// 一次只能接收10个字节, 客户端一次发送100个字节</span></span><br><span class="line">                <span class="comment">// 一次是接收不完的, 文件描述符对应的读缓冲区中还有数据</span></span><br><span class="line">                <span class="comment">// 下一轮select检测的时候, 内核还会标记这个文件描述符缓冲区有数据 -&gt; 再读一次</span></span><br><span class="line">                <span class="comment">// 	循环会一直持续, 知道缓冲区数据被读完位置</span></span><br><span class="line">                <span class="type">int</span> len = recv(i, buf, <span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端关闭了连接...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将检测的文件描述符从读集合中删除</span></span><br><span class="line">                    FD_CLR(i, &amp;rdset);</span><br><span class="line">                    close(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 收到了数据,打印到终端</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s&quot;</span>,buf);</span><br><span class="line">                    <span class="comment">// 大小写转换</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;after buf = %s&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                    <span class="type">int</span> ret = send(i,buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">&quot;send()&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 异常</span></span><br><span class="line">                    perror(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line">                    <span class="comment">// 退出服务端进程</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭监听的</span></span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>client_Iomultiplexing.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">1989</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        fgets(recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="built_in">stdin</span>);</span><br><span class="line">        send(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        recv(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make client_Iomultiplexing</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make server_Iomultiplexing</span></span><br></pre></td></tr></table></figure>

<p>打开终端运行，服务端程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./server_Iomultiplexing</span></span><br></pre></td></tr></table></figure>

<p>打开多个终端运行，客户端程序，并且在客户端终端输入需要发送的信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./client_Iomultiplexing</span></span><br></pre></td></tr></table></figure>

<p>客户端1显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240515174143.png" alt="image-20240515174143250"></p>
<p>客户端2显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240515174159.png" alt="image-20240515174159788"></p>
<p>服务端显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240515174217.png" alt="image-20240515174217513"></p>
<h5 id="（3）总结"><a href="#（3）总结" class="headerlink" title="（3）总结"></a>（3）总结</h5><p>这种方式，可以实现并发，但是效率比较低，如果存在多个客户端同时与服务端进行通信，服务端需要依次处理客户端请求，若客户端比较多，那么客户端等待响应的时间就会比较长</p>
<h4 id="3-多线程select并发"><a href="#3-多线程select并发" class="headerlink" title="3.多线程select并发"></a>3.多线程select并发</h4><p>为了<code>单线程select并发</code>中低效的情况，可以在上面单线程select并发服务端的基础上，使用多线程，主线程，用于调用<code>select</code>检测集合中是否有就绪的套接字文件描述符。创建子线程调用<code>accept</code>接受客户端的连接，在创建其他子线程用于与已经接受连接的客户端进行通信</p>
<p><code>client.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">1989</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[BUFSIZE];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;hello world, %d\n&quot;</span>, num++);</span><br><span class="line">        send(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        recv(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        <span class="comment">// 1s一次</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>server.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fdinfo</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> *maxfd;</span><br><span class="line">    fd_set * rdset;  <span class="comment">// 指向被内核检测的原始文件描述符集合</span></span><br><span class="line">&#125;FDInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * func:</span></span><br><span class="line"><span class="comment"> *      accept接受客户端连接的子线程任务函数</span></span><br><span class="line"><span class="comment"> * parameter：</span></span><br><span class="line"><span class="comment"> *      fd: 用于监听的套接字文件描述符</span></span><br><span class="line"><span class="comment"> *      fd_set * rdset: 被内核检测的原始文件描述符集合</span></span><br><span class="line"><span class="comment"> *      int *maxfd: 文件描述符最大值</span></span><br><span class="line"><span class="comment"> *      // 参数使用结构体传入</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">acceptConn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程ID：%ld\n&quot;</span>,pthread_self());</span><br><span class="line">    FDInfo *fdInfo = (FDInfo *)arg;</span><br><span class="line">    <span class="comment">// 接受连接请求, 这个调用不阻塞</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> cliLen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="comment">// 此时accept不会阻塞，因为该监听的套接字文件描述符读缓冲区有数据，为就绪状态</span></span><br><span class="line">    <span class="type">int</span> cfd = accept(fdInfo-&gt;fd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到了有效的文件描述符</span></span><br><span class="line">    <span class="comment">// 通信的文件描述符添加到读集合</span></span><br><span class="line">    <span class="comment">// 在下一轮select检测的时候, 就能得到通信的套接字文件描述符读缓冲区的状态</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    FD_SET(cfd, fdInfo-&gt;rdset);</span><br><span class="line">    <span class="comment">// 重置最大的文件描述符</span></span><br><span class="line">    *(fdInfo-&gt;maxfd) = cfd &gt; *(fdInfo-&gt;maxfd) ? cfd : *(fdInfo-&gt;maxfd);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(fdInfo);</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * func:</span></span><br><span class="line"><span class="comment"> *      与客户端通信的子线程任务函数</span></span><br><span class="line"><span class="comment"> * parameter：</span></span><br><span class="line"><span class="comment"> *      fd: 用于监听的套接字文件描述符</span></span><br><span class="line"><span class="comment"> *      fd_set * rdset: 被内核检测的原始文件描述符集合</span></span><br><span class="line"><span class="comment"> *      int *maxfd: 文件描述符最大值</span></span><br><span class="line"><span class="comment"> *      // 参数使用结构体传入</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Communication</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    FDInfo *info = (FDInfo *)arg;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = recv(info-&gt;fd, buf, <span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%ld]:客户端关闭了连接...\n&quot;</span>,pthread_self());</span><br><span class="line">        <span class="comment">// 将检测的文件描述符从读集合中删除</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        FD_CLR(info-&gt;fd, info-&gt;rdset);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        close(info-&gt;fd);</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(info);</span><br><span class="line">        <span class="comment">// 退出子线程</span></span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 收到了数据,打印到终端</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%ld]:read buf = %s\n&quot;</span>,pthread_self(),buf);</span><br><span class="line">        <span class="comment">// 大小写转换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%ld]:after buf = %s\n&quot;</span>,pthread_self(),buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">int</span> ret = send(info-&gt;fd,buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;send()&quot;</span>);</span><br><span class="line">            <span class="comment">// 释放内存</span></span><br><span class="line">            <span class="built_in">free</span>(info);</span><br><span class="line">            <span class="comment">// 退出子线程</span></span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        perror(<span class="string">&quot;recv()&quot;</span>);</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(info);</span><br><span class="line">        <span class="comment">// 退出子线程</span></span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 互斥锁初始化</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建监听的fd</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> cfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">1989</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字属性 快速释放被占用的端口</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的fd的状态检测委托给内核检测</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line">    <span class="comment">// 初始化检测的读集合--集合有去重操作</span></span><br><span class="line">    fd_set rdset;  <span class="comment">// 原始集合</span></span><br><span class="line">    fd_set rdtemp;</span><br><span class="line">    <span class="comment">// 清零</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    <span class="comment">// 将监听的lfd设置到检测的读集合中</span></span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    <span class="comment">// 前面部分不需要枷锁，因为前面代码的执行还没有创建其他子线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过select委托内核检测读集合中的文件描述符状态, 检测read缓冲区有没有数据</span></span><br><span class="line">    <span class="comment">// 如果有数据, select解除阻塞返回</span></span><br><span class="line">    <span class="comment">// 应该让内核持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// rdset 中是委托内核检测的所有的文件描述符</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        rdtemp = rdset;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数1：最大的文件描述符值+1  参数2：读集合  参数3：写集合为NULL</span></span><br><span class="line">        <span class="comment">// rdset中的数据被内核改写了, 只保留了发生变化的文件描述的标志位上的1, 没变化的改为0</span></span><br><span class="line">        <span class="comment">// 只要rdset中的fd对应的标志位为1 -&gt; 缓冲区有数据了</span></span><br><span class="line">        <span class="type">int</span> num = select(maxfd+<span class="number">1</span>, &amp;rdtemp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断读集合中的监听套接字文件描述符的标志位是否为1</span></span><br><span class="line">        <span class="comment">// 监听的套接字文件描述符，是否有连接</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rdtemp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建用于调用accept接受客户端连接请求的子线程</span></span><br><span class="line">            <span class="type">pthread_t</span> tid;</span><br><span class="line">            FDInfo *info = (FDInfo *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FDInfo));</span><br><span class="line">            info-&gt;fd = lfd;</span><br><span class="line">            info-&gt;maxfd = &amp;maxfd;</span><br><span class="line">            info-&gt;rdset = &amp;rdset;</span><br><span class="line">            <span class="comment">// 创建子线程调用accept接受客户端连接</span></span><br><span class="line">            pthread_create(&amp;tid,<span class="literal">NULL</span>,acceptConn,info);</span><br><span class="line">            <span class="comment">// 线程分离</span></span><br><span class="line">            pthread_detach(tid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有新连接, 通信</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;maxfd+<span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 判断从监听的文件描述符之后到maxfd这个范围内的文件描述符是否读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(i != lfd &amp;&amp; FD_ISSET(i, &amp;rdtemp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 创建用于调用accept接受客户端连接请求的子线程</span></span><br><span class="line">                <span class="type">pthread_t</span> tid;</span><br><span class="line">                FDInfo *info = (FDInfo *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FDInfo));</span><br><span class="line">                info-&gt;fd = i;</span><br><span class="line">                info-&gt;rdset = &amp;rdset;</span><br><span class="line">                <span class="comment">// 创建子线程调用accept接受客户端连接</span></span><br><span class="line">                pthread_create(&amp;tid,<span class="literal">NULL</span>,Communication,info);</span><br><span class="line">                <span class="comment">// 线程分离</span></span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭监听的</span></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用多线程select的服务端中，每次只要检测到监听套接字文件描述符的读缓冲区有数据，就会创建一个子线程接受客户端的连接请求</p>
<h3 id="二、poll"><a href="#二、poll" class="headerlink" title="二、poll"></a>二、poll</h3><p>poll与select机制类似，但是poll无法跨平台，一般更加倾向于使用<code>select</code></p>
<p>select的可以查询的文件描述符的数量上限为1024</p>
<p>而poll的可以查询的文件描述符的数量没有上限，但是poll只能在Linux系统上使用</p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/poll/">poll博客链接，爱编程的大丙</a></p>
<h3 id="三、epoll"><a href="#三、epoll" class="headerlink" title="三、epoll"></a>三、epoll</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p><code>epoll </code>全称<code> eventpoll</code>，是<code>linux</code>内核实现<code>IO</code>多路转接&#x2F;复用（<code>IO multiplexing</code>）的一个实现。<code>IO</code>多路转接的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。<code>epoll</code>是<code>select</code>和<code>poll</code>的升级版，相较于<code>select</code>与<code>poll</code>，<code>epoll</code>改进了工作方式，因此它更加高效，但是与<code>poll</code>一样，<code>epoll</code>不可以跨平台，只能在<code>Linux</code>上面使用</p>
<ul>
<li>对于待检测集合<code>select</code>和<code>poll</code>是基于线性方式（时间复杂度为<code>O(n)</code>）处理的，<code>epoll</code>是基于红黑树来管理待检测集合的</li>
<li><code>select</code>和<code>poll</code>每次都会线性扫描整个待检测集合，集合越大速度越慢，<code>epoll</code>使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降</li>
<li><code>select</code>和<code>poll</code>工作过程中存在内核&#x2F;用户空间数据的频繁拷贝问题（每次调用 <code>select</code>&#x2F;<code>poll</code> 时，都需要把整个文件描述符集从用户空间复制到内核空间（<strong>因为内核需要知道哪些文件描述符被监视以及对应的事件类型</strong>）。此外，<code>select</code>&#x2F;<code>poll </code>每次返回时都会返回整个文件描述符集（<strong>完成扫描后，内核需要将更新后的文件描述符集，即状态改变的描述符集，整个文件描述符集，复制回用户空间，以便应用程序可以了解哪些描述符已经就绪</strong>），应用程序需要线性遍历整个集合来找出活动的文件描述符）<ul>
<li><code>epoll</code> 的机制涉及用户空间与内核空间的数据交换，但这种交换是通过系统调用进行的，而不是通过共享内存</li>
<li><code>epoll</code> 在<strong>内核中维护一个事件表，这个事件表是一个数据结构，用于存储所有被监控的文件描述符及其对应的事件</strong>。当用户空间应用程序调用 <code>epoll_ctl()</code> 添加、修改或删除文件描述符时，内核会更新这个事件表</li>
<li><code>epoll</code> 的设计减少了需要复制的数据量，因为<strong>只有发生事件的文件描述符信息会被复制回用户空间</strong>，与 <code>select</code> 或 <code>poll</code> 相比，这大大减少了不必要的数据传输和处理。此外，因为<strong>事件表是在内核中维护的，所以不需要每次调用时都传递大量数据结构，也就减少了系统调用的开销</strong></li>
<li>当监控的文件描述符发生了注册的事件（如可读、可写等），内核将这些事件复制到一个用户空间的缓冲区中。这个过程是通过 <code>epoll_wait()</code> 调用完成的。在 <code>epoll_wait()</code> 调用中，内核检查事件表，查找发生了事件的文件描述符，然后将这些事件的信息复制到用户空间提供的内存中</li>
</ul>
</li>
<li>设计人员需要对<code>select</code>和<code>poll</code>返回的集合进行判断才能知道哪些文件描述符是就绪的，通过<code>epoll</code>可以直接得到已就绪的文件描述符集合，无需再次检测</li>
<li>使用<code>epoll</code><strong>没有最大文件描述符的限制</strong>，仅受系统中进程能打开的最大文件数目限制</li>
</ul>
<p>当<strong>多路复用的文件数量庞大、IO流量频繁的时候</strong>，一般不太适合使用select()和poll()，这种情况下select()和poll()表现较差，**推荐使用<code>epoll()</code>**。</p>
<p><code>epoll</code>维护树状结构，里面还维护了一系列事件处理机制，事件处理机制核心是回调</p>
<p><strong><code>epoll</code>的核心组件</strong>：</p>
<ul>
<li><strong>epoll 文件描述符</strong>：通过调用 <code>epoll_create</code> 创建，它本身是一个文件描述符，代表了一个 <code>epoll</code> 实例。这个描述符会用来管理和跟踪一组文件描述符（sockets、文件、pipes等）的事件</li>
<li><strong>事件注册表</strong>：应用程序通过 <code>epoll_ctl</code> 调用将一个或多个文件描述符添加到 <code>epoll</code> 文件描述符指定的兴趣列表中，或从中移除文件描述符。你可以指定你感兴趣的事件类型，如读、写、关闭等</li>
<li><strong>事件通知区</strong>：调用 <code>epoll_wait</code> 时，内核将所有已就绪的事件（即满足条件的文件描述符事件）复制到用户空间的事件数组中。这允许应用程序仅处理那些有事件发生的文件描述符</li>
</ul>
<p><strong>主要特点</strong>：</p>
<ul>
<li><strong>效率高</strong>: <code>epoll</code> 使用一种<strong>基于事件的编程模式（事件通知的机制和内核中的事件表） <strong>，并且只告诉用户哪些文件描述符是活跃的，这</strong>减少了应用程序检查文件描述符的数量，从而提高了效率</strong>。</li>
<li><strong>可扩展性强</strong>: <code>epoll</code> 的性能几乎不会随着文件描述符数量的增加而降低，这使得它在处理大量并发连接时表现出色</li>
<li><strong>功能强大</strong>: 支持边缘触发和水平触发两种模式，让用户可以根据具体需求选择合适的工作模式</li>
</ul>
<p><strong>工作模式</strong>：</p>
<ul>
<li><strong>边缘触发 (ET)</strong>: 只有当状态改变时，即从非活跃变为活跃时，才会通知用户。这种模式效率很高，但用户需要负责读取所有的数据直到没有更多数据可读。</li>
<li><strong>水平触发 (LT)</strong>: 只要有数据可读，<code>epoll</code> 就会通知用户，不管之前是否已经被通知过。这种模式更容易使用，但可能效率稍低</li>
</ul>
<h4 id="2-操作函数"><a href="#2-操作函数" class="headerlink" title="2.操作函数"></a>2.操作函数</h4><p>在<code>epoll</code>中一共提供是三个<code>API</code>函数，分别处理不同的操作，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">// 检测epoll树中是否有就绪的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p><code>select/poll</code>低效的原因之一是将“添加&#x2F;维护待检测任务”和“阻塞进程&#x2F;线程”两个步骤合二为一。每次调用<code>select</code>都需要这两步操作，然而大多数应用场景中，需要监视的<code>socket</code>个数相对固定，并不需要每次都修改。<code>epoll</code>将这两个操作分开，先用<code>epoll_ctl()</code>维护等待队列，再调用<code>epoll_wait()</code>阻塞进程（解耦）。通过下图的对比显而易见，epoll的效率得到了提升</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516101106.png" alt="image-20240516101106911"></p>
<h5 id="（1）epoll-create"><a href="#（1）epoll-create" class="headerlink" title="（1）epoll_create()"></a>（1）<code>epoll_create()</code></h5><p><code>epoll_create()</code>函数的作用是创建一个红黑树模型的实例，用于管理待检测的文件描述符的集合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>size：在Linux内核2.6.8版本以后，这个参数是被忽略的，只需要指定一个大于0的数值就可以了</li>
</ul>
<p>返回值：</p>
<ul>
<li>失败：返回-1</li>
<li>成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的<code>epoll</code>实例了</li>
</ul>
<h5 id="（2）epoll-ctl"><a href="#（2）epoll-ctl" class="headerlink" title="（2）epoll_ctl()"></a>（2）<code>epoll_ctl()</code></h5><p>函数的作用是管理红黑树实例上的节点，可以进行添加、删除、修改操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合体, 多个变量共用同一块内存        </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line"> 	<span class="type">void</span>        *ptr;</span><br><span class="line">	<span class="type">int</span>          fd;	<span class="comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span></span><br><span class="line">	<span class="type">uint32_t</span>     u32;</span><br><span class="line">	<span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><p><code>epfd</code>：<code>epoll_create()</code> 函数的返回值，通过这个参数找到<code>epoll</code>实例</p>
</li>
<li><p><code>op</code>：这是一个枚举值，控制通过该函数执行什么操作</p>
<ul>
<li><code>EPOLL_CTL_ADD</code>：往<code>epoll</code>模型中添加新的节点</li>
<li><code>EPOLL_CTL_MOD</code>：修改<code>epoll</code>模型中已经存在的节点</li>
<li><code>EPOLL_CTL_DEL</code>：删除<code>epoll</code>模型中的指定的节点</li>
</ul>
</li>
<li><p><code>fd</code>：文件描述符，即要添加&#x2F;修改&#x2F;删除的文件描述符</p>
</li>
<li><p><code>event</code>：<code>epoll</code>事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件</p>
<p><code>events</code>：委托<code>epoll</code>检测的事件，<code> struct epoll_event</code> 结构体中的字段 <code>events</code></p>
<ul>
<li><code>EPOLLIN</code>：读事件, 接收数据, 检测读缓冲区，如果有数据该文件描述符就绪</li>
<li><code>EPOLLOUT</code>：写事件, 发送数据, 检测写缓冲区，如果可写该文件描述符就绪</li>
<li><code>EPOLLERR</code>：异常事件</li>
</ul>
<p><code>data</code>：用户数据变量，这是一个联合体类型，通常情况下使用里边的<code>fd</code>成员，用于存储待检测的文件描述符的值，在调用<code>epoll_wait()</code>函数的时候这个值会被传出</p>
</li>
</ul>
<p>返回值：</p>
<ul>
<li>失败：返回-1</li>
<li>成功：返回0</li>
</ul>
<h5 id="（3）epoll-wait"><a href="#（3）epoll-wait" class="headerlink" title="（3）epoll_wait()"></a>（3）<code>epoll_wait()</code></h5><p>作用是检测创建的<code>epoll</code>实例中有没有就绪的文件描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>epfd</code>：<code>epoll_create() </code>函数的返回值, 通过这个参数找到<code>epoll</code>实例</li>
<li><code>events</code>：传出参数, <strong>这是一个结构体数组的地址, 里边存储了已就绪的文件描述符的信息</strong></li>
<li><code>maxevents</code>：修饰第二个参数, 结构体数组的容量（元素个数）</li>
<li><code>timeout</code>：如果检测的<code>epoll</code>实例中没有已就绪的文件描述符，该函数阻塞的时长, 单位<code>ms </code>毫秒<ul>
<li>0：函数不阻塞，不管<code>epoll</code>实例中有没有就绪的文件描述符，函数被调用后都直接返回</li>
<li>大于0：如果<code>epoll</code>实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回</li>
<li>-1：函数一直阻塞，直到<code>epoll</code>实例中有已就绪的文件描述符之后才解除阻塞</li>
</ul>
</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功，等于0：函数是阻塞被强制解除了, 没有检测到满足条件的文件描述符；大于0：检测到的已就绪的文件描述符的总个数</li>
<li>失败，返回-1</li>
</ul>
<h4 id="3-epoll的使用"><a href="#3-epoll的使用" class="headerlink" title="3.epoll的使用"></a>3.<code>epoll</code>的使用</h4><h5 id="（1）操作步骤"><a href="#（1）操作步骤" class="headerlink" title="（1）操作步骤"></a>（1）操作步骤</h5><p>在服务器端使用<code>epoll</code>进行<code>IO</code>多路转接的操作步骤如下：</p>
<ul>
<li>1.创建监听套接字</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket(AF_INET, SOCK_STR EAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>2.设置端口复用（可选），断开的端口可快速重启</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<ul>
<li>3.使用本地的<code>IP</code>与端口和监听的套接字进行绑定</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br></pre></td></tr></table></figure>

<ul>
<li>4.给监听的套接字设置监听</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(lfd, <span class="number">128</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>5.创建<code>epoll</code>实例对象（<code>epoll</code>树），<code>epoll_create</code>参数大于0即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>6.将用于监听的套接字添加到<code>epoll</code>实例中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span>  <span class="comment">// 事件结构体</span></span><br><span class="line">ev.events = EPOLLIN;    <span class="comment">// 读事件，检测lfd读读缓冲区是否有数据</span></span><br><span class="line">ev.data.fd = lfd;       <span class="comment">// 与事件相关的套接字文件描述符</span></span><br><span class="line"><span class="type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);  <span class="comment">// 将用于监听的套接字文件描述符挂到epoll树上</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>7.检测添加到<code>epoll</code>实例中的文件描述符是否已就绪，并将这些已就绪的文件描述符进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evs是传出的struct epoll_event 事件结构体数组类型参数，里面存储了已经就绪的文件描述符信息</span></span><br><span class="line"><span class="comment">// 可以同读取传出参数evs[i].data.fd知道是哪一个文件描述符已经就绪</span></span><br><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>7-1<strong>判断</strong>，如果是监听的文件描述符，和新客户端建立连接，将得到的文件描述符添加到<code>epoll</code>实例中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = cfd;</span><br><span class="line"><span class="comment">// 新得到的用于通信的套接字文件描述符添加到epoll模型中（挂到epoll树上）, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br></pre></td></tr></table></figure>
</li>
<li><p>7-2<strong>判断</strong>，如果是通信的文件描述符，和对应的客户端通信，如果连接已断开，将该文件描述符从<code>epoll</code>实例中删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接收数据长度为0，表示客户端断开连接</span></span><br><span class="line">    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 关闭用于通信的套接字文件描述符</span></span><br><span class="line">    close(curfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    send(curfd, buf, len, <span class="number">0</span>);  <span class="comment">// 发送数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>8.<strong>重复第7步的操作</strong></p>
</li>
</ul>
<h5 id="（2）示例代码"><a href="#（2）示例代码" class="headerlink" title="（2）示例代码"></a>（2）示例代码</h5><p><code>server_epoll.c</code></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERPORT <span class="string">&quot;1989&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.创建用于监听的套接字文件描述符*/</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2.服务端绑定本机IP与端口信息*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr,<span class="number">0</span>,<span class="keyword">sizeof</span> server_addr);   <span class="comment">// 清0</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;server_addr.sin_addr);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="type">void</span> *)&amp;server_addr,<span class="keyword">sizeof</span> server_addr);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3.设置套接字属性，端口复用*/</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4.监听*/</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5.创建epoll对象实例，epoll树*/</span></span><br><span class="line">    <span class="type">int</span> para = <span class="number">100</span>;   <span class="comment">// 传入的参数&gt;0即可</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(para);</span><br><span class="line">    <span class="keyword">if</span>(epfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*6.将用于监听的套接字添加到epoll实例中*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span>  <span class="comment">// 事件结构体</span></span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 添加读事件，检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;       <span class="comment">// 将监听的套接字文件描述符添加</span></span><br><span class="line">    ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DEBUG信息</span></span><br><span class="line">    <span class="comment">// printf(&quot;DE<span class="doctag">BUG:</span> %s:%d\n&quot;,__FILE__,__LINE__);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*7.检测添加到epoll实例的文件描述符是否就绪*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次，检测一次，传入evs结构体数组，里面存储了已经就绪的文件描述符信息</span></span><br><span class="line">        <span class="comment">// 参数3，size evs结构体数组容量</span></span><br><span class="line">        <span class="comment">// 参数4，-1   结构体数组中直到有就绪的文件描述符才解除阻塞</span></span><br><span class="line">        <span class="comment">// return, num  为就绪的文件描述符数量</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd,evs,size,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的就绪的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*7-1 判断，当前就绪的文件描述符是用于监听的*/</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> raddr_len = <span class="keyword">sizeof</span> raddr;</span><br><span class="line">                <span class="type">int</span> cfd = accept(curfd,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">                <span class="comment">// 得到新的用于通信的套接字，添加到epoll实例中，挂到epoll树上，下一轮循环就可以被检测到</span></span><br><span class="line">                ev.events = EPOLLIN;  <span class="comment">// 读事件，通信的套接字文件描述符，读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                <span class="comment">// ev 传递给epoll_ctl 会做一个拷贝(通过地址会将地址中结构体数据全部拷贝)，添加到epoll实例中</span></span><br><span class="line">                ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl():add&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/***********************************************/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*7-2 判断，当前就绪的文件描述符是用于通信的*/</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 通信逻辑</span></span><br><span class="line">                <span class="comment">// 接收客户端数据</span></span><br><span class="line">                <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span> buf);</span><br><span class="line">                <span class="type">int</span> len = recv(curfd,buf,<span class="keyword">sizeof</span> buf,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 客户端断开连接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端断开连接...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// 关闭通信的套接字文件描述符</span></span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;接收成功，客户端数据: %s \n&quot;</span>,buf);</span><br><span class="line">                    <span class="comment">// 发送数据给客户端，告知</span></span><br><span class="line">                    send(curfd,buf,len,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;recv()&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/***********************************************/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>client.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">1989</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[BUFSIZE];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;hello world, %d\n&quot;</span>, num++);</span><br><span class="line">        send(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        recv(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        <span class="comment">// 1s一次</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，运行结果如下：</p>
<p>客户端1，显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516153258.png" alt="image-20240516153258707"></p>
<p>客户端2，显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516153317.png" alt="image-20240516153317013"></p>
<p>服务端，显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516153244.png" alt="image-20240516153244096"></p>
<p><strong>解析</strong>：</p>
<p>当在服务器端循环调用<code>epoll_wait()</code>的时候，就会得到一个就绪列表，并通过该函数的第二个参数传出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>每当<code>epoll_wait()</code>函数返回一次，在<code>evs</code>中最多可以存储<code>size</code>个已就绪的文件描述符信息，但是在这个数组中实际存储的有效元素个数为<code>num</code>个，如果在这个<code>epoll</code>实例的红黑树中已就绪的文件描述符很多，并且<code>evs</code>数组无法将这些信息全部传出，那么这些信息会在下一次<code>epoll_wait()</code>函数返回的时候被传出</p>
<p>通过<code>evs</code>数组被传递出的每一个有效元素里边都包含了已就绪的文件描述符的相关信息，这些信息并不是凭空得来的，这取决于我们在往<code>epoll</code>实例中添加节点的时候，往节点中初始化了哪些数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line"><span class="comment">// 节点初始化</span></span><br><span class="line">ev.events = EPOLLIN;    </span><br><span class="line">ev.data.fd = lfd;	<span class="comment">// 使用了联合体中 fd 成员</span></span><br><span class="line"><span class="comment">// 添加待检测节点到epoll实例中</span></span><br><span class="line"><span class="type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br></pre></td></tr></table></figure>

<p>在添加节点的时候，需要对这个<code>struct epoll_event</code>类型的节点进行初始化，当这个节点对应的文件描述符变为已就绪状态，这些被传入的初始化信息就会被原样传出，这个对应关系必须要搞清楚</p>
<h4 id="4-epoll工作模式"><a href="#4-epoll工作模式" class="headerlink" title="4.epoll工作模式"></a>4.<code>epoll</code>工作模式</h4><h5 id="（1）水平工作模式"><a href="#（1）水平工作模式" class="headerlink" title="（1）水平工作模式"></a>（1）水平工作模式</h5><p>水平模式可以简称为<code>LT</code>模式，<code>LT（level triggered）</code>是<strong>缺省的工作方式</strong>，并且同时支持<code>block</code>和<code>no-block socket</code>。在这种做法中，内核通知使用者哪些文件描述符已经就绪，之后就可以对这些已就绪的文件描述符进行<code>IO</code>操作了。如果我们不作任何操作，内核还是会继续通知使用者</p>
<p>水平模式：</p>
<ul>
<li>读事件：如果文件描述符对应的读缓冲区还有数据，读事件就会被触发，<code>epoll_wait()</code>解除阻塞<ul>
<li>当读事件被触发，<code>epoll_wait()</code>解除阻塞，之后就可以接收数据了</li>
<li>如果接收数据的<code>buf</code>很小，不能全部将缓冲区数据读出，那么读事件会继续被触发，直到数据被全部读出，如果接收数据的内存相对较大，读数据的效率也会相对较高（减少了读数据的次数）</li>
<li>因为读数据是被动的，必须要通过读事件才能知道有数据到达了，因此<strong>对于读事件的检测是必须的</strong></li>
</ul>
</li>
<li>写事件：如果文件描述符对应的写缓冲区可写，写事件就会被触发，<code>epoll_wait()</code>解除阻塞<ul>
<li>当写事件被触发，<code>epoll_wait()</code>解除阻塞，之后就可以将数据写入到写缓冲区了</li>
<li>写事件的触发发生在写数据之前而不是之后，被写入到写缓冲区中的数据是由内核自动发送出去的</li>
<li>如果写缓冲区没有被写满，写事件会一直被触发</li>
<li>因为写数据是主动的，并且写缓冲区一般情况下都是可写的（缓冲区不满），因此对于写事件的检测不是必须的</li>
</ul>
</li>
</ul>
<p><strong>水平模式触发的特点</strong>：</p>
<ul>
<li><strong>重复通知</strong>：只要文件描述符仍然处于可读写状态，<code>epoll</code> 会不断地通知应用程序，无论是否已经对该描述符执行过读写操作。这意味着，如果数据可读，应用程序如果没有读取，<code>epoll_wait</code> 将会再次返回该文件描述符</li>
<li><strong>简化的事件处理</strong>：由于 <code>epoll</code> 在描述符准备好时会不断通知，应用程序的逻辑可以比较简单，无需担心错过事件。这也意味着应用程序在每次 <code>epoll_wait</code> 调用后都必须适当处理事件，否则会陷入重复通知的循环</li>
<li><strong>兼容性</strong>：水平触发模式的行为类似于传统的 <code>select</code> 和 <code>poll</code> 系统调用，使得从这些系统调用迁移到 <code>epoll</code> 的过程中，逻辑转换较为直接</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li><strong>不确定是否能一次性处理完所有数据</strong>：例如，当你希望接收缓冲区非空时就读取一些数据，但不想（或不需要）一次性将其清空</li>
<li><strong>多个线程处理同一文件描述符</strong>：在这种情况下，水平触发可以减少因竞态条件造成的复杂性，因为多个线程可能都会被告知文件描述符准备好了</li>
</ul>
<p><strong>实例程序</strong>：</p>
<p><code>server_epoll_LT.c</code><br><strong>重点</strong>：在这个实例程序中，因为通信逻辑部分用于接收数据的字符数组非常小，若客户端一次发送的数据非常多，那么一次无法将缓冲区的数据全部读取出来，由于水平出发模式关于这个通信的套接字文件描述符的读事件会继续被触发，直到数据全部读取出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERPORT <span class="string">&quot;1989&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.创建用于监听的套接字文件描述符*/</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2.服务端绑定本机IP与端口信息*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr,<span class="number">0</span>,<span class="keyword">sizeof</span> server_addr);   <span class="comment">// 清0</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;server_addr.sin_addr);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="type">void</span> *)&amp;server_addr,<span class="keyword">sizeof</span> server_addr);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3.设置套接字属性，端口复用*/</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4.监听*/</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5.创建epoll对象实例，epoll树*/</span></span><br><span class="line">    <span class="type">int</span> para = <span class="number">100</span>;   <span class="comment">// 传入的参数&gt;0即可</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(para);</span><br><span class="line">    <span class="keyword">if</span>(epfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*6.将用于监听的套接字添加到epoll实例中*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span>  <span class="comment">// 事件结构体</span></span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 添加读事件，检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;       <span class="comment">// 将监听的套接字文件描述符添加</span></span><br><span class="line">    ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DEBUG信息</span></span><br><span class="line">    <span class="comment">// printf(&quot;DE<span class="doctag">BUG:</span> %s:%d\n&quot;,__FILE__,__LINE__);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*7.检测添加到epoll实例的文件描述符是否就绪*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次，检测一次，传入evs结构体数组，里面存储了已经就绪的文件描述符信息</span></span><br><span class="line">        <span class="comment">// 参数3，size evs结构体数组容量</span></span><br><span class="line">        <span class="comment">// 参数4，-1   结构体数组中直到有就绪的文件描述符才解除阻塞</span></span><br><span class="line">        <span class="comment">// return, num  为就绪的文件描述符数量</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd,evs,size,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的就绪的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*7-1 判断，当前就绪的文件描述符是用于监听的*/</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> raddr_len = <span class="keyword">sizeof</span> raddr;</span><br><span class="line">                <span class="type">int</span> cfd = accept(curfd,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">                <span class="comment">// 得到新的用于通信的套接字，添加到epoll实例中，挂到epoll树上，下一轮循环就可以被检测到</span></span><br><span class="line">                ev.events = EPOLLIN;  <span class="comment">// 读事件，通信的套接字文件描述符，读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl():add&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">/***********************************************/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/*7-2 判断，当前就绪的文件描述符是用于通信的*/</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 通信逻辑</span></span><br><span class="line">                <span class="comment">// 接收客户端数据</span></span><br><span class="line">                <span class="comment">// 重点，接收数据的buf容量非常小</span></span><br><span class="line">                <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span> buf);</span><br><span class="line">                <span class="type">int</span> len = recv(curfd,buf,<span class="keyword">sizeof</span> buf,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 客户端断开连接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端断开连接...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// 关闭通信的套接字文件描述符</span></span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;接收成功，客户端数据: %s \n&quot;</span>,buf);</span><br><span class="line">                    <span class="comment">// 发送数据给客户端，告知</span></span><br><span class="line">                    send(curfd,buf,len,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;recv()&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/***********************************************/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>client_epoll_LT.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">1989</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">size_t</span> send_len;</span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        fgets(recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="built_in">stdin</span>);</span><br><span class="line">        send_len = <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>;</span><br><span class="line">        send(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            len = recv(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf),<span class="number">0</span>);</span><br><span class="line">            send_len -= len;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;<span class="keyword">while</span>(send_len &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行如下：</p>
<p>客户端显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516163658.png" alt="image-20240516163658084"></p>
<p>服务端显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516163722.png" alt="image-20240516163722162"></p>
<h5 id="（2）边沿工作模式"><a href="#（2）边沿工作模式" class="headerlink" title="（2）边沿工作模式"></a>（2）边沿工作模式</h5><p>边沿模式可以简称为<code>ET</code>模式，<code>ET（edge-triggered）</code>是高速工作方式，只支持<code>no-block socket</code>。在这种模式下，当文件描述符从未就绪变为就绪时，内核会通过<code>epoll</code>通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知<code>（only once）</code>。如果我们对这个文件描述符做<code>IO</code>操作，从而导致它再次变成未就绪，当这个未就绪的文件描述符再次变成就绪状态，内核会再次进行通知，并且还是只通知一次。<code>ET</code>模式在很大程度上减少了<code>epoll</code>事件被重复触发的次数，因此效率要比<code>LT</code>模式高</p>
<p><strong>边沿模式</strong>：</p>
<ul>
<li><p><strong>读事件</strong>：当读缓冲区有新的数据进入，读事件被触发一次，没有新数据不会触发该事件</p>
<ul>
<li><p>如果有新数据进入到读缓冲区，读事件被触发，<code>epoll_wait()</code>解除阻塞</p>
</li>
<li><p>读事件被触发，可以通过调用<code>read()/recv()</code>函数将缓冲区数据读出</p>
<p>如果数据没有被全部读走，并且没有新数据进入，读事件不会再次触发，只通知一次</p>
<p>如果数据被全部读走或者只读走一部分，此时有新数据进入，读事件被触发，并且只通知一次</p>
</li>
</ul>
</li>
<li><p><strong>写事件</strong>：当写缓冲区状态可写，写事件只会触发一次</p>
<ul>
<li><p>如果写缓冲区被检测到可写，写事件被触发，<code>epoll_wait()</code>解除阻塞</p>
</li>
<li><p>写事件被触发，就可以通过调用<code>write()/send()</code>函数，将数据写入到写缓冲区中</p>
<p>写缓冲区从不满到被写满，期间写事件只会被触发一次</p>
<p>写缓冲区从满到不满，状态变为可写，写事件只会被触发一次</p>
</li>
</ul>
</li>
</ul>
<p>综上所述：<code>epoll</code>的边沿模式下 <code>epoll_wait()</code>检测到文件描述符有新事件才会通知，如果不是新的事件就不通知，通知的次数比水平模式少，效率比水平模式要高</p>
<p><strong>边沿触发模式特点</strong>：</p>
<ul>
<li><strong>单次通知</strong>：<strong>当文件描述符从非就绪状态变为就绪状态时</strong>，<code>epoll</code> 会通知应用程序一次。一旦通知发生，即使文件描述符仍然处于就绪状态，<code>epoll</code> 不会再次通知应用程序，除非状态再次发生变化</li>
<li><strong>高效率</strong>：边沿触发模式可以减少系统调用的次数，因为它只在状态变化时发出通知。这减少了应用程序不必要的检查和轮询，特别是在高负载情况下</li>
<li><strong>复杂的事件处理</strong>：使用边沿触发模式要求应用程序必须能够处理所有的数据，直到资源耗尽（例如读取直到遇到 <code>EAGAIN </code>错误）。这需要应用程序具有更复杂的逻辑来确保数据的完全处理</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li><strong>高并发服务器</strong>：在高负载环境下，边沿触发可以显著减少不必要的事件处理，提高服务器效率。</li>
<li><strong>应用程序能够一次处理所有数据</strong>：应用程序需要设计为能够处理尽可能多的数据，直到没有更多数据可读（或可写），以避免遗漏数据。</li>
</ul>
<h6 id="ET模式的设置"><a href="#ET模式的设置" class="headerlink" title="ET模式的设置"></a>ET模式的设置</h6><p>边沿模式不是默认的<code>epoll</code>模式，需要额外进行设置。<code>epoll</code>设置边沿模式是非常简单的，<code>epoll</code>管理的红黑树示例中每个节点都是<code>struct epoll_event</code>类型，只需要将<code>EPOLLET</code>添加到结构体的<code>events</code>成员中即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLET;	<span class="comment">// 设置边沿模式</span></span><br></pre></td></tr></table></figure>

<p>示例代码，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">    <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">    <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">    <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 建立新的连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">        <span class="comment">// 读缓冲区是否有数据, 并且将文件描述符设置为边沿模式</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">        ev.events = EPOLLIN | EPOLLET;   <span class="comment">// 设置事件触发模式为边沿触发</span></span><br><span class="line">        ev.data.fd = cfd;</span><br><span class="line">        ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="设置非阻塞"><a href="#设置非阻塞" class="headerlink" title="设置非阻塞"></a>设置非阻塞</h6><p>对于写事件的触发一般情况下是不需要进行检测的，因为写缓冲区大部分情况下都是有足够的空间可以进行数据的写入。对于读事件的触发就必须要检测了，因为服务器也不知道客户端什么时候发送数据，如果使用<code>epoll</code>的边沿模式进行读事件的检测，有新数据达到只会通知一次，那么<strong>必须要保证得到通知后将数据全部从读缓冲区中读出。那么，应该如何读这些数据呢</strong>？</p>
<p><strong>方法1</strong>：准备一块特别大的内存，用于存储从读缓冲区中读出的数据，但是这种方式有很大的弊端：</p>
<ul>
<li>内存的大小没有办法界定，太大浪费内存，太小又不够用</li>
<li>系统能够分配的最大堆内存也是有上限的，栈内存就更不必多言了</li>
</ul>
<p><strong>方法2</strong>：<strong>循环接收数据</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 数据处理...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做也是有弊端的，因为套接字操作默认是阻塞的，当读缓冲区数据被读完之后，读操作就阻塞了也就是调用的<code>read()/recv()</code>函数被阻塞了，当前进程&#x2F;线程被阻塞之后就无法处理其他操作了</p>
<p>要解决阻塞问题，就需要将套接字默认的阻塞行为修改为非阻塞，需要使用<code>fcntl()</code>函数进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置完成之后, 读写都变成了非阻塞模式</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;                                                        </span><br><span class="line">fcntl(cfd, F_SETFL, flag);</span><br></pre></td></tr></table></figure>

<p>通过上述分析就可以得出一个结论：**<code>epoll</code>在边沿模式下，必须要将套接字设置为非阻塞模式**，但是，这样就会引发另外的一个<code>bug</code>，在非阻塞模式下，循环地将读缓冲区数据读到本地内存中，当缓冲区数据被读完了，调用的<code>read()/recv()</code>函数还会继续从缓冲区中读数据，此时函数调用就失败了，返回-1，对应的全局变量 <code>errno </code>值为<code> EAGAIN</code> 或者 <code>EWOULDBLOCK</code>如果打印错误信息会得到如下的信息：<code>Resource temporarily unavailable</code></p>
<p><strong>因此可以通过非阻塞状态下的套接字<code>errno</code>的判断，什么时候缓冲区的数据全部读取完毕</strong></p>
<p><strong>检查<code>recv</code>的返回值</strong>：</p>
<p><code>recv</code> 函数的返回值可以提供关于读取状态的直接信息：</p>
<ul>
<li>如果返回<strong>正数</strong>，这代表读取到的字节数。如果这个数小于你请求的字节数（第三个参数），这通常意味着缓冲区中没有更多的数据可读（或者数据正好被读完）</li>
<li>如果返回<strong>0</strong>，表示对端已经关闭了连接。在TCP协议中，这意味着对端的套接字已经执行了正常的关闭过程</li>
<li><strong>如果返回</strong>-1<strong>，并且 <code>errno</code> 设置为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>，表示没有数据可读，且套接字被设置为非阻塞模式。此时，可以认为之前已经读取了所有可用数据</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞模式下recv() / read()函数返回值 len == -1</span></span><br><span class="line"><span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例程序</strong>：</p>
<p><code>server_epoll_ET.c</code></p>
<p>将用于通信的套接字文件描述符的事件触发方式设置为边沿触发，并且将套接字的文件属性设置为非阻塞，这样在使用<code>recv</code>函数读取，通信套接字文件描述符的读缓冲区，没有数据时，不会存在阻塞的情况；但是这时，需要通过<code>errno</code>来判断，读缓冲区的数据是否全部读取完毕</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERPORT <span class="string">&quot;1989&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.创建用于监听的套接字文件描述符*/</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2.服务端绑定本机IP与端口信息*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr,<span class="number">0</span>,<span class="keyword">sizeof</span> server_addr);   <span class="comment">// 清0</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;server_addr.sin_addr);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="type">void</span> *)&amp;server_addr,<span class="keyword">sizeof</span> server_addr);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3.设置套接字属性，端口复用*/</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4.监听*/</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5.创建epoll对象实例，epoll树*/</span></span><br><span class="line">    <span class="type">int</span> para = <span class="number">100</span>;   <span class="comment">// 传入的参数&gt;0即可</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(para);</span><br><span class="line">    <span class="keyword">if</span>(epfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*6.将用于监听的套接字添加到epoll实例中*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span>  <span class="comment">// 事件结构体</span></span><br><span class="line">    <span class="comment">// （监听套接字事件触发模式可以设置为边沿触发，也可以不设置）</span></span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 添加读事件，检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;       <span class="comment">// 将监听的套接字文件描述符添加</span></span><br><span class="line">    ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DEBUG信息</span></span><br><span class="line">    <span class="comment">// printf(&quot;DE<span class="doctag">BUG:</span> %s:%d\n&quot;,__FILE__,__LINE__);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*7.检测添加到epoll实例的文件描述符是否就绪*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次，检测一次，传入evs结构体数组，里面存储了已经就绪的文件描述符信息</span></span><br><span class="line">        <span class="comment">// 参数3，size evs结构体数组容量</span></span><br><span class="line">        <span class="comment">// 参数4，-1   结构体数组中直到有就绪的文件描述符才解除阻塞</span></span><br><span class="line">        <span class="comment">// return, num  为就绪的文件描述符数量</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd,evs,size,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的就绪的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*7-1 判断，当前就绪的文件描述符是用于监听的*/</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> raddr_len = <span class="keyword">sizeof</span> raddr;</span><br><span class="line">                <span class="type">int</span> cfd = accept(curfd,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">                <span class="comment">// 重点：将用于通信的套接字文件符属性设置为非阻塞</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd,F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd,F_SETFL,flag);</span><br><span class="line">                <span class="comment">// 得到新的用于通信的套接字，添加到epoll实例中，挂到epoll树上，下一轮循环就可以被检测到</span></span><br><span class="line">                <span class="comment">// 重点：将通信的套接字文件描述符事件触发方式设置为边沿触发</span></span><br><span class="line">                ev.events = EPOLLIN|EPOLLET;  <span class="comment">// 读事件，通信的套接字文件描述符，读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl():add&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">/***********************************************/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/*7-2 判断，当前就绪的文件描述符是用于通信的*/</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 通信逻辑</span></span><br><span class="line">                <span class="comment">// 接收客户端数据</span></span><br><span class="line">                <span class="comment">// 重点，接收数据的buf容量非常小</span></span><br><span class="line">                <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span> buf);</span><br><span class="line">                <span class="comment">// 循环接收，通信套接字文件描述符读缓冲区中，没有读取完的数据</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> len = recv(curfd,buf,<span class="keyword">sizeof</span> buf,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 客户端断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开连接...\n&quot;</span>);</span><br><span class="line">                        <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                        epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="comment">// 关闭通信的套接字文件描述符</span></span><br><span class="line">                        close(curfd);</span><br><span class="line">                        <span class="comment">// 跳出接收循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;接收成功，客户端数据: %s \n&quot;</span>,buf);</span><br><span class="line">                        <span class="comment">// 发送数据给客户端，告知</span></span><br><span class="line">                        send(curfd,buf,len,<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// len == -1</span></span><br><span class="line">                        <span class="comment">// 套接字属性为非阻塞情况下，判断errno == EAGAIN，表示套接字读缓冲区为空</span></span><br><span class="line">                        <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">                            <span class="comment">// 没有数据了，跳出循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            perror(<span class="string">&quot;recv()&quot;</span>);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/***********************************************/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>client_epoll_ET.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">1989</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">size_t</span> send_len;</span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        fgets(recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="built_in">stdin</span>);</span><br><span class="line">        send_len = <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>;</span><br><span class="line">        send(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            len = recv(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf),<span class="number">0</span>);</span><br><span class="line">            send_len -= len;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;<span class="keyword">while</span>(send_len &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<p>服务端显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516193440.png" alt="image-20240516193440105"></p>
<p>客户端1显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516193453.png" alt="image-20240516193452988"></p>
<p>客户端2显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516193519.png" alt="image-20240516193519384"></p>
<h6 id="基于多线程的边沿非阻塞服务端"><a href="#基于多线程的边沿非阻塞服务端" class="headerlink" title="基于多线程的边沿非阻塞服务端"></a>基于多线程的边沿非阻塞服务端</h6><p><code>server_epoll_LT_Thread.c</code></p>
<p>当调用<code>epoll_wait</code>得知此时有套接字文件描述符处于就绪状态，并且进一步<strong>判断发现就绪的套接字文件描述符为用于监听的，则将接受客户端连接，并且创建用于通信的套接字文件描述符，将之添加至<code>epoll</code>实例中等操作，全部放到子线程中去操作</strong>；<strong>判断发现就绪的套接字文件描述符为用于通信的，则将与客户端进行通信的逻辑操作全部放到子线程中执行</strong></p>
<p><strong>重点</strong>：<code>epoll</code>函数均是线程安全的，因此对使用<code>epoll</code>相关函数不需要添加线程锁，但是若存在其他与<code>epoll</code>无关的共享资源，仍然需要加锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERPORT <span class="string">&quot;1989&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">socketinfo</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;   <span class="comment">// 子线程认为函数需要的套接字文件描述符，监听或者通信</span></span><br><span class="line">    <span class="type">int</span> epfd; <span class="comment">// epoll实例</span></span><br><span class="line">&#125;SocketInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于接受客户端连接的子线程任务函数*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">acceptConn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印子线程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;acceptConn id: %ld\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socketinfo</span> *<span class="title">info</span> =</span> (<span class="keyword">struct</span> socketinfo *)arg;</span><br><span class="line">    <span class="comment">// 建立新连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len = <span class="keyword">sizeof</span> raddr;</span><br><span class="line">    <span class="type">int</span> cfd = accept(info-&gt;fd,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">    <span class="comment">// 重点：将用于通信的套接字文件符属性设置为非阻塞</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(cfd,F_GETFL);</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    fcntl(cfd,F_SETFL,flag);</span><br><span class="line">    <span class="comment">// 得到新的用于通信的套接字，添加到epoll实例中，挂到epoll树上，下一轮循环就可以被检测到</span></span><br><span class="line">    <span class="comment">// 重点：将通信的套接字文件描述符事件触发方式设置为边沿触发</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = EPOLLIN|EPOLLET;  <span class="comment">// 读事件，通信的套接字文件描述符，读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = cfd;</span><br><span class="line">    <span class="type">int</span> ret = epoll_ctl(info-&gt;epfd,EPOLL_CTL_ADD,cfd,&amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl():add&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">free</span>(info);</span><br><span class="line">    <span class="comment">// 线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// return NULL;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于与客户端通信的子线程任务函数*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Communication</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socketinfo</span> *<span class="title">info</span> =</span> (<span class="keyword">struct</span> socketinfo *)arg;</span><br><span class="line">    <span class="comment">// 通信逻辑</span></span><br><span class="line">    <span class="comment">// 接收客户端数据</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="comment">// 循环接收，通信套接字文件描述符读缓冲区中，没有读取完的数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(info-&gt;fd,buf,<span class="keyword">sizeof</span> buf,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 客户端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%ld]: 客户端断开连接...\n&quot;</span>,pthread_self());</span><br><span class="line">            <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">            epoll_ctl(info-&gt;epfd, EPOLL_CTL_DEL, info-&gt;fd, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 关闭通信的套接字文件描述符</span></span><br><span class="line">            close(info-&gt;fd);</span><br><span class="line">            <span class="comment">// 跳出接收循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%ld]: 接收成功，客户端数据: %s \n&quot;</span>,pthread_self(),buf);</span><br><span class="line">            <span class="comment">// 发送数据给客户端，告知</span></span><br><span class="line">            send(info-&gt;fd,buf,len,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// len == -1</span></span><br><span class="line">            <span class="comment">// 套接字属性为非阻塞情况下，判断errno == EAGAIN，表示套接字读缓冲区为空</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[%ld]: 数据读完了...\n&quot;</span>,pthread_self());</span><br><span class="line">                <span class="comment">// 没有数据了，跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;recv()&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">free</span>(info);</span><br><span class="line">    <span class="comment">// 线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// return NULL;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.创建用于监听的套接字文件描述符*/</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2.服务端绑定本机IP与端口信息*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr,<span class="number">0</span>,<span class="keyword">sizeof</span> server_addr);   <span class="comment">// 清0</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;server_addr.sin_addr);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="type">void</span> *)&amp;server_addr,<span class="keyword">sizeof</span> server_addr);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3.设置套接字属性，端口复用*/</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4.监听*/</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5.创建epoll对象实例，epoll树*/</span></span><br><span class="line">    <span class="type">int</span> para = <span class="number">100</span>;   <span class="comment">// 传入的参数&gt;0即可</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(para);</span><br><span class="line">    <span class="keyword">if</span>(epfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*6.将用于监听的套接字添加到epoll实例中*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span>  <span class="comment">// 事件结构体</span></span><br><span class="line">    <span class="comment">// （监听套接字事件触发模式可以设置为边沿触发，也可以不设置）</span></span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 添加读事件，检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;       <span class="comment">// 将监听的套接字文件描述符添加</span></span><br><span class="line">    ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DEBUG信息</span></span><br><span class="line">    <span class="comment">// printf(&quot;DE<span class="doctag">BUG:</span> %s:%d\n&quot;,__FILE__,__LINE__);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*7.检测添加到epoll实例的文件描述符是否就绪*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次，检测一次，传入evs结构体数组，里面存储了已经就绪的文件描述符信息</span></span><br><span class="line">        <span class="comment">// 参数3，size evs结构体数组容量</span></span><br><span class="line">        <span class="comment">// 参数4，-1   结构体数组中直到有就绪的文件描述符才解除阻塞</span></span><br><span class="line">        <span class="comment">// return, num  为就绪的文件描述符数量</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd,evs,size,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的就绪的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            SocketInfo *info = (SocketInfo *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SocketInfo));</span><br><span class="line">            info-&gt;fd = curfd;</span><br><span class="line">            info-&gt;epfd = epfd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*7-1 判断，当前就绪的文件描述符是用于监听的*/</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 创建建立连接的子线程</span></span><br><span class="line">                <span class="type">pthread_t</span> acceptConn_tid;</span><br><span class="line">                pthread_create(&amp;acceptConn_tid,<span class="literal">NULL</span>,acceptConn,info);</span><br><span class="line">                <span class="comment">// 线程分离</span></span><br><span class="line">                pthread_detach(acceptConn_tid);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">/***********************************************/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/*7-2 判断，当前就绪的文件描述符是用于通信的*/</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 创建用于通信的子线程</span></span><br><span class="line">                <span class="type">pthread_t</span> Communicat_tid;</span><br><span class="line">                pthread_create(&amp;Communicat_tid,<span class="literal">NULL</span>,Communication,info);</span><br><span class="line">                <span class="comment">// 线程分离</span></span><br><span class="line">                pthread_detach(Communicat_tid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/***********************************************/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>client_epoll_LT_Thread.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">1989</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[BUFSIZE];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;hello world, %d\n&quot;</span>, num++);</span><br><span class="line">        send(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        recv(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        <span class="comment">// 5s一次</span></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，服务端需要链接线程库，其编译指令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc server_epoll_LT_Thread.c -o server_epoll_LT_Thread -pthread</span><br></pre></td></tr></table></figure>

<p>运行服务端，以及客户端，如下：</p>
<p>服务端显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516202312.png" alt="image-20240516202312866"></p>
<p>客户端1显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516202325.png" alt="image-20240516202324977"></p>
<p>客户端2显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20240516202352.png" alt="image-20240516202352904"></p>
<p><strong>重点</strong>：</p>
<p>在上面的程序中，每次接受一条数据都需要创建一个子线程，子线程的频繁创建，使得服务端效率低，因此可以在上面的基础上，使用线程池，提升服务端效率**<code>epoll</code>的<code>IO</code>多路复用结合线程池的方式的服务端**</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://maxswordsman.github.io">Maxswordsman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://maxswordsman.github.io/2023/08/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%80%9A%E4%BF%A1/">https://maxswordsman.github.io/2023/08/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%80%9A%E4%BF%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://maxswordsman.github.io" target="_blank">Maxswordsman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></div><div class="post_share"><div class="social-share" data-image="/image/head2.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch/Tensor%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/" title="Tensor数据转换为稀疏矩阵"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Tensor数据转换为稀疏矩阵</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%EF%BC%8810%EF%BC%89/" title="UNIX环境编程-多进程（10）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UNIX环境编程-多进程（10）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/Linux%E5%9F%BA%E7%A1%80/" title="Linux基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-28</div><div class="title">Linux基础</div></div></a></div><div><a href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-MAKEFILE%EF%BC%884%EF%BC%89/" title="UNIX环境编程-MAKEFILE（4）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">UNIX环境编程-MAKEFILE（4）</div></div></a></div><div><a href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%883%EF%BC%89/" title="UNIX环境编程-动态内存管理（3）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">UNIX环境编程-动态内存管理（3）</div></div></a></div><div><a href="/2023/12/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%EF%BC%8811%EF%BC%89/" title="UNIX环境编程-并发（11）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-25</div><div class="title">UNIX环境编程-并发（11）</div></div></a></div><div><a href="/2023/07/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86%EF%BC%885%EF%BC%89/" title="UNIX环境编程-数据结构部分（5）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-02</div><div class="title">UNIX环境编程-数据结构部分（5）</div></div></a></div><div><a href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%95%B0%E7%BB%84-%E5%87%BD%E6%95%B0-%E6%8C%87%E9%92%88%EF%BC%881%EF%BC%89/" title="UNIX环境编程-数组-函数-指针（1）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">UNIX环境编程-数组-函数-指针（1）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/head2.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Maxswordsman</div><div class="author-info__description">不颓好胜之心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/maxswordsman"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/maxswordsman" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2723937292@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://gitee.com/zhou-xuezhi" target="_blank" title="Gitee"><i class="iconfont  icon-gitee" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%80%9A%E4%BF%A1"><span class="toc-text">IO多路复用-多线程并发通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81select"><span class="toc-text">一、select</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%86%E8%8A%82%E6%8F%8F%E8%BF%B0"><span class="toc-text">1.细节描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-select%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86"><span class="toc-text">2.select并发处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">（1）处理流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81"><span class="toc-text">（2）通信代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%80%BB%E7%BB%93"><span class="toc-text">（3）总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9A%E7%BA%BF%E7%A8%8Bselect%E5%B9%B6%E5%8F%91"><span class="toc-text">3.多线程select并发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81poll"><span class="toc-text">二、poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81epoll"><span class="toc-text">三、epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">2.操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89epoll-create"><span class="toc-text">（1）epoll_create()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89epoll-ctl"><span class="toc-text">（2）epoll_ctl()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89epoll-wait"><span class="toc-text">（3）epoll_wait()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-epoll%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.epoll的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-text">（1）操作步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">（2）示例代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-epoll%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.epoll工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B0%B4%E5%B9%B3%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">（1）水平工作模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BE%B9%E6%B2%BF%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">（2）边沿工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ET%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-text">ET模式的设置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">设置非阻塞</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BE%B9%E6%B2%BF%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">基于多线程的边沿非阻塞服务端</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Maxswordsman</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>