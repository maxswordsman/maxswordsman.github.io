<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UNIX环境编程-标准IO （7） | Maxswordsman</title><meta name="author" content="Maxswordsman"><meta name="copyright" content="Maxswordsman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="UNIX环境编程-标准IO （7）IO：input &amp; output 一切实现的基础 IO分类：  stdio(标准IO)–优先使用 对于不同的系统均可以使用 sysio系统调用IO(文件IO)  标准IO优点：  移植性性好、合并系统调用（可以为读写做一个加速的机制） 在不同的系统下，标准IO所依赖的系统调用的函数不同  一、fopen()1.fprintffprintf 是 C 语">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX环境编程-标准IO （7）">
<meta property="og:url" content="https://maxswordsman.github.io/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%A0%87%E5%87%86IO%EF%BC%887%EF%BC%89/index.html">
<meta property="og:site_name" content="Maxswordsman">
<meta property="og:description" content="UNIX环境编程-标准IO （7）IO：input &amp; output 一切实现的基础 IO分类：  stdio(标准IO)–优先使用 对于不同的系统均可以使用 sysio系统调用IO(文件IO)  标准IO优点：  移植性性好、合并系统调用（可以为读写做一个加速的机制） 在不同的系统下，标准IO所依赖的系统调用的函数不同  一、fopen()1.fprintffprintf 是 C 语">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://maxswordsman.github.io/image/head2.webp">
<meta property="article:published_time" content="2023-08-02T13:00:00.000Z">
<meta property="article:modified_time" content="2023-08-02T13:00:00.000Z">
<meta property="article:author" content="Maxswordsman">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://maxswordsman.github.io/image/head2.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://maxswordsman.github.io/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%A0%87%E5%87%86IO%EF%BC%887%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UNIX环境编程-标准IO （7）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-02 21:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/head2.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Maxswordsman"><span class="site-name">Maxswordsman</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UNIX环境编程-标准IO （7）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-02T13:00:00.000Z" title="发表于 2023-08-02 21:00:00">2023-08-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-02T13:00:00.000Z" title="更新于 2023-08-02 21:00:00">2023-08-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/">C</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UNIX环境编程-标准IO （7）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />

<h2 id="UNIX环境编程-标准IO-（7）"><a href="#UNIX环境编程-标准IO-（7）" class="headerlink" title="UNIX环境编程-标准IO （7）"></a>UNIX环境编程-标准IO （7）</h2><p>IO：input &amp; output 一切实现的基础</p>
<p>IO分类：</p>
<ul>
<li>stdio(标准IO)–<strong>优先使用</strong> 对于不同的系统均可以使用</li>
<li>sysio系统调用IO(文件IO)</li>
</ul>
<p>标准IO优点：</p>
<ul>
<li>移植性性好、合并系统调用（可以为读写做一个加速的机制）</li>
<li>在不同的系统下，标准IO所依赖的系统调用的函数不同</li>
</ul>
<h3 id="一、fopen"><a href="#一、fopen" class="headerlink" title="一、fopen()"></a>一、fopen()</h3><h4 id="1-fprintf"><a href="#1-fprintf" class="headerlink" title="1.fprintf"></a>1.fprintf</h4><p><code>fprintf</code> 是 C 语言标准库中的一个函数，用于将格式化的数据输出到文件。它是 <code>printf</code> 函数的文件版本，<code>printf</code> 输出到标准输出，而 <code>fprintf</code> 可以输出到任意文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ... )</span>;</span><br><span class="line"><span class="comment">// fprintf()函数根据指定的format(格式)发送信息(参数)到由stream(流)指定的文件.因此fprintf()可以使得信息输出到指定的文件</span></span><br><span class="line"><span class="comment">// 如下:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    char name[20] = &quot;Mary&quot;;</span></span><br><span class="line"><span class="comment">    FILE *out;</span></span><br><span class="line"><span class="comment">    out = fopen( &quot;output.txt&quot;, &quot;w&quot; );</span></span><br><span class="line"><span class="comment">    if( out != NULL )</span></span><br><span class="line"><span class="comment">    fprintf( out, &quot;Hello %s\n&quot;, name );</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>参数的意义如下：</p>
<ul>
<li><code>stream</code>：这是一个指向 <code>FILE</code> 类型的指针，代表要写入的文件。可以是任何已打开的文件，包括 <code>stdout</code>。</li>
<li><code>format</code>：这是一个格式字符串，它定义了输出的格式。格式字符串可以包含普通字符和格式说明符。</li>
<li><code>...</code>：这是可变参数列表，它们的类型和数量由 <code>format</code> 字符串中的格式说明符决定。</li>
</ul>
<p>函数返回写入的字符数，或者在出错时返回一个负数。</p>
<p><strong>关于刷新缓冲区</strong>，C 语言标准库提供了 <code>fflush</code> 函数来刷新一个文件的缓冲区。如果你想立即将 <code>fprintf</code> 的输出发送到文件，<strong>而不等待缓冲区满或文件关闭，你可以使用 <code>fflush</code> 函数</strong>。</p>
<p><code>fflush</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fflush(FILE *stream);</span><br></pre></td></tr></table></figure>

<p><code>stream</code> 是你想刷新的文件的 <code>FILE</code> 指针。函数成功时返回0，出错时返回EOF。</p>
<p>示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    fflush(fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子首先打开一个文件用于写入，然后使用 <code>fprintf</code> 将一行文字写入文件，接着使用 <code>fflush</code> 将输出立即写入文件，最后关闭文件</p>
<p>在ubuntu终端可以使用<code>man fopen</code>查看<code>fopen()</code>函数相关信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>; <span class="comment">// FILE是一个文件类型的结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mode:</span></span><br><span class="line"><span class="comment">// r : Open text file for reading.  The stream is positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment">// r+: Open  for  reading and writing.  The stream is positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment">// w : Truncate file to zero length or create text  file  for  writing(文件存在则清空，文件不存在则创建,只是写入).The stream is positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment">// w+: Open  for  reading  and writing.  The file is created if it does not exist（相较w包含读写操作）, otherwise it is truncated.  The stream is  positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment">// a : Open  for  appending (writing at end of file)(在文件内容末尾进行内容追加).  The file is created if it does not exist.The stream is positioned at the  end of the file.</span></span><br><span class="line"><span class="comment">// a+: Open  for  reading  and appending (writing at end of file)(读写) The file is created if it does not exist.  Output is always appended to  the  end  of  the file.  POSIX is silent on what the initial read position is when using this mode.  For glibc,  the  initial file  position  for reading is at the beginning of the file, but for Android/BSD/MacOS, the initial file position for reading  is at the end of the file.</span></span><br></pre></td></tr></table></figure>

<p><code>Return</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upon  successful  completion  <span class="title function_">fopen</span><span class="params">()</span>,  <span class="title function_">fdopen</span><span class="params">()</span> and <span class="title function_">freopen</span><span class="params">()</span> <span class="keyword">return</span> a FILE pointer.  Otherwise, <span class="literal">NULL</span> is returned and errno is <span class="built_in">set</span> to indicate the error. </span><br><span class="line"><span class="comment">// 也会得到一个对应的errno </span></span><br></pre></td></tr></table></figure>

<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 当前并为创建 tem.txt文件</span></span><br><span class="line">	fp = fopen(<span class="string">&quot;./tem.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fopen() failed! errno = %d\n&quot;</span>,errno);</span><br><span class="line">		<span class="comment">// 异常退出</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;OK!&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行可执行文件输出:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fopen() failed! errno = <span class="number">2</span></span><br><span class="line"><span class="comment">// errno 可以进入 该目录查看 vim /usr/include/asm-generic/errno-base.h </span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307161950174.png" alt="image-20230716195033135"></p>
<p>这样不太方便，因为对于报错的errno有很多，如果这样进行使用，后续还需要进入该目录下，查看该errno所对应的报错信息是什么</p>
<h4 id="2-perror"><a href="#2-perror" class="headerlink" title="2.perror"></a>2.perror</h4><p>这个函数可以对errno报错的信息进行自动关联（自动关联全局变量errno）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       perror - print a system error message</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span> ;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 当前并为创建 tem.txt文件</span></span><br><span class="line">	fp = fopen(<span class="string">&quot;./tem.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// fprintf(stderr,&quot;fopen() failed! errno = %d\n&quot;,errno);</span></span><br><span class="line">		perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">		<span class="comment">// 异常退出</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;OK!&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行可执行文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash: ./fopen: 没有那个文件或目录</span><br></pre></td></tr></table></figure>



<h4 id="3-strerror"><a href="#3-strerror" class="headerlink" title="3.strerror"></a>3.strerror</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       strerror, strerror_r, strerror_l - <span class="keyword">return</span> <span class="built_in">string</span> describing error number</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 需要的参数是一个errno</span></span><br><span class="line">       <span class="type">char</span> *strerror(<span class="type">int</span> errnum);</span><br></pre></td></tr></table></figure>

<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 当前并为创建 tem.txt文件</span></span><br><span class="line">	fp = fopen(<span class="string">&quot;./tem.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// fprintf(stderr,&quot;fopen() failed! errno = %d\n&quot;,errno);</span></span><br><span class="line">		<span class="comment">// perror(&quot;fopen()&quot;); </span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fopen(): %s\n&quot;</span>,strerror(errno));</span><br><span class="line">		<span class="comment">// 异常退出</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;OK!&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行可执行文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash: ./fopen: 没有那个文件或目录</span><br></pre></td></tr></table></figure>



<h4 id="4-fopen相关问题"><a href="#4-fopen相关问题" class="headerlink" title="4.fopen相关问题"></a>4.fopen相关问题</h4><h5 id="（1）fopen返回的FILE类型指针指向的是哪一个空间"><a href="#（1）fopen返回的FILE类型指针指向的是哪一个空间" class="headerlink" title="（1）fopen返回的FILE类型指针指向的是哪一个空间"></a>（1）fopen返回的FILE类型指针指向的是哪一个空间</h5><p>栈  or 静态区 or 堆  答案： 堆上</p>
<ul>
<li><p>栈是局部变量存放的空间，不对 fopen返回的内容需要在整个程序（进程）运行期间均存在，所以不在栈上</p>
</li>
<li><p>静态区 用static修饰该FILE变量.如下,但是需要注意的是，如果fopen函数被重复调用的时候，这个<code>static FILE tmp;</code>只会被声明一次，则如果多次调用<code>fopen</code>函数那么之前所返回的FILE指针则会被覆盖，不能用，有效的则是最后调用的那个<code>fopen</code>函数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> FILE tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>堆上，如下，需要对所使用的内存空间进行动态开辟<code>malloc</code>,那么<code>fcolse</code>函数则是对这块动态开辟的空间进行释放</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *tmp = <span class="literal">NULL</span> ;</span><br><span class="line">    </span><br><span class="line">    tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FILE));</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、字符输入与输出"><a href="#二、字符输入与输出" class="headerlink" title="二、字符输入与输出"></a>二、字符输入与输出</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-standard-library-stdio-h.html">菜鸟教程</a></p>
<h4 id="1-模拟cp-指令将-src文件-复制到dest文件中"><a href="#1-模拟cp-指令将-src文件-复制到dest文件中" class="headerlink" title="1.模拟cp 指令将 src文件 复制到dest文件中"></a>1.模拟cp 指令将 src文件 复制到dest文件中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp src dest</span><br></pre></td></tr></table></figure>

<h5 id="（1）fgetc"><a href="#（1）fgetc" class="headerlink" title="（1）fgetc"></a>（1）fgetc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fgetc（）从流中读取下一个字符，并将其作为一个无符号字符返回，该字符转换为int，或文件末尾的EOF或error</span></span><br><span class="line"><span class="comment">从文件流中读取数据 ,并且返回</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="（2）fputc"><a href="#（2）fputc" class="headerlink" title="（2）fputc"></a>（2）fputc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C 库函数 int fputc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流stream 中，并把位置标识符往前移动</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="（3）实现代码"><a href="#（3）实现代码" class="headerlink" title="（3）实现代码"></a>（3）实现代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fps,*fpd;</span><br><span class="line">	<span class="type">int</span> ch;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 选择模式为 r表示源文件一定要存在 ，否则报错</span></span><br><span class="line">	fps = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fps == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 目标文件</span></span><br><span class="line">	fpd = fopen(argv[<span class="number">2</span>],<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fpd == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 从fps中读取数据</span></span><br><span class="line">		ch = fgetc(fps);</span><br><span class="line">		<span class="keyword">if</span>(ch == EOF) <span class="comment">// 读到文件末尾</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将原文件中读取的数据写入目标文件</span></span><br><span class="line">		fputc(ch,fpd);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fclose(fpd);</span><br><span class="line">	fclose(fps);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个<code>txt</code>文件分别文<code>src.txt</code>以及<code>dest.txt</code>,在<code>src.txt</code>下写入<code>123456</code>,<code>dest.txt</code>为空白</p>
<p>运行可执行文件<code>先在终端输入 (make mycpy)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mycpy src.txt dest.txt</span><br></pre></td></tr></table></figure>

<p>使用终端命令比较两个文件是否相同(Enter之后无任何输出表示两个文件是相同的)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diff src.txt dest.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171019147.png" alt="image-20230717101947123"></p>
<h4 id="2-测试文件中存在有效字符数量"><a href="#2-测试文件中存在有效字符数量" class="headerlink" title="2.测试文件中存在有效字符数量"></a>2.测试文件中存在有效字符数量</h4><p>实现代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="comment">// 用于字符个数计数	</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 命令行参数数量出错</span></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage ...\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fp = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 文件打开失败</span></span><br><span class="line">	<span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 循环在fp文件中读取字符，直到文件的终止符</span></span><br><span class="line">	<span class="keyword">while</span>(fgetc(fp) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;count = %d \n&quot;</span>,count);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行可执行文件</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171041612.png" alt="image-20230717104133589"></p>
<h4 id="3-字符串相关"><a href="#3-字符串相关" class="headerlink" title="3.字符串相关"></a>3.字符串相关</h4><h5 id="（1）fgets"><a href="#（1）fgets" class="headerlink" title="（1）fgets"></a>（1）fgets</h5><p>C 库函数 <strong>char *fgets(char *str, int n, FILE *stream)</strong> 从指定的流 stream 读取一行，并把它存储在 <strong>str</strong> 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span> ;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str</strong> – 这是指向一个字符数组的指针，该数组存储了要读取的字符串</li>
<li><strong>n</strong> – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流</li>
</ul>
<p>return</p>
<ul>
<li>该函数返回一个非负值，如果发生错误则返回 EOF</li>
</ul>
<h5 id="（2）fputs"><a href="#（2）fputs" class="headerlink" title="（2）fputs"></a>（2）fputs</h5><p>C 库函数 <strong>int fputs(const char *str, FILE *stream)</strong> 把字符串写入到指定的流 stream 中，但不包括空字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str</strong> – 这是一个数组，包含了要写入的以空字符终止的字符序列</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流</li>
</ul>
<p>return</p>
<ul>
<li>该函数返回一个非负值，如果发生错误则返回 EOF</li>
</ul>
<h4 id="4-fread-和-fwrite"><a href="#4-fread-和-fwrite" class="headerlink" title="4.fread 和 fwrite"></a>4.fread 和 fwrite</h4><h5 id="（1）fread"><a href="#（1）fread" class="headerlink" title="（1）fread"></a>（1）fread</h5><p>注意:fread只能操作工整的数据</p>
<p>C 库函数 <strong>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ptr</strong> – 这是指向带有最小尺寸 <em>size*nmemb</em> 字节的内存块的指针</li>
<li><strong>size</strong> – 这是要读取的每个元素(<strong>这个元素可以是结构体等</strong>)的大小，以字节为单位</li>
<li><strong>nmemb</strong> – 这是元素的个数，每个元素的大小为 size 字节</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流</li>
</ul>
<p>return</p>
<ul>
<li>成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾<strong>（返回值则会小于等于0）</strong></li>
</ul>
<p><strong>使用事项:</strong></p>
<p>一般都是一个字节一个字节的读取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fread(buf,<span class="number">1</span>,BUFSIZE,fps);</span><br><span class="line"><span class="comment">// BUFSIZE 为buf的字节数量，即大小</span></span><br></pre></td></tr></table></figure>



<h5 id="（2）fwrite"><a href="#（2）fwrite" class="headerlink" title="（2）fwrite"></a>（2）fwrite</h5><p>C 库函数 <strong>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ptr</strong> – 这是指向要被写入的元素数组的指针。</li>
<li><strong>size</strong> – 这是要被写入的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> – 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</li>
</ul>
<p>return</p>
<ul>
<li>如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误</li>
</ul>
<h4 id="5-printf与scanf函数族"><a href="#5-printf与scanf函数族" class="headerlink" title="5.printf与scanf函数族"></a>5.printf与scanf函数族</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171505832.png" alt="image-20230717150540800"></p>
<h5 id="（1）sprintf"><a href="#（1）sprintf" class="headerlink" title="（1）sprintf"></a>（1）sprintf</h5><p>C 库函数 <strong>int sprintf(char *str, const char *format, …)</strong> 发送格式化输出到 <strong>str</strong> 所指向的字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str</strong> – 这是指向一个字符数组的指针，该数组存储了 C 字符串。</li>
<li><strong>format</strong> – 这是字符串，包含了要被#写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</li>
</ul>
<h5 id="（2）snprintf"><a href="#（2）snprintf" class="headerlink" title="（2）snprintf"></a>（2）snprintf</h5><p>snprintf() 是一个 C 语言标准库函数，用于格式化输出字符串，并将结果写入到指定的缓冲区，与 sprintf() 不同的是，snprintf() 会限制输出的字符数，避免缓冲区溢出</p>
<p>C 库函数 <strong>int snprintf(char *str, size_t size, const char *format, …)</strong> 设将可变参数**(…)<strong>按照 <strong>format</strong> 格式化成字符串，并将字符串复制到 <strong>str</strong> 中，</strong>size** 为要写入的字符的最大数目，超过 <strong>size</strong> 会被截断，最多写入 size-1 个字符</p>
<p>与 <a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-sprintf.html">sprintf()</a> 函数不同的是，snprintf() 函数提供了一个参数 size，可以防止缓冲区溢出。如果格式化后的字符串长度超过了 size-1，则 snprintf() 只会写入 size-1 个字符，并在字符串的末尾添加一个空字符（\0）以表示字符串的结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span> <span class="params">( <span class="type">char</span> * str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> * format, ... )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str</strong> – 目标字符串，用于存储格式化后的字符串的字符数组的指针</li>
<li><strong>size</strong> – 字符数组的大小</li>
<li><strong>format</strong> – 格式化字符串</li>
<li><strong>…</strong> – 可变参数，可变数量的参数根据 format 中的格式化指令进行格式化</li>
</ul>
<p>return </p>
<ul>
<li><p>snprintf() 函数的返回值是输出到 str 缓冲区中的字符数，不包括字符串结尾的空字符 \0。如果 snprintf() 输出的字符数超过了 size 参数指定的缓冲区大小，则输出的结果会被截断，只有 size - 1 个字符被写入缓冲区，最后一个字符为字符串结尾的空字符 \0</p>
</li>
<li><p>需要注意的是，snprintf() 函数返回的字符数并不包括字符串结尾的空字符 \0，因此如果需要将输出结果作为一个字符串使用，则需要在缓冲区的末尾添加一个空字符 \0</p>
</li>
</ul>
<h5 id="（3）fscanf"><a href="#（3）fscanf" class="headerlink" title="（3）fscanf"></a>（3）fscanf</h5><p>C 库函数 <strong>int fscanf(FILE *stream, const char *format, …)</strong> 从流 stream 读取格式化输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流</li>
<li><strong>format</strong> – 这是 C 字符串，包含了以下各项中的一个或多个：<em>空格字符、非空格字符</em> 和 <em>format 说明符</em></li>
</ul>
<h5 id="（4）sscanf"><a href="#（4）sscanf" class="headerlink" title="（4）sscanf"></a>（4）sscanf</h5><p>C 库函数 <strong>int sscanf(const char *str, const char *format, …)</strong> 从字符串读取格式化输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str</strong> – 这是 C 字符串，是函数检索数据的源</li>
<li><strong>format</strong> – 这是 C 字符串，包含了以下各项中的一个或多个：<em>空格字符、非空格字符</em> 和 <em>format 说明符</em></li>
</ul>
<h4 id="6-文件位置函数和缓冲区刷新函数"><a href="#6-文件位置函数和缓冲区刷新函数" class="headerlink" title="6.文件位置函数和缓冲区刷新函数"></a>6.文件位置函数和缓冲区刷新函数</h4><p>在读取与写入的时候，存在文件位置指针</p>
<h5 id="（1）fseek"><a href="#（1）fseek" class="headerlink" title="（1）fseek"></a>（1）fseek</h5><p>C 库函数 <strong>int fseek(FILE *stream, long int offset, int whence)</strong> 设置流 <strong>stream</strong> 的文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>s<strong>tream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流</li>
<li><strong>offset</strong> – 这是相对 whence 的偏移量，以字节为单位</li>
<li><strong>whence</strong> – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一:</li>
</ul>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171555856.png" alt="image-20230717155519825"></p>
<p>return </p>
<ul>
<li>如果成功，则该函数返回零，否则返回非零值</li>
</ul>
<h5 id="（2）ftell"><a href="#（2）ftell" class="headerlink" title="（2）ftell"></a>（2）ftell</h5><p>C 库函数 <strong>long int ftell(FILE *stream)</strong> 返回给定流 stream 的当前文件位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流</li>
</ul>
<p>return </p>
<ul>
<li>该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值</li>
</ul>
<p><strong>使用实例:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 判断命令行传递参数数量</span></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Usage ...\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FILE *fp;</span><br><span class="line">	</span><br><span class="line">	fp = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (fp ==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 文件位置指针值于文件末尾处</span></span><br><span class="line">	fseek(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,ftell(fp));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建src.txt文件其中内容:<code>123456\0</code> 表示七个字节</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171606742.png" alt="image-20230717160628708"></p>
<p>运行可执行文件</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171607897.png" alt="image-20230717160711855"></p>
<h5 id="（3）rewind"><a href="#（3）rewind" class="headerlink" title="（3）rewind"></a>（3）rewind</h5><p><strong>使用这个函数可以直接让文件位置指针达到文件内容的开头</strong></p>
<p>C 库函数 <strong>void rewind(FILE *stream)</strong> 设置文件位置为给定流 <strong>stream</strong> 的文件的开头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流</li>
</ul>
<h5 id="（4）fflush"><a href="#（4）fflush" class="headerlink" title="（4）fflush"></a>（4）fflush</h5><p>C 库函数 <strong>int fflush(FILE *stream)</strong> 刷新流 stream 的输出缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流</li>
</ul>
<p>return </p>
<p>如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）</p>
<p><strong>测试代码:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Before while(1)..&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After while(1)..&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上述代码进行make,然后运行可执行文件，发现终端无输出</p>
<p><strong>原因</strong>: printf函数向标准终端进行输出时，是典型的行缓冲,是碰到换行符号或者一行满的时候以此来刷新缓冲区</p>
<p><strong>修正</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Before while(1)..\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After while(1)..\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码make之后运行会输出:<code>Before while(1)..</code></p>
<p><strong>使用fflush</strong>,强制刷新缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Before while(1)..&quot;</span>);</span><br><span class="line">	<span class="comment">// 将输出缓冲区进行刷新</span></span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After while(1)..&quot;</span>);</span><br><span class="line">	<span class="comment">// 将会刷新所有打开的流</span></span><br><span class="line">	fflush(<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>make之后终端运行</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171629228.png" alt="image-20230717162950203"></p>
<h5 id="（5）缓冲区存在的作用"><a href="#（5）缓冲区存在的作用" class="headerlink" title="（5）缓冲区存在的作用"></a>（5）缓冲区存在的作用</h5><p><strong>优点</strong></p>
<ul>
<li>行缓冲：换行的时候刷新,满了的时候刷新，强制刷新（标准输出就是这样，因为是终端设备）</li>
<li>全缓冲：满了的时候刷新，强制刷新（默认是，只要不是终端设备）</li>
<li>无缓冲：如stderr,需要立即输出的内容</li>
</ul>
<p>一个文件的缓冲模式默认为全缓冲模式，但是缓冲模式是可以进行修改的</p>
<h4 id="7-getline"><a href="#7-getline" class="headerlink" title="7.getline"></a>7.getline</h4><p>完整的获取文件一行的内容</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18p4y167Md?p=133&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a><br>完整的获取文件一行的内容</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18p4y167Md?p=133&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> GNU_SOURCE</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">getline</span><span class="params">(<span class="type">char</span> **lineptr, <span class="type">size_t</span> *n, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lineptr</code>：指向一个字符指针的指针，用于存储读取到的行。如果 <code>*lineptr</code> 是 NULL 或 <code>n</code> 是零，函数将为您分配一个新的缓冲区。当您完成使用后，需要使用 <code>free</code> 函数来释放这块内存</li>
<li><code>n</code>：是指向已分配的内存大小的指针。它可能会被函数修改，表示新分配的大小</li>
<li><code>stream</code>：是一个文件指针，指示从哪里读取数据，例如 <code>stdin</code></li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：返回读取的字符数量（不包括结尾的 null 字符）。</li>
<li>错误或读到文件结束：返回 <code>-1</code>。</li>
</ul>
<p>在编译程序时需要在CMakeLists.txt中添加该函数所需要的宏定义<code>_D_GNU_SOURCE</code></p>
<h5 id="（1）程序实例"><a href="#（1）程序实例" class="headerlink" title="（1）程序实例"></a>（1）程序实例</h5><p>读取文件内容</p>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        FILE *fp;</span><br><span class="line">        <span class="type">char</span> *linebuf;</span><br><span class="line">        <span class="type">size_t</span> linesize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;USage..\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fp = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*getline函数至关重要的初始化*/</span></span><br><span class="line">        linebuf = <span class="literal">NULL</span>;</span><br><span class="line">        linesize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(getline(&amp;linebuf,&amp;linesize,fp) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前行的字符数打印</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,<span class="built_in">strlen</span>(linebuf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,linesize);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用getline函数其参数的初始化是至关重要的，如果没有做好，会出现初始化</p>
<p>CMakeLists.txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.16</span>)</span><br><span class="line">project(getline_test)    # 工程名字可以与可执行程序名不一样</span><br><span class="line">add_executable(main main.c)</span><br><span class="line">target_compile_definitions(main PRIVATE -D_GNU_SOURCE)</span><br></pre></td></tr></table></figure>

<p>创建src.txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhouxuezhi</span><br><span class="line">comeno</span><br><span class="line">wanglei</span><br><span class="line">comeno</span><br></pre></td></tr></table></figure>

<p>CMake之后运行程序,查看结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，getline内部实际使用的malloc开辟动态的内存空间存储，读取到的内容（<code>linebuf</code>），并且当一行内容超过120字节时，则会使用realloc，在之前的malloc开辟的空间基础上继续增加120个字节的内容（类推）</p>
<p><strong>内存泄漏</strong>，getline存在可控的内存泄漏，因为函数内部使用malloc开辟动态内存空间，但是最后并没有使用free函数将开辟的内存空间自动释放</p>
<h5 id="（2）mygetline函数实现"><a href="#（2）mygetline函数实现" class="headerlink" title="（2）mygetline函数实现"></a>（2）mygetline函数实现</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lvlvituotuo/article/details/52832975">原文链接</a></p>
<p>返回类型ssize_t为有符号整形,其值为获取的字符数，文件结束则返回-1，包括换行符’\n’，但不包括字符串结束符’\0’。linepter用来存储获得的字符串，size_t为无符号整形表示linepter的字节数。当*linepter为空时函数则动态为其分配空间，注意要将size_t值赋0。当linepter的空间不足时，函数会通过realloc，重新分配更大的空间。stream为文件指针，用于读取文件<br>mygetline.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYGETLINE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYGETLINE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mygetline</span><span class="params">(<span class="type">char</span>** line,<span class="type">size_t</span> *n,FILE *fp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mygetline_free</span><span class="params">(<span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>mygetline.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mygetline.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mygetline</span><span class="params">(<span class="type">char</span>** line,<span class="type">size_t</span> *n,FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> *buf = *line;</span><br><span class="line">        <span class="comment">// i to record string length, c to store characters</span></span><br><span class="line">        <span class="type">ssize_t</span> c,i=<span class="number">0</span>,init_bufsize=<span class="number">120</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Opening up memory space</span></span><br><span class="line">        <span class="keyword">if</span>(buf == <span class="literal">NULL</span> || *n = <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                *line = <span class="built_in">malloc</span>(<span class="number">120</span>);</span><br><span class="line">                buf = *line;</span><br><span class="line">                *n = <span class="number">120</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read data</span></span><br><span class="line">        <span class="keyword">while</span>((c=getc(fp))!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Read to the end of the file</span></span><br><span class="line">                <span class="keyword">if</span>(c==EOF)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Two spaces need to be left for characters &#x27;\n&#x27; and &#x27;\0&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;(*n)<span class="number">-2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        *buf+i = c;</span><br><span class="line">                        i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// The number of bytes in a row exceeds 120</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        *n = *n + init_bufsize;</span><br><span class="line">                        <span class="comment">// Insufficient initial allocated space, reallocating memory space with 120 bytes added each time</span></span><br><span class="line">                        buf = <span class="built_in">realloc</span>(buf,*n)</span><br><span class="line">                        *buf+i = c;</span><br><span class="line">                        i++;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Fill in the characters &#x27;\0&#x27; and &#x27;\n&#x27; of the line in buf</span></span><br><span class="line">        *(buf+i++) = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        *(buf+i++) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mygetline_free</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mygetline.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        FILE *fp;</span><br><span class="line">        <span class="type">char</span> *linebuf;</span><br><span class="line">        <span class="type">size_t</span> linesize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;USage..\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fp = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*getline函数至关重要的初始化*/</span></span><br><span class="line">        linebuf = <span class="literal">NULL</span>;</span><br><span class="line">        linesize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(mygetline(&amp;linebuf,&amp;linesize,fp) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前行的字符数打印</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,<span class="built_in">strlen</span>(linebuf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,linesize);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        mygetline_free(linebuf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工程目录结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@ubuntu:~/Proj/C_C++/linux_c/sys/getline_test$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── mygetline.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">├── src</span><br><span class="line">│   └── mygetline.c</span><br><span class="line">└── src.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.16</span>)</span><br><span class="line">project(getline_test)</span><br><span class="line"># Output General Information</span><br><span class="line"><span class="title function_">message</span><span class="params">(<span class="string">&quot;PROJECT_SOURCE_DIR = $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span></span><br><span class="line"><span class="title function_">message</span><span class="params">(<span class="string">&quot;CMAKE_CURRENT_SOURCE_DIR = $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span></span><br><span class="line"># Define the output path <span class="keyword">for</span> executable files</span><br><span class="line"><span class="title function_">set</span><span class="params">(HOME $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span></span><br><span class="line"># Include header files</span><br><span class="line"><span class="title function_">include_directories</span><span class="params">($&#123;PROJECT_SOURCE_DIR&#125;/include)</span></span><br><span class="line"><span class="meta"># search for file</span></span><br><span class="line"><span class="title function_">file</span><span class="params">(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src<span class="comment">/*.c)</span></span></span><br><span class="line"><span class="comment"><span class="params"># Set the generation path for static libraries</span></span></span><br><span class="line"><span class="comment"><span class="params">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span></span></span><br><span class="line"><span class="comment"><span class="params"># Specify the output path of the executable file</span></span></span><br><span class="line"><span class="comment"><span class="params">set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;)</span></span></span><br><span class="line"><span class="comment"><span class="params"># Create a static library</span></span></span><br><span class="line"><span class="comment"><span class="params">add_library(calc STATIC $&#123;SRC_LIST&#125;)</span></span></span><br><span class="line"><span class="comment"><span class="params"># Generating Target Files</span></span></span><br><span class="line"><span class="comment"><span class="params">add_executable(main main.c)</span></span></span><br><span class="line"><span class="comment"><span class="params"># link static library</span></span></span><br><span class="line"><span class="comment"><span class="params">target_link_libraries(main calc)</span></span></span><br><span class="line"><span class="comment"><span class="params">target_compile_definitions(main PRIVATE -D_GNU_SOURCE)</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@ubuntu:~/Proj/C_C++/linux_c/sys/getline_test/bin$ ./main ../src.txt </span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure>

<p>运行结果与getline函数相同</p>
<h4 id="8-临时文件"><a href="#8-临时文件" class="headerlink" title="8.临时文件"></a>8.临时文件</h4><h5 id="（1）tmpfile"><a href="#（1）tmpfile" class="headerlink" title="（1）tmpfile"></a>（1）tmpfile</h5><p>C 库函数 <strong>FILE *tmpfile(void)</strong> 以二进制更新模式(wb+)创建临时文件。被创建的临时文件会在流关闭的时候或者在程序终止的时候自动删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>return</p>
<p>如果成功，该函数返回一个指向被创建的临时文件的流指针。如果文件未被创建，则返回 NULL</p>
<p><strong>实例代码:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line"></span><br><span class="line">   fp = tmpfile();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;临时文件被创建\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 您可以在这里使用临时文件 */</span></span><br><span class="line"></span><br><span class="line">   fclose(fp);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们编译并运行上面的程序，它将在 &#x2F;tmp 文件夹中创建一个临时文件，但是一旦程序退出，临时文件会被自动删除</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://maxswordsman.github.io">Maxswordsman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://maxswordsman.github.io/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%A0%87%E5%87%86IO%EF%BC%887%EF%BC%89/">https://maxswordsman.github.io/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%A0%87%E5%87%86IO%EF%BC%887%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://maxswordsman.github.io" target="_blank">Maxswordsman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></div><div class="post_share"><div class="social-share" data-image="/image/head2.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8IO%EF%BC%888%EF%BC%89/" title="UNIX环境编程-系统调用IO（8）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UNIX环境编程-系统调用IO（8）</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86%EF%BC%885%EF%BC%89/" title="UNIX环境编程-数据结构部分（5）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UNIX环境编程-数据结构部分（5）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/14/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-IPV4-%E6%B5%81%E5%AA%92%E4%BD%93%E9%A1%B9%E7%9B%AE%EF%BC%8814%EF%BC%89/" title="UNIX环境编程-IPV4-流媒体项目（网络多播）（14）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-14</div><div class="title">UNIX环境编程-IPV4-流媒体项目（网络多播）（14）</div></div></a></div><div><a href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-MAKEFILE%EF%BC%884%EF%BC%89/" title="UNIX环境编程-MAKEFILE（4）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">UNIX环境编程-MAKEFILE（4）</div></div></a></div><div><a href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%883%EF%BC%89/" title="UNIX环境编程-动态内存管理（3）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">UNIX环境编程-动态内存管理（3）</div></div></a></div><div><a href="/2023/12/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%EF%BC%8811%EF%BC%89/" title="UNIX环境编程-并发（11）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-25</div><div class="title">UNIX环境编程-并发（11）</div></div></a></div><div><a href="/2023/07/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86%EF%BC%885%EF%BC%89/" title="UNIX环境编程-数据结构部分（5）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-02</div><div class="title">UNIX环境编程-数据结构部分（5）</div></div></a></div><div><a href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%95%B0%E7%BB%84-%E5%87%BD%E6%95%B0-%E6%8C%87%E9%92%88%EF%BC%881%EF%BC%89/" title="UNIX环境编程-数组-函数-指针（1）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">UNIX环境编程-数组-函数-指针（1）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/head2.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Maxswordsman</div><div class="author-info__description">不颓好胜之心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/maxswordsman"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/maxswordsman" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2723937292@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://gitee.com/zhou-xuezhi" target="_blank" title="Gitee"><i class="iconfont  icon-gitee" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%A0%87%E5%87%86IO-%EF%BC%887%EF%BC%89"><span class="toc-text">UNIX环境编程-标准IO （7）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81fopen"><span class="toc-text">一、fopen()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-fprintf"><span class="toc-text">1.fprintf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-perror"><span class="toc-text">2.perror</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-strerror"><span class="toc-text">3.strerror</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-fopen%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-text">4.fopen相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89fopen%E8%BF%94%E5%9B%9E%E7%9A%84FILE%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B4"><span class="toc-text">（1）fopen返回的FILE类型指针指向的是哪一个空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-text">二、字符输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A8%A1%E6%8B%9Fcp-%E6%8C%87%E4%BB%A4%E5%B0%86-src%E6%96%87%E4%BB%B6-%E5%A4%8D%E5%88%B6%E5%88%B0dest%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-text">1.模拟cp 指令将 src文件 复制到dest文件中</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89fgetc"><span class="toc-text">（1）fgetc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89fputc"><span class="toc-text">（2）fputc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-text">（3）实现代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E6%95%B0%E9%87%8F"><span class="toc-text">2.测试文件中存在有效字符数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3"><span class="toc-text">3.字符串相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89fgets"><span class="toc-text">（1）fgets</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89fputs"><span class="toc-text">（2）fputs</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-fread-%E5%92%8C-fwrite"><span class="toc-text">4.fread 和 fwrite</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89fread"><span class="toc-text">（1）fread</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89fwrite"><span class="toc-text">（2）fwrite</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-printf%E4%B8%8Escanf%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-text">5.printf与scanf函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89sprintf"><span class="toc-text">（1）sprintf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89snprintf"><span class="toc-text">（2）snprintf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89fscanf"><span class="toc-text">（3）fscanf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89sscanf"><span class="toc-text">（4）sscanf</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%B7%E6%96%B0%E5%87%BD%E6%95%B0"><span class="toc-text">6.文件位置函数和缓冲区刷新函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89fseek"><span class="toc-text">（1）fseek</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89ftell"><span class="toc-text">（2）ftell</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89rewind"><span class="toc-text">（3）rewind</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89fflush"><span class="toc-text">（4）fflush</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AD%98%E5%9C%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">（5）缓冲区存在的作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-getline"><span class="toc-text">7.getline</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BE%8B"><span class="toc-text">（1）程序实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89mygetline%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">（2）mygetline函数实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-text">8.临时文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89tmpfile"><span class="toc-text">（1）tmpfile</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Maxswordsman</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>