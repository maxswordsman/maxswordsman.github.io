<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UNIX环境编程-进程通信-套接字编程（13） | Maxswordsman</title><meta name="author" content="Maxswordsman"><meta name="copyright" content="Maxswordsman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程通信-套接字编程（13）视频教程 IPC(Inter-Process Conmunication)进程间通信 一、管道管道必须凑齐读写双方才可以实现 管道可以看作为队列。先入先出，队首出，队尾入 在C语言中，使用管道（pipes）进行进程间通信是一种经典方法。管道主要用于进程间传递数据 管道由内核提供，单工，具有自同步机制 自同步机制：管道的自同步机制指的是管道在进程间通信时内置的同步">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX环境编程-进程通信-套接字编程（13）">
<meta property="og:url" content="https://maxswordsman.github.io/2024/01/31/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%EF%BC%8813%EF%BC%89/index.html">
<meta property="og:site_name" content="Maxswordsman">
<meta property="og:description" content="进程通信-套接字编程（13）视频教程 IPC(Inter-Process Conmunication)进程间通信 一、管道管道必须凑齐读写双方才可以实现 管道可以看作为队列。先入先出，队首出，队尾入 在C语言中，使用管道（pipes）进行进程间通信是一种经典方法。管道主要用于进程间传递数据 管道由内核提供，单工，具有自同步机制 自同步机制：管道的自同步机制指的是管道在进程间通信时内置的同步">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://maxswordsman.github.io/image/head2.webp">
<meta property="article:published_time" content="2024-01-31T15:19:00.000Z">
<meta property="article:modified_time" content="2024-05-14T06:00:00.000Z">
<meta property="article:author" content="Maxswordsman">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://maxswordsman.github.io/image/head2.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://maxswordsman.github.io/2024/01/31/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%EF%BC%8813%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UNIX环境编程-进程通信-套接字编程（13）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-14 14:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/head2.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Maxswordsman"><span class="site-name">Maxswordsman</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UNIX环境编程-进程通信-套接字编程（13）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-31T15:19:00.000Z" title="发表于 2024-01-31 23:19:00">2024-01-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-14T06:00:00.000Z" title="更新于 2024-05-14 14:00:00">2024-05-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/">C</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>115分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UNIX环境编程-进程通信-套接字编程（13）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />



<h2 id="进程通信-套接字编程（13）"><a href="#进程通信-套接字编程（13）" class="headerlink" title="进程通信-套接字编程（13）"></a>进程通信-套接字编程（13）</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18p4y167Md?p=236&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p>
<p><code>IPC</code>(<code>Inter-Process Conmunication</code>)进程间通信</p>
<h3 id="一、管道"><a href="#一、管道" class="headerlink" title="一、管道"></a>一、管道</h3><p><strong>管道必须凑齐读写双方才可以实现</strong></p>
<p><strong>管道可以看作为队列。先入先出，队首出，队尾入</strong></p>
<p>在C语言中，使用管道（pipes）进行进程间通信是一种经典方法。管道主要用于进程间传递数据</p>
<p>管道由内核提供，单工，具有自同步机制</p>
<p><strong>自同步机制</strong>：管道的自同步机制指的是管道在进程间通信时内置的同步特性，这些特性确保了数据的一致性和顺序性。<strong>管道通常是阻塞的，这意味着在特定情况下，读操作和写操作会被阻塞</strong>，直到某些条件得到满足。这种行为形成了管道的基本自同步特性。</p>
<p>管道分为：匿名管道与命名管道</p>
<hr>
<hr>
<h4 id="1-匿名管道"><a href="#1-匿名管道" class="headerlink" title="1.匿名管道"></a>1.匿名管道</h4><p>匿名管道是一种简单的进程间通信（<code>IPC</code>）机制，主要用于有父子关系的进程间的通信。在Unix和类Unix系统（如Linux）中，匿名管道非常常见。它们是单向的通信方式，通常用于一个进程向另一个进程（具有父子关系的进程）发送数据</p>
<p><strong>基本特性</strong></p>
<ul>
<li><p><strong>单向通信</strong>：数据只能在一个方向上流动，要么是从父进程到子进程，要么是从子进程到父进程。</p>
</li>
<li><p><strong>临时通信通道</strong>：管道在使用完毕后会被销毁。</p>
</li>
<li><p><strong>数据流</strong>：管道中的数据是按照先进先出（<code>FIFO</code>）的顺序流动的。</p>
</li>
<li><p><strong>内存中的存在</strong>：匿名管道不对应于文件系统中的任何文件，它们仅存在于内存中。</p>
</li>
</ul>
<p><strong>创建与使用</strong></p>
<ul>
<li>在C语言中，可以通过<code>pipe()</code>系统调用来创建一个匿名管道。这个调用会创建管道并返回两个文件描述符：一个用于读（<code>pipefd[0]</code>），另一个用于写（<code>pipefd[1]</code>）。</li>
</ul>
<hr>
<h5 id="（1）pipe函数"><a href="#（1）pipe函数" class="headerlink" title="（1）pipe函数"></a>（1）pipe函数</h5><p>在Unix和类Unix系统中，<code>pipe()</code> 函数用于创建一个匿名管道，用于在进程间进行通信。这个函数是进程间通信（<code>IPC</code>）的基础工具之一，特别是在需要在有父子关系的进程之间传递数据时。</p>
<p><strong>函数原型</strong></p>
<p>在 C 语言中，<code>pipe()</code> 函数的原型定义在 <code>&lt;unistd.h&gt;</code> 头文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>pipefd</code>：一个包含两个整型元素的数组。函数成功执行后，<code>pipefd[0]</code> 会被设置为管道的读端，而 <code>pipefd[1]</code> 会被设置为管道的写端</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回 <code>0</code></li>
<li>失败时，返回 <code>-1</code> 并设置 <code>errno</code> 以指示错误原因</li>
</ul>
<p><strong>使用方式</strong></p>
<p>当你调用 <code>pipe()</code> 函数时，它会创建一个管道并提供两个文件描述符（0端作为读取端口，1端作为写入端口）：一个用于读取管道（<code>pipefd[0]</code>），另一个用于写入管道（<code>pipefd[1]</code>）。这些文件描述符可以在后续的读写操作中使用</p>
<p><strong>实例程序</strong></p>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用匿名管道实现父子进程间的通信</span></span><br><span class="line"><span class="comment"> * 父进程在管道中进行读取（0端--队首进行出队）</span></span><br><span class="line"><span class="comment"> * 子进程在管道中进行写入（1端--队尾进行入队）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="comment">// pipe成功后，它会创建一个管道并提供两个文件描述符</span></span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pd)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建管道失败</span></span><br><span class="line">        perror(<span class="string">&quot;pipe()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子进程失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork函数在子进程中返回0</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程的操作</span></span><br><span class="line">        <span class="comment">// 0端进行读取--出队</span></span><br><span class="line">        close(pd[<span class="number">1</span>]); <span class="comment">// 读管道则不需要写端，将写端关闭</span></span><br><span class="line">        <span class="comment">// 将管道中读取的内容放入buf中，长度为BUFSIZE</span></span><br><span class="line">        len = read(pd[<span class="number">0</span>],buf,BUFSIZE);</span><br><span class="line">        <span class="comment">// 将读取的内容，即buf中的内容写入终端，标准输出文件描述符为1</span></span><br><span class="line">        write(<span class="number">1</span>,buf,len);</span><br><span class="line">        <span class="comment">// 关闭0端</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 退出子进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程的操作</span></span><br><span class="line">        close(pd[<span class="number">0</span>]); <span class="comment">// 写管道则不需要读端，将读端关闭</span></span><br><span class="line">        <span class="comment">// 1端进行写入--入队</span></span><br><span class="line">        write(pd[<span class="number">1</span>],<span class="string">&quot;HELLO!\n&quot;</span>,<span class="number">7</span>);</span><br><span class="line">        <span class="comment">// 关闭1端口</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 阻塞回收子进程资源</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出父进程</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312281710134.png" alt="image-20231228171026110"></p>
<hr>
<hr>
<h4 id="2-命名管道"><a href="#2-命名管道" class="headerlink" title="2.命名管道"></a>2.命名管道</h4><p>命名管道（也称为 <code>FIFO</code>，即“先进先出”）是一种在不相关的进程之间进行通信的机制。与匿名管道不同，命名管道具有在文件系统中实际存在的路径名，这允许不具有共同祖先的进程之间进行通信</p>
<p><strong>基本特性</strong></p>
<ul>
<li><strong>有名字</strong>：与匿名管道只存在于内存中不同，命名管道在文件系统中有一个实际的名字。</li>
<li><strong>持久性</strong>：即使没有进程使用它们，命名管道也会继续存在。</li>
<li><strong>双向通信</strong>：理论上支持双向通信，但在实际使用中通常作为单向通信使用，以避免复杂的同步问题。</li>
<li><strong>先进先出原则</strong>：数据以先进先出的方式传输。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>两个不相关的进程通信</strong>：例如，一个进程负责生成数据，另一个进程负责处理数据。</li>
<li><strong>跨程序通信</strong>：不同程序之间可以通过命名管道进行简单的数据交换。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>命名管道的读取和写入操作通常是阻塞的，除非特别设置为非阻塞方式</li>
<li>需要确保合适地打开和关闭管道，避免资源泄露</li>
<li>与匿名管道类似，命名管道的数据也是没有内部结构的字节流，因此需要额外的协议或约定来解释数据。</li>
</ul>
<p><strong>创建与使用</strong></p>
<p>在Unix和类Unix系统中，命名管道通常可以通过两种方式创建：</p>
<p><code>mkfifo</code> 是 Unix 和类 Unix 系统（如 Linux）中用于创建命名管道（FIFO）的函数命名管道允许不相关的进程进行通信，不同于匿名管道，它在文件系统中以特定名称存在，而不仅仅是进程间的临时通信通道</p>
<ul>
<li><strong>命令行</strong>：使用 <code>mkfifo</code> 命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> [path_to_fifo]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>C语言</strong>：使用 <code>mkfifo()</code> 函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（1）命令行创建管道"><a href="#（1）命令行创建管道" class="headerlink" title="（1）命令行创建管道"></a>（1）命令行创建管道</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkfifo</span> namedfifo</span><br></pre></td></tr></table></figure>

<p>查看创建的管道信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l namedfifo</span><br></pre></td></tr></table></figure>

<p>如下，文件权限被标明为<code>p</code>,表明这是一个管道文件</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312282105683.png" alt="image-20231228210547643"></p>
<p>可以使用<code>date</code>显示时间日期信息</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312282109175.png" alt="image-20231228210910142"></p>
<p>在一个终端，将data信息重定向，输入至管道（内容写入管道），如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">date</span> &gt; namedfifo</span><br></pre></td></tr></table></figure>

<p>另外打开一个终端，读取管道内的内容</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312282110918.png" alt="image-20231228211017881"></p>
<hr>
<hr>
<hr>
<h3 id="二、消息队列"><a href="#二、消息队列" class="headerlink" title="二、消息队列"></a>二、消息队列</h3><h4 id="1-ftok函数"><a href="#1-ftok函数" class="headerlink" title="1.ftok函数"></a>1.ftok函数</h4><p>在 Unix 和类 Unix 系统中，<code>ftok</code> 是一个用于 <code>IPC</code>（进程间通信）的标准库函数，它根据一个现有的文件名和一个字节大小的项目标识符，生成一个 <code>System V IPC </code>键（通常称为 <code>key_t</code> 类型）。这个键通常用于创建或访问消息队列、共享内存或信号量</p>
<p><strong>功能</strong></p>
<p><code>ftok</code> 函数的主要目的是提供一种方法，以便不同的进程可以使用相同的键来访问同一段共享内存、消息队列或信号量。通过这种方式，可以保证在不同的进程中创建或访问相同的<code>IPC</code>结构</p>
<p><strong><code>ftok</code>函数是可以获得一个用于进程间通信<code>IPC</code>的<code>key_t</code>值</strong></p>
<p><strong>函数原型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line"></span><br><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pathname</code>：是指向一个已存在文件的路径的指针。这个文件用作生成键的基础。</li>
<li><code>proj_id</code>：是一个字符，用于和 <code>pathname</code> 一起生成一个独特的键。它通常是一个非零字符。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，<code>ftok</code> 返回一个 <code>key_t</code> 类型的值，该值可以被用于后续的<code>IPC</code>操作。</li>
<li>失败时，返回 <code>(key_t) -1</code>，并设置 <code>errno </code>以指示错误原因。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><code>ftok</code> 并不保证生成的键是唯一的，尽管在大多数情况下它是足够有效的。</li>
<li>使用 <code>ftok</code> 时，确保参考文件存在且对所有需要通信的进程可访问。</li>
<li>由于 <code>ftok</code> 返回的键可能在不同系统上有所不同，因此它不适合用于跨系统的 <code>IPC</code></li>
</ul>
<hr>
<hr>
<h4 id="2-消息队列的操作"><a href="#2-消息队列的操作" class="headerlink" title="2.消息队列的操作"></a>2.消息队列的操作</h4><p>消息队列是一个双工的操作</p>
<h5 id="（1）msgget函数"><a href="#（1）msgget函数" class="headerlink" title="（1）msgget函数"></a>（1）msgget函数</h5><p>在 Unix 和类 Unix 系统中，<code>msgget</code> 函数是用于创建或访问消息队列的系统调用。消息队列是一种进程间通信（<code>IPC</code>）机制，允许进程以消息的形式交换数据。这些消息按照先进先出（<code>FIFO</code>）的顺序在队列中排列</p>
<p><strong>功能</strong></p>
<p><code>msgget</code> 函数用于创建新的消息队列或获取对现有消息队列的访问权限。它是 <code>System V IPC </code>机制的一部分</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>key</code>：是一个<code>IPC</code>键，通常由 <code>ftok</code> 函数生成。特殊值 <code>IPC_PRIVATE</code> 可用于创建一个新的、私有的消息队列。</p>
</li>
<li><p><code>msgflg</code>是一个整数，指定操作模式和权限。它可以是权限位的组合（类似于文件权限，例如 0644），以及可能包括以下标志之一：</p>
<p><code>IPC_CREAT</code>：如果指定的键不存在，则创建一个新的消息队列。</p>
<p><code>IPC_EXCL</code>：与 <code>IPC_CREAT</code> 结合使用时，如果消息队列已存在，则返回错误</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，<code>msgget</code> 返回一个非负整数，表示消息队列的标识符（ID）。</li>
<li>失败时，返回 -1，并设置 <code>errno</code> 以指示错误原因</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>确保在使用 <code>msgget</code> 之前调用 <code>ftok</code> 生成有效的 <code>IPC</code> 键</li>
<li>使用 <code>msgget</code> 创建的消息队列在系统级别是持久的，除非显式删除（使用 <code>msgctl</code>）或系统重启</li>
<li>使用消息队列进行进程间通信时，<strong>需要定义一种消息结构</strong>，并遵循先进先出的原则进行操作</li>
</ul>
<hr>
<h5 id="（2）msgsnd与msgrcv函数"><a href="#（2）msgsnd与msgrcv函数" class="headerlink" title="（2）msgsnd与msgrcv函数"></a>（2）msgsnd与msgrcv函数</h5><h6 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd"></a>msgsnd</h6><p><code>msgsnd</code> 用于向消息队列发送消息</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>msqid</code>：消息队列标识符，由 <code>msgget</code> 函数返回。</p>
</li>
<li><p><code>msgp</code>：指向消息结构体的指针。消息结构体的第一个字段通常是一个长整型 (<code>long</code>)，用于表示消息类型。</p>
</li>
<li><p><code>msgsz</code>：消息数据部分的长度，不包括消息类型字段。</p>
</li>
<li><p><code>msgflg</code>：控制消息发送行为的标志。常用的标志包括：</p>
<p><code>IPC_NOWAIT</code>：如果消息不能立即发送（例如，队列已满），则不等待，直接返回。</p>
<p>如果不设置 <code>IPC_NOWAIT</code>，则在无法立即发送消息时，调用将阻塞直到能够发送为止。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回 -1，并设置 <code>errno</code>。</li>
</ul>
<h6 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv"></a>msgrcv</h6><p><code>msgrcv</code> 用于从消息队列接收消息</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>msqid</code>：消息队列标识符，由 <code>msgget</code> 函数返回。</p>
</li>
<li><p><code>msgp</code>：指向消息结构体的指针。消息结构体的第一个字段通常是一个长整型（<code>long</code>），用于表示消息类型。</p>
</li>
<li><p><code>msgsz</code>：消息数据部分的大小，不包括消息类型字段。</p>
</li>
<li><p><code>msgtyp</code>：指定接收消息的类型。如果 <code>msgtyp</code> 为 0，则接收队列中的第一个消息；如果 <code>msgtyp</code> 大于 0，则接收队列中第一个类型等于 <code>msgtyp</code> 的消息；如果 <code>msgtyp</code> 小于 0，则接收队列中类型值最小且不大于 <code>msgtyp</code> 绝对值的第一个消息。</p>
</li>
<li><p><code>msgflg</code>：控制消息接收行为的标志。常用的标志包括：</p>
<p><code>IPC_NOWAIT</code>：如果没有符合条件的消息，则不等待，直接返回。</p>
<p><code>MSG_NOERROR</code>：如果队列中的消息长度超过 <code>msgsz</code>，则截断消息而不是报错。</p>
<p>如果不设置 <code>IPC_NOWAIT</code>，则在没有符合条件的消息时，调用将阻塞直到有消息为止。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回接收到的消息的大小（字节）。</li>
<li>失败时返回 -1，并设置 <code>errno</code> 以指示错误的原因。</li>
</ul>
<hr>
<hr>
<h4 id="3-msgctl"><a href="#3-msgctl" class="headerlink" title="3.msgctl"></a>3.msgctl</h4><p><code>msgctl</code> 函数是 Unix 和类 Unix 系统中的一个系统调用，用于<strong>控制消息队列</strong>。它是 <code>System V </code>消息队列接口的一部分，<strong>提供了对消息队列执行各种控制操作的功能</strong>，如改变队列属性、获取队列信息和删除队列</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>msqid</code>：消息队列标识符，由 <code>msgget</code> 函数返回。</p>
</li>
<li><p><code>cmd</code>：指定要执行的控制操作。常用的操作包括：</p>
<p><code>IPC_STAT</code>：获取消息队列的当前状态和属性，并将其存储在 <code>buf</code> 指向的 <code>msqid_ds</code> 结构体中。</p>
<p><code>IPC_SET</code>：根据 <code>buf</code> 指向的 <code>msqid_ds</code> 结构体中的值设置消息队列的属性。</p>
<p><code>IPC_RMID</code>：立即删除消息队列，释放与之关联的所有资源。</p>
</li>
<li><p><code>buf</code>：指向 <code>msqid_ds</code> 结构体的指针，用于存储或设置消息队列的状态信息。对于 <code>IPC_STAT</code> 和 <code>IPC_SET</code> 命令，这个参数是必需的。对于 <code>IPC_RMID</code> 命令，它通常被忽略。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时返回 0。</li>
<li>失败时返回 -1，并设置 <code>errno</code> 以指示错误的原因。</li>
</ul>
<hr>
<hr>
<h4 id="4-实例代码"><a href="#4-实例代码" class="headerlink" title="4.实例代码"></a>4.实例代码</h4><p>创建一个发送端，向消息队列中发送信息，再创建一个接收端，取出消息队列中的信息</p>
<p><strong>准备工作</strong>：在项目目录下创建文件，命名为<code>Communication_Service</code>的文件，将该文件的路径传入<code>ftok</code>函数中用于生成进程通信的<code>IPC</code>键</p>
<h5 id="（1）协议"><a href="#（1）协议" class="headerlink" title="（1）协议"></a>（1）协议</h5><p>创建通信协议，定义收发数据的结构体</p>
<p><code>proto.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 规定通信协议</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_PROTO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_PROTO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPATH <span class="string">&quot;./Communication_Service&quot;</span>  <span class="comment">// ftok 函数中使用的pathname  ftok 使用路径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPROJ <span class="string">&#x27;g&#x27;</span>                        <span class="comment">// ftok 函数中使用的proj_id 项目标识符 g ASCII码生成一个进程通信的键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义通信的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype; <span class="comment">// 当前消息类型(必需)</span></span><br><span class="line">    <span class="comment">// 下面的才是消息数据部分 上面的消息类型不属于消息数据部分，因此在计算消息数据大小时，需要将消息类型的大小进行减去</span></span><br><span class="line">    <span class="comment">// 即 sizeof(struct msg_st) - sizeof(long)</span></span><br><span class="line">    <span class="type">char</span> name[NAMESIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MSG_PROTO_H</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（2）接收端"><a href="#（2）接收端" class="headerlink" title="（2）接收端"></a>（2）接收端</h5><p>接收消息队列中的数据信息，在该实例程序中，应该先运行接收端程序，等待消息队列中有数据时，取出</p>
<p><code>rcver.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接收方</span></span><br><span class="line"><span class="comment"> * 被动端：接收消息队列中信息，先运行</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ftok函数 生成通信的键</span></span><br><span class="line">    <span class="comment">// 返回一个key_t 类型的健值用于后续的进程通信IPC</span></span><br><span class="line">    key = ftok(KEYPATH,KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        perror(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// msgget 创建消息队列或者获取现有消息队列的访问权</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数1：传入一个用于IPC的key_t值</span></span><br><span class="line"><span class="comment">     * 参数2：消息队列指定的操作模式(如创建IPC_CREAT)与权限(0600)</span></span><br><span class="line"><span class="comment">     * 返回值：成功时，返回一个非负整数，即消息队列的标识符（ID）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    msgid = msgget(key,IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息队列的信息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数1：消息队列标识符，由 msgget 函数返回</span></span><br><span class="line"><span class="comment">     * 参数2：指向消息结构体的指针(间接收的消息存储值协议中指定的消息结构体中)。消息结构体的第一个字段通常是一个长整型（long），用于表示消息类型</span></span><br><span class="line"><span class="comment">     * 参数3：消息数据部分的最大大小，不包括消息类型字段 因此需要(消息类型结构体大小 - 消息类型大小long)</span></span><br><span class="line"><span class="comment">     * 参数4：指定接收消息的类型,无特殊要求直接写0</span></span><br><span class="line"><span class="comment">     * 参数5：控制消息接收行为的标志，无特殊要求直接写0</span></span><br><span class="line"><span class="comment">     * 返回值：成功时返回接收到的消息的大小（字节）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgid,&amp;rbuf,(<span class="keyword">sizeof</span>(rbuf)-<span class="keyword">sizeof</span>(<span class="type">long</span>)),<span class="number">0</span>,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgrcv()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NAME = %s\n&quot;</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MATH = %d\n&quot;</span>,rbuf.math);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CHINESE = %d\n&quot;</span>,rbuf.chinese);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作消息队列--删除队列</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数1：消息队列标识符，由 msgget 返回</span></span><br><span class="line"><span class="comment">     * 参数2：指定要执行的命令。常见的命令包括：IPC_RMID立即删除消息队列</span></span><br><span class="line"><span class="comment">     * 参数3：用于存储或设置消息队列的信息，于 IPC_RMID 命令，通常被忽略设置为NULL</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span>(msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgctl()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（3）发送端"><a href="#（3）发送端" class="headerlink" title="（3）发送端"></a>（3）发送端</h5><p><code>snder.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送方</span></span><br><span class="line"><span class="comment"> * 主动端：发送消息的一方</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="type">int</span> msgid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ftok函数 生成通信的键</span></span><br><span class="line">    key = ftok(KEYPATH,KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// msgget 创建消息队列或者获取现有消息队列的访问权</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数2：在该实例程序中，被动方已经创建了消息队列，因此可以不做额外操作，写0</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    msgid = msgget(key,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充发送的消息结构体信息</span></span><br><span class="line">    sbuf.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">&quot;ZXZ&quot;</span>);</span><br><span class="line">    sbuf.math = <span class="number">100</span>;</span><br><span class="line">    sbuf.chinese = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向消息队列发送信息</span></span><br><span class="line">    <span class="keyword">if</span>(msgsnd(msgid,&amp;sbuf,(<span class="keyword">sizeof</span>(sbuf)-<span class="keyword">sizeof</span>(<span class="type">long</span> )),<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgsnd()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Send OK!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（4）运行结果"><a href="#（4）运行结果" class="headerlink" title="（4）运行结果"></a>（4）运行结果</h5><p>在项目目录下，打开两个终端，分别对收发端程序源码进行编译。如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make snder</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make rcver</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312291842040.png" alt="image-20231229184205007"></p>
<p>运行接收端，可执行文件，等到发送端，发送信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./rcver</span><br></pre></td></tr></table></figure>

<p>运行发送端发送信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./snder</span><br></pre></td></tr></table></figure>

<p>发送端终端结果：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312291844175.png" alt="image-20231229184419146"></p>
<p>接收端终端结果：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312291844936.png" alt="image-20231229184437903"></p>
<p>结束程序之后，在项目目录下的终端运行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipcs</span><br></pre></td></tr></table></figure>

<p>可以发现我们创建的消息队列实例没有被删除</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312291855137.png" alt="image-20231229185557108"></p>
<p>可以使用如下命令对消息队列，或者共享内存或者信号量数组进行删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipcrm</span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<p><code>ipcrm</code> 是 Unix 和类 Unix 系统中用于删除<code> IPC（</code>进程间通信）资源的命令行工具。这个工具允许用户删除消息队列、共享内存段和信号量集，这些是 <code>System V IPC </code>的主要构成部分</p>
<p><code>ipcrm</code> 的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipcrm [options]</span><br></pre></td></tr></table></figure>

<p>常见的选项包括：</p>
<ul>
<li><code>-q msqid</code>：删除消息队列 ID 为 <code>msqid</code> 的消息队列。</li>
<li><code>-m shmid</code>：删除共享内存段 ID 为 <code>shmid</code> 的共享内存。</li>
<li><code>-s semid</code>：删除信号量集 ID 为 <code>semid</code> 的信号量集。</li>
<li><code>-Q msgkey</code>：删除键为 <code>msgkey</code> 的消息队列。</li>
<li><code>-M shmkey</code>：删除键为 <code>shmkey</code> 的共享内存段。</li>
<li><code>-S semkey</code>：删除键为 <code>semkey</code> 的信号量</li>
</ul>
<p>针对我们实例程序中的消息队列可以使用，msqid进行删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipcrm -q 0</span><br></pre></td></tr></table></figure>

<p>运行上述命令之后再进行查看，创建的消息队列被删除：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312291900616.png" alt="image-20231229190053593"></p>
<hr>
<hr>
<h4 id="5-消息队列-ftp实例"><a href="#5-消息队列-ftp实例" class="headerlink" title="5.消息队列-ftp实例"></a>5.消息队列-ftp实例</h4><p>使用消息队列在接收端与发送端之间进行数据的收发</p>
<p>实例描述：</p>
<p>Client端，向Server端发送path请求，path表示的是文件路径</p>
<p>Server端，接收Client的path请求，根据path请求，找到path路径下对应的数据</p>
<p>Server端，将path下的数据分为多份data包发送给Client端，若数据发送完毕，则发送<code>EOF(End of transmission)</code>数据包告知Client发送完毕</p>
<p>图解如下：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401091108015.png" alt="image-20240109110829968"></p>
<h5 id="（1）收发协议"><a href="#（1）收发协议" class="headerlink" title="（1）收发协议"></a>（1）收发协议</h5><p>两种方式实现，Client端不同数据包的判断</p>
<p><code>proto.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 协议1：使用共用体 判断Client端接收的数据包种类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYFTP_MSG_PROTO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYFTP_MSG_PROTO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPATH  <span class="string">&quot;./Communication_Service&quot;</span>  <span class="comment">// ftok 函数中使用的pathname  ftok 使用路径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPROJ <span class="string">&#x27;g&#x27;</span>                         <span class="comment">// ftok 函数中使用的proj_id 项目标识符 g 生成一个进程通信的键</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHMAX 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATAMAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举数据表示 判断接收到包的种类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    MSG_PATH = <span class="number">1</span>,</span><br><span class="line">    MSG_DATA,</span><br><span class="line">    MSG_EOT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// path 包</span></span><br><span class="line"><span class="comment">// Server 端接收 path包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msg_path_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;           <span class="comment">/* 必须是 MAG_PATH */</span></span><br><span class="line">    <span class="type">char</span> path[PATHMAX];   <span class="comment">/* ASCIIZ字符串 字符串的末尾由一个空字符（ASCII码为0，通常写作 \0）标记 */</span></span><br><span class="line">&#125;<span class="type">msg_path_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据包</span></span><br><span class="line"><span class="comment">// Client 端 可能接收的包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msg_data_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;         <span class="comment">/* 必须是 MAG_DATA */</span></span><br><span class="line">    <span class="type">char</span> data[DATAMAX];</span><br><span class="line">    <span class="type">int</span> datalen;</span><br><span class="line">&#125;<span class="type">msg_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eot包（代表接收数据结尾，此时已经没有接收的数据）</span></span><br><span class="line"><span class="comment">// Client 端 可能接收的包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msg_eot_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;        <span class="comment">/* 必须是 MAG_EOT */</span></span><br><span class="line">&#125;<span class="type">msg_eot_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用共用体对象 判断 Client 接收的包的类型</span></span><br><span class="line"><span class="comment">// 共用体中以下三种类型数据只会存在一个</span></span><br><span class="line"><span class="comment">// 以下三种数据类型 均会占用同一段内存空间</span></span><br><span class="line"><span class="comment">// 而 long mtype 占用内存中前四个字节 表示的则是 接收的数据包的种类</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">msg_s2c_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">msg_data_t</span> datamsg;</span><br><span class="line">    <span class="type">msg_eot_t</span> etomsg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MYFTP_MSG_PROTO_H</span></span></span><br></pre></td></tr></table></figure>

<p><code>proto2.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 协议2：不使用共用体 判断Client端接收的数据包种类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYFTP_MSG_PROTO2_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYFTP_MSG_PROTO2_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPATH  <span class="string">&quot;./Communication_Service&quot;</span>  <span class="comment">// ftok 函数中使用的pathname  ftok 使用路径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPROJ <span class="string">&#x27;g&#x27;</span>                         <span class="comment">// ftok 函数中使用的proj_id 项目标识符 g 生成一个进程通信的键</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHMAX 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATAMAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举数据表示 判断接收到包的种类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    MSG_PATH = <span class="number">1</span>,</span><br><span class="line">    MSG_DATA,</span><br><span class="line">    MSG_EOT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// path 包</span></span><br><span class="line"><span class="comment">// Server 端接收 path包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msg_path_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;           <span class="comment">/* 必须是 MAG_PATH */</span></span><br><span class="line">    <span class="type">char</span> path[PATHMAX];   <span class="comment">/* ASCIIZ字符串 字符串的末尾由一个空字符（ASCII码为0，通常写作 \0）标记 */</span></span><br><span class="line">&#125;<span class="type">msg_path_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据包</span></span><br><span class="line"><span class="comment">// Client 端 接收的包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msg_data_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;         <span class="comment">/* 必须是 MAG_DATA 或者 MSG_EOT*/</span></span><br><span class="line">    <span class="type">int</span> datalen;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * datalen &gt; 0 : 接收的是data包</span></span><br><span class="line"><span class="comment">     * datalen ==0 : 接收的是eot包（表示接收数据的结尾 接收数据完毕）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">char</span> data[DATAMAX];</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">msg_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MYFTP_MSG_PROTO2_H</span></span></span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h4 id="6-消息队列-信号量数组实例"><a href="#6-消息队列-信号量数组实例" class="headerlink" title="6.消息队列-信号量数组实例"></a>6.消息队列-信号量数组实例</h4><p>信号量数组是一种在并发编程中使用的同步机制，它通常用于控制对共享资源的访问。在Unix和类Unix系统中，信号量通常是通过系统调用和<code>IPC</code>（进程间通信）机制实现的。信号量数组就是包含多个信号量的集合，允许程序同时管理多个共享资源。</p>
<p>若信号量数组，的大小为<code>1</code>则表示信号量或者互斥锁，对于单个资源的单独共享</p>
<p><strong>基本概念</strong></p>
<ul>
<li><strong>信号量（Semaphore）</strong>：一个整数值，用于同步进程或线程，控制对共享资源的访问。</li>
<li><strong>信号量数组</strong>：包含多个信号量的集合，每个信号量可以独立地用来控制对不同共享资源的访问。</li>
</ul>
<p><strong>主要操作</strong></p>
<ul>
<li><strong>初始化</strong>：在使用信号量之前，需要初始化它们，包括设置初始值。</li>
<li><strong>等待（P操作或wait）</strong>：如果信号量的值大于0，减少它的值并继续执行。如果信号量的值为0，进程或线程将阻塞，直到信号量值变为正。</li>
<li><strong>发信号（V操作或signal）</strong>：增加信号量的值。如果有其他进程或线程因信号量的值为0而阻塞，它们中的一个将被唤醒</li>
</ul>
<p><strong>使用场景</strong></p>
<p>信号量数组在多进程环境中特别有用，特别是<strong>当你需要控制对多个不同资源的并发访问时</strong>。例如，你可能有一个包含多个文件或数据结构的系统，每个文件或数据结构都需要单独的同步机制</p>
<h5 id="（1）信号量集合相关API"><a href="#（1）信号量集合相关API" class="headerlink" title="（1）信号量集合相关API"></a>（1）信号量集合相关API</h5><h6 id="semget"><a href="#semget" class="headerlink" title="semget"></a>semget</h6><p><code>semget</code> 函数是 UNIX 和类 UNIX 系统（如 Linux）中用于<strong>创建新的信号量集或访问现有信号量集的系统调用</strong>。它是实现进程间同步和互斥的关键组件之一</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ul>
<li><strong>key</strong>：一个键值（<code>key_t</code> 类型），用于标识信号量集。可以是一个显式的键值或使用 <code>IPC_PRIVATE</code> 创建一个新的私有集合。</li>
<li><strong>nsems</strong>：需要的信号量数目。如果访问现有的信号量集，这个值通常设置为 0。</li>
<li><strong>semflg</strong>：一个整数，指定一组标志。这些标志包括创建信号量集的权限（如 <code>0600</code> 或 <code>0666</code> 等）和其他选项，如 <code>IPC_CREAT</code>（创建新信号量集，如果已存在则访问它）和 <code>IPC_EXCL</code>（与 <code>IPC_CREAT</code> 结合使用，确保创建新的集合）</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回信号量集的标识符（非负整数）。</li>
<li>出错时，返回 -1，并设置 <code>errno</code> 以指示错误的原因（例如 <code>EEXIST</code> 表示信号量集已存在，<code>ENOENT</code> 表示不存在等）。</li>
</ul>
<h6 id="semop"><a href="#semop" class="headerlink" title="semop"></a>semop</h6><p><code>semop</code> 函数是 UNIX 和类 UNIX 系统（比如 Linux）中<strong>用于执行操作（如等待和信号）在信号量上的系统调用</strong>。这个函数允许进程对一个或多个信号量执行一系列操作，这对于进程间同步和互斥是非常重要的</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ul>
<li><strong>semid</strong>：由 <code>semget</code> 返回的信号量集标识符。</li>
<li><strong>sops</strong>：指向 <code>sembuf</code> 结构数组的指针，每个元素指定对单个信号量执行的操作。</li>
<li><strong>nsops</strong>：<code>sops</code> 数组中的元素数量，表示要执行的操作数。</li>
</ul>
<p><code>sembuf</code> 结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sem_num; <span class="comment">/* 信号量集中信号量的索引 */</span></span><br><span class="line">    <span class="type">short</span> sem_op;           <span class="comment">/* 操作类型：-1（等待）、0（测试）、+1（信号） */</span></span><br><span class="line">    <span class="type">short</span> sem_flg;          <span class="comment">/* 操作标志，如 IPC_NOWAIT */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回 0。</li>
<li>出错时，返回 -1，并设置 <code>errno</code> 以指示错误的原因（例如 <code>EINTR</code> 表示操作被中断，<code>EINVAL</code> 表示参数无效等）。</li>
</ul>
<h6 id="semctl"><a href="#semctl" class="headerlink" title="semctl"></a>semctl</h6><p><code>semctl</code> 函数是 UNIX 和类 UNIX 系统（如 Linux）中<strong>用于控制信号量集的系统调用</strong>。它提供了一种方式来执行多种不同的控制操作，比如<strong>设置信号量的值，获取信号量的当前值，或删除信号量集</strong></p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ...)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ul>
<li><strong>semid</strong>：由 <code>semget</code> 返回的信号量集标识符。</li>
<li><strong>semnum</strong>：信号量集中的信号量索引（对于某些命令，这个参数可能被忽略）。</li>
<li><strong>cmd</strong>：控制操作的类型，如 <code>SETVAL</code>（设置信号量的值），<code>GETVAL</code>（获取信号量的当前值），<code>IPC_RMID</code>（删除信号量集）等。</li>
<li>**…**：附加参数，根据 <code>cmd</code> 的不同而变化。例如，对于 <code>SETVAL</code>，它是一个 <code>union semun</code> 类型的值，用于设置信号量的值。</li>
</ul>
<p><strong>共用体<code>uniom semum</code>定义</strong><br>由于历史原因，<code>union semun</code> 并不总是在系统头文件中定义。因此，你可能需要自己定义它，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;                 <span class="comment">/* 用于 SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* 用于 IPC_STAT 和 IPC_SET */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *<span class="built_in">array</span>;   <span class="comment">/* 用于 GETALL 和 SETALL */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>返回值</strong></p>
<ul>
<li>成功时，根据执行的命令不同，返回值也不同。例如，<code>GETVAL</code> 返回信号量的当前值。</li>
<li>出错时，返回 -1，并设置 <code>errno</code> 以指示错误的原因（例如 <code>EINVAL</code> 表示参数无效，<code>EACCES</code> 表示权限错误等）。</li>
</ul>
<h5 id="（2）实例程序"><a href="#（2）实例程序" class="headerlink" title="（2）实例程序"></a>（2）实例程序</h5><p>使用信号量数组，实现互斥锁，保证对于单个进程共享资源的单独使用，进程同步</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多进程并发</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCNUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FNAME <span class="string">&quot;../out&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> semid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p函数是取出资源进行使用，因此信号量中资源数进行-1操作 op.sem_op = -1</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line">    op.sem_num = <span class="number">0</span>;   <span class="comment">/* 信号量集中信号量的索引 */</span></span><br><span class="line">    op.sem_op = <span class="number">-1</span>;   <span class="comment">/* 操作类型：-1（等待）、0（测试）、+1（信号） */</span></span><br><span class="line">    op.sem_flg = <span class="number">0</span>;   <span class="comment">/* 操作标志，如 IPC_NOWAIT */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对信号量进行操作</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数1：由semget返回的信号量集标识符</span></span><br><span class="line"><span class="comment">     * 参数2：指向sembuf结构数组的指针，每个元素指定对单个信号量执行的操作</span></span><br><span class="line"><span class="comment">     * 参数3:sops数组中的元素数量，表示要执行的操作数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">while</span>(semop(semid,&amp;op,<span class="number">1</span>)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断是否为真的错误，因为semop是一个阻塞的系统调用</span></span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR || errno != EAGAIN)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;semop()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v函数是放回资源进行使用，因此信号量中资源数进行+1操作 op.sem_op = 1</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line">    op.sem_num = <span class="number">0</span>;</span><br><span class="line">    op.sem_op = <span class="number">1</span>;</span><br><span class="line">    op.sem_flg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对信号量进行操作</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数1：由semget返回的信号量集标识符</span></span><br><span class="line"><span class="comment">     * 参数2：指向sembuf结构数组的指针，每个元素指定对单个信号量执行的操作</span></span><br><span class="line"><span class="comment">     * 参数3:sops数组中的元素数量，表示要执行的操作数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span>(semop(semid,&amp;op,<span class="number">1</span>)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;semop()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func_add</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> linebuf[LINESIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="comment">// fopen用于将文件流（例如，由 fopen 创建的 FILE* 类型的对象）转换成对应的文件描述符</span></span><br><span class="line">    fp = fopen(FNAME,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PV操作是进行资源取还的两个操作</span></span><br><span class="line">    <span class="comment">// 取资源时，进行P()操作</span></span><br><span class="line">    P();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件中的一行</span></span><br><span class="line">    fgets(linebuf,LINESIZE,fp);</span><br><span class="line">    <span class="comment">// 定位到文件开始的位置进行覆盖写入</span></span><br><span class="line">    fseek(fp,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将linfbuf字符串中的转为整形+1 在写入文件流fp中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d\n&quot;</span>,atoi(linebuf)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// fptintf为行缓冲模式，而文件是全缓冲模式，需要刷新流</span></span><br><span class="line">    fflush(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还资源量，进行V() 操作</span></span><br><span class="line">    V();</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点，该程序是父子进程进行通信，因此可以不使用ftok函数,当然也可以进行使用</span></span><br><span class="line">    <span class="comment">// 创建一个用于进程间进行通信的key值</span></span><br><span class="line">    <span class="comment">// ftok();</span></span><br><span class="line">    <span class="comment">// 该程序用于父子进程间的通信，父进程先使用ftok可以创建一个唯一的key值</span></span><br><span class="line">    <span class="comment">// 使用fork函数创建子进程，则每个子进程均可以得到一个IPC的key值</span></span><br><span class="line">    <span class="comment">// （重点）因此下面的semget函数传入的key_t key可以不用找一个合适的key值，可以直接使用参数IPC_PRIVATE,创建一个新的、私有的消息队列</span></span><br><span class="line">    <span class="comment">// 则上面的ftok函数就可以不使用了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号量数组实例</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数1：是一个IPC键，通常由ftok函数生成。特殊值IPC_PRIVATE可用于创建一个新的、私有的消息队列</span></span><br><span class="line"><span class="comment">     * 参数2：需要的信号量数目。如果访问现有的信号量集，这个值通常设置为 0</span></span><br><span class="line"><span class="comment">     * 参数3：一个整数，指定一组标志。这些标志包括创建信号量集的权限（如0600或0666等）和其他选项</span></span><br><span class="line"><span class="comment">     *       如IPC_CREAT（创建新信号量集，如果已存在则访问它）和IPC_EXCL（与IPC_CREAT结合使用，确保创建新的集合）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    semid = semget(IPC_PRIVATE,<span class="number">1</span>,IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>(semid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;semget()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对信号量数组进行初始化</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数1：由semget返回的信号量集标识符</span></span><br><span class="line"><span class="comment">     * 参数2：信号量集中的信号量索引</span></span><br><span class="line"><span class="comment">     * 参数3：控制操作的类型，如SETVAL（设置信号量的值），GETVAL（获取信号量的当前值），IPC_RMID（删除信号量集）等</span></span><br><span class="line"><span class="comment">     * 参数4：附加参数，根据 cmd的不同而变化。例如，对于SETVAL，它是一个 union semun类型的值，用于设置信号量的值。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">// 此处设置信号量的值为1，表示只有一个信号量可以用</span></span><br><span class="line">    <span class="comment">// union semun arg;</span></span><br><span class="line">    <span class="comment">// arg.val = 1;  union semun，已经在 &lt;sys/sem.h&gt; 中定义</span></span><br><span class="line">    <span class="keyword">if</span>(semctl(semid,<span class="number">0</span>,SETVAL,<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;semctl()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;PROCNUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="comment">// 进程创建失败</span></span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            func_add();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收线程资源（收尸）</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;PROCNUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量数组实例</span></span><br><span class="line">    semctl(semid,<span class="number">0</span>,IPC_RMID);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，可以实现多进程对out文件逐次递加使用</p>
<hr>
<hr>
<h4 id="7-进程间通信-共享内存项目实例"><a href="#7-进程间通信-共享内存项目实例" class="headerlink" title="7.进程间通信-共享内存项目实例"></a>7.进程间通信-共享内存项目实例</h4><p>共享内存是一种进程间通信（IPC）机制，允许两个或多个进程共享一个给定的存储区。它是最快的IPC方法之一，因为进程是直接对内存进行读写，而不是通过操作系统进行数据传输</p>
<p><strong>如何工作</strong></p>
<p>在共享内存模型中，操作系统为多个进程分配一块内存区域。一旦这块内存被分配，所有有访问权限的进程都可以直接读写这块内存。这些进程可能是同时运行的，并且可以看到内存中的即时更新。</p>
<p><strong>共享内存优点</strong></p>
<ul>
<li><strong>效率高</strong>：由于数据不需要在进程之间复制，所以这是一种非常快速的数据交换方式。</li>
<li><strong>实时通信</strong>：共享内存允许进程以几乎无延迟的方式进行通信。</li>
</ul>
<p><strong>共享内存优点</strong></p>
<ul>
<li><p><strong>同步问题</strong>：当多个进程需要访问共享内存时，同步变得至关重要。否则，就可能出现竞争条件和数据不一致的问题。</p>
</li>
<li><p><strong>复杂性</strong>：管理共享内存，特别是同步和协调访问，比其他IPC机制更复杂。</p>
</li>
</ul>
<h5 id="（1）共享内存相关API"><a href="#（1）共享内存相关API" class="headerlink" title="（1）共享内存相关API"></a>（1）共享内存相关API</h5><h6 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h6><p><code>shmget</code> 是 UNIX 和类 UNIX 系统（比如 Linux）中用于<strong>创建新的共享内存段或获取现有共享内存段的标识符的系统调用</strong>。共享内存是一种高效的进程间通信（IPC）机制，允许多个进程访问同一块内存区域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ul>
<li><strong>key</strong>：一个键值（<code>key_t</code> 类型），用于标识共享内存段。可以是一个显式的键值或使用 <code>IPC_PRIVATE</code> 创建一个新的私有内存段。</li>
<li><strong>size</strong>：需要的共享内存大小（以字节为单位）。</li>
<li><strong>shmflg</strong>：一个整数，指定一组标志。这些标志包括创建共享内存段的权限（如 <code>0600</code> 或 <code>0666</code> 等）和其他选项，如 <code>IPC_CREAT</code>（创建新共享内存段，如果已存在则访问它）和 <code>IPC_EXCL</code>（与 <code>IPC_CREAT</code> 结合使用，确保创建新的段）</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回共享内存段的标识符（非负整数）。</li>
<li>出错时，返回 -1，并设置 <code>errno</code> 以指示错误的原因（例如 <code>EEXIST</code> 表示共享内存段已存在，<code>ENOENT</code> 表示不存在等）</li>
</ul>
<h6 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h6><p><code>shmat</code>（shared memory attach）函数是 UNIX 和类 UNIX 系统中<strong>用于将共享内存段附加到进程的地址空间的系统调用。这个函数使进程能够访问共享内存段中的数据</strong>。</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ul>
<li><strong>shmid</strong>：由 <code>shmget</code> 返回的共享内存段标识符。</li>
<li><strong>shmaddr</strong>：指定共享内存连接到进程地址空间的特定地址。如果为 NULL，则操作系统选择地址。</li>
<li><strong>shmflg</strong>：附加标志。常用的标志包括 <code>SHM_RND</code>（用于舍入 <code>shmaddr</code> 到系统允许的地址边界）和 <code>SHM_RDONLY</code>（将内存段附加为只读）</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回指向共享内存段的指针。</li>
<li>出错时，返回 <code>((void *) -1)</code>，并设置 <code>errno</code> 以指示错误的原因。</li>
</ul>
<h6 id="shmdt"><a href="#shmdt" class="headerlink" title="shmdt"></a>shmdt</h6><p><code>shmdt</code> 函数是 UNIX 和类 UNIX 系统（如 Linux）中<strong>用于将共享内存段从进程的地址空间分离的系统调用。当进程完成对共享内存的访问并希望解除与该内存段的关联时，它会使用此函数</strong>。</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ul>
<li><strong>shmaddr</strong>：指向共享内存段的指针，这个指针是之前调用 <code>shmat</code> 时返回的</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回 <code>0</code>。</li>
<li>出错时，返回 <code>-1</code>，并设置 <code>errno</code> 以指示错误的原因。</li>
</ul>
<h6 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h6><p><code>shmctl</code> 是 UNIX 和类 UNIX 系统（如 Linux）中<strong>用于执行共享内存控制操作的系统调用。这个函数允许你对共享内存进行多种操作，如获取状态信息、修改权限、标记删除等</strong></p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ul>
<li><strong>shmid</strong>：共享内存段的标识符，通常由 <code>shmget</code> 返回。</li>
<li><strong>cmd</strong>：控制命令，决定了 <code>shmctl</code> 的行为。常用命令包括 <code>IPC_STAT</code>（获取共享内存状态）、<code>IPC_SET</code>（设置共享内存参数）和 <code>IPC_RMID</code>（标记共享内存以便删除）。</li>
<li><strong>buf</strong>：指向 <code>shmid_ds</code> 结构的指针，用于获取或设置共享内存的状态信息。结构定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>  <span class="comment">// 所有权和权限</span></span><br><span class="line">    <span class="type">size_t</span> shm_segsz;          <span class="comment">// 大小（字节）</span></span><br><span class="line">    <span class="type">time_t</span> shm_atime;          <span class="comment">// 最后一次附加时间</span></span><br><span class="line">    <span class="type">time_t</span> shm_dtime;          <span class="comment">// 最后一次分离时间</span></span><br><span class="line">    <span class="type">time_t</span> shm_ctime;          <span class="comment">// 最后一次修改时间</span></span><br><span class="line">    <span class="type">pid_t</span> shm_cpid;            <span class="comment">// 创建者的进程ID</span></span><br><span class="line">    <span class="type">pid_t</span> shm_lpid;            <span class="comment">// 最后操作的进程ID</span></span><br><span class="line">    <span class="type">shmatt_t</span> shm_nattch;       <span class="comment">// 当前附加的进程数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回 <code>0</code>。</li>
<li>出错时，返回 <code>-1</code>，并设置 <code>errno</code> 以指示错误的原因。</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>使用 <code>IPC_RMID</code> 命令标记共享内存以便删除后，该内存段仍然存在，直到所有附加的进程都分离（即 <code>shm_nattch</code> 为0）。</li>
<li>在共享内存段被删除之前，它仍然可以被其他进程附加和使用。</li>
<li>适当地管理共享内存非常重要，特别是在多进程系统中，以防止资源泄露。</li>
</ul>
<hr>
<h5 id="（2）实例程序-1"><a href="#（2）实例程序-1" class="headerlink" title="（2）实例程序"></a>（2）实例程序</h5><p>使用共享内存用于父子进程间的通信</p>
<p>描述：子进程向共享内存中写入数据<code>HELLO</code>,父进程读取共享内存中的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ftok 获得进程间通信的key值</span></span><br><span class="line">    <span class="comment">// 实现父子进程通信则可以不使用这个函数</span></span><br><span class="line">    <span class="comment">// 在shmget函数中使用参数`IPC_PRIVATE`创建一个新的私有内存段</span></span><br><span class="line">    <span class="comment">// ftok();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存实例</span></span><br><span class="line">    <span class="comment">// 返回一个shmid,共享内存ID</span></span><br><span class="line">    shmid = shmget(IPC_PRIVATE,MEMSIZE,IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程操作--对共享内存进行写入数据</span></span><br><span class="line">        <span class="comment">// 将共享内存段附加到进程的地址空间。使进程能够访问共享内存段中的数据</span></span><br><span class="line">        ptr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;shmat()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对共享内存 char *ptr写入数据</span></span><br><span class="line">        <span class="built_in">strcpy</span>(ptr,<span class="string">&quot;HELLO!\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 解除共享内存的映射</span></span><br><span class="line">        shmdt(ptr);</span><br><span class="line">        <span class="comment">// 退出子进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 阻塞进程，对子进程资源进行收尸</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 父进程操作--对共享内存进行读取数据</span></span><br><span class="line">        <span class="comment">// 将共享内存段附加到进程的地址空间。使进程能够访问共享内存段中的数据</span></span><br><span class="line">        ptr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;shmat()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取 char *ptr 指针指向的共享内存</span></span><br><span class="line">        <span class="built_in">puts</span>(ptr);</span><br><span class="line">        <span class="comment">// 解除共享内存的映射</span></span><br><span class="line">        shmdt(ptr);</span><br><span class="line">        <span class="comment">// 销毁共享内存实例</span></span><br><span class="line">        shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 退出父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401091623966.png" alt="image-20240109162331930"></p>
<hr>
<hr>
<hr>
<h3 id="三、套接字"><a href="#三、套接字" class="headerlink" title="三、套接字"></a>三、套接字</h3><h4 id="1-跨主机传输要注意的主要问题"><a href="#1-跨主机传输要注意的主要问题" class="headerlink" title="1.跨主机传输要注意的主要问题"></a>1.跨主机传输要注意的主要问题</h4><h5 id="（1）基础知识"><a href="#（1）基础知识" class="headerlink" title="（1）基础知识"></a>（1）基础知识</h5><h6 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h6><p>大小端存储（<code>Big-endian</code> 和 <code>Little-endian</code>）是计算机系统中<strong>用于存储数据字节序的两种不同方式</strong>。它们主要涉及多字节数据（如整数、浮点数）在内存中的存储顺序</p>
<ul>
<li><p><strong>大端模式</strong>：</p>
<p>在大端模式中，最高有效字节（<code>MSB</code>）存储在最低的内存地址上，而最低有效字节（<code>LSB</code>）存储在最高的内存地址上（<strong>低地址放高字节</strong>）</p>
<p>例如，一个值为 <code>0x12345678</code> 的四字节整数（字节序，两个16进制位（等价于8个二进制位）表示一个字节），在内存中的存储顺序（从低地址到高地址）将是 <code>12 34 56 78</code></p>
</li>
</ul>
<p>​		大端模式可视作更接近人类阅读和书写数字的方式</p>
<ul>
<li><p><strong>小端模式</strong>:</p>
<p>在小端模式中，最低有效字节（<code>LSB</code>）存储在最低的内存地址上，而最高有效字节（<code>MSB</code>）存储在最高的内存地址上（<strong>低地址放低字节</strong>）</p>
<p>同样的例子，值 <code>0x12345678</code> 的四字节整数，在内存中的存储顺序将是 <code>78 56 34 12</code></p>
<p>小端模式在许多现代计算机系统中（如<code>x86</code>架构）更为常见</p>
</li>
</ul>
<p><strong>注意（重点理解）</strong>：</p>
<ul>
<li><p>在 <code>0x12345678</code> 中，<code>0x12</code> 始终是最高有效字节，而 <code>0x78</code> 始终是最低有效字节（<code>LSB</code>）</p>
</li>
<li><p>在十六进制（16进制）系统中，每位可以表示16个不同的值，范围从0到15。然而，为了在数字表示中包含超过9的值，十六进制使用字母A到F来代表10到15。因此，十六进制的每位可以是0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, 或 F</p>
<p>所以，当你看到一个像 <code>0x12345678</code> 这样的十六进制数时，每个数字或字母都代表一个单独的十六进制位。这个数分解如下：</p>
<p><code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code> 每个都是单独的十六进制位</p>
<p><code>12</code>, <code>34</code>, <code>56</code>, <code>78</code> 每对数字代表一个字节，因为在十六进制中，每两位组成一个8位（或1字节）的值（在十六进制（16进制）中，每两位组成一个8位（或1字节）的值，这是因为每个十六进制位可以表示4个二进制位，而两个16进制位则是8个二进制位，即一个字节）</p>
</li>
</ul>
<h6 id="32位机器与64位机器数据类型存储字节数"><a href="#32位机器与64位机器数据类型存储字节数" class="headerlink" title="32位机器与64位机器数据类型存储字节数"></a>32位机器与64位机器数据类型存储字节数</h6><ul>
<li><p><strong><code>int</code>类型</strong></p>
<p>在32位的机器环境中，<code>int</code> 类型的数据通常占用4个字节。这是因为在大多数32位系统中，标准的整型（<code>int</code>）被定义为32位，而每个字节包含8位，因此 <code>32位 / 8位/字节 = 4字节</code></p>
<p>在64位的机器环境中，<code>int</code> 类型数据的大小并不总是因为系统是64位的就自动扩展到64位。实际上，<code>int</code> 类型的大小取决于编译器和操作系统的具体实现，但在大多数现代的64位系统中，<code>int</code> 仍然保持为32位，即4个字节。这是为了保持与旧代码的兼容性。不过，其他一些数据类型，如指针（<code>pointers</code>）和长整型（<code>long</code>），在64位系统中可能会增加到64位</p>
</li>
</ul>
<hr>
<h5 id="（2）字节序问题"><a href="#（2）字节序问题" class="headerlink" title="（2）字节序问题"></a>（2）字节序问题</h5><p>跨主机通信时字节序问题是计算机网络中的一个重要考虑因素。<strong>不同的计算机系统可能采用不同的字节序（即大小端模式）来存储数据</strong>，这可能导致在一个系统中正确表示的数据，在另一个系统中被错误解释。</p>
<p><strong>机器对于文件数据按地址位读取方式</strong>：数据通常是按照它们在文件中的顺序逐字节读取的。这意味着读取操作通常是从文件的开始（低地址位）向文件的结束（高地址位）进行的</p>
<p><strong>若在跨主机通信中，收发两端采用不同的字节序来存储数据，则解析数据时会存在问题</strong>。</p>
<p><strong>问题根源：</strong></p>
<ul>
<li><strong>不同的字节序</strong>：有些系统采用大端模式（如大多数网络设备和一些旧的计算机系统），而其他系统则采用小端模式（如大多数现代个人电脑和服务器）。</li>
<li><strong>直接传输未转换的数据</strong>：如果一个系统直接将其内部表示的数据发送到另一个采用不同字节序的系统，接收方可能会错误地解释这些数据。</li>
</ul>
<p><strong>解决方法</strong>：</p>
<ul>
<li><strong>网络字节序</strong>：为了解决这个问题，网络通信通常使用一种称为“网络字节序”的标准，它是大端模式。因此，<strong>在数据在网络上发送之前，它通常被转换为网络字节序。接收系统需要将接收到的数据从网络字节序转换回其本地（主机）字节序</strong></li>
<li><strong>明确协议规范</strong>：通信协议应该明确指定所使用的字节序；在设计协议时，应该考虑到不同系统间的字节序差异，并在必要时进行适当的转换</li>
<li><strong>使用无关字节序的格式</strong>：另一种方法是使用格式（如<code>JSON</code>、<code>XML</code>）来交换数据，这些格式本质上是字节序无关的，因为它们表示的是文本数据</li>
<li><strong>转换函数</strong>：在需要时，开发者可以使用如 <code>htonl()</code>、<code>htons()</code>（host-to-network long&#x2F;short）和它们的反向函数 <code>ntohl()</code>、<code>ntohs()</code>（<code>network-to-host long/short</code>）等函数来在本地字节序和网络字节序之间进行转换</li>
</ul>
<h6 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h6><p>网络字节序是一种在网络上发送和接收数据时使用的字节序约定。由于不同的计算机系统可能使用不同的字节序（即大端模式和小端模式），因此在通过网络通信时，需要一个共同的标准以确保数据的一致性和正确性。网络字节序就是这样一个标准，它采用大端模式</p>
<p><strong>网络字节序特点</strong>：</p>
<ul>
<li>使用大端模式</li>
<li><strong>跨平台一致性</strong>：采用网络字节序可以确保来自不同字节序计算机系统的数据在网络上传输时保持一致的表示方式</li>
</ul>
<p><strong>应用</strong>：</p>
<ul>
<li><strong>协议遵守</strong>：许多网络协议，如<code>TCP/IP</code>，明确规定使用网络字节序来表示多字节数值。因此，构建和解析网络数据包时需要遵循这一约定</li>
<li><strong>数据转换</strong>：在发送数据之前，发送方可能需要将其本地字节序的数据转换为网络字节序。接收方收到数据后，可能需要将网络字节序的数据转换回其本地字节序。这通常通过函数（如 <code>htonl()</code>、<code>htons()</code>、<code>ntohl()</code>、<code>ntohs()</code> 等）完成，这些函数在不同平台上有不同的实现，但提供一致的接口。这些函数中<code>h</code>表示<code>host</code>主机的意思，<code>to</code>表示从前者到后者的意思，而<code>n</code>表示<code>network</code>,最后的<code>s与l</code>则表示<code>short</code>与<code>long</code>类型的数据</li>
</ul>
<hr>
<h5 id="（3）结构体对齐问题"><a href="#（3）结构体对齐问题" class="headerlink" title="（3）结构体对齐问题"></a>（3）结构体对齐问题</h5><p>在数据存储中，为了加速地址检索，结构体会存在地址对齐，但是在<strong>网络通信的结构体中需禁止对齐（指定告知编译器不需要进行地址对齐）</strong></p>
<p><a href="https://maxswordsman.github.io/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B%EF%BC%882%EF%BC%89/">结构体对齐方式</a></p>
<hr>
<h5 id="（4）数据类型长度问题"><a href="#（4）数据类型长度问题" class="headerlink" title="（4）数据类型长度问题"></a>（4）数据类型长度问题</h5><p>例如：不同机器之间<code>int</code>占多少字节，占多少二进制位。<code>char</code>字符数据，有无符号</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>使用通用的类型数据：如32位的整型数，<code>int32_t</code>;32位无符号整型数据，<code>uint32_t</code>;类推，<code>int64_t</code>,<code>int8_t</code>,<code>uint8_t</code></li>
</ul>
<hr>
<hr>
<h4 id="2-套接字-Socket"><a href="#2-套接字-Socket" class="headerlink" title="2.套接字-Socket"></a>2.套接字-Socket</h4><p>Socket（套接字）是一种网络通信的端点，它为网络中的不同主机之间提供了一种发送和接收数据的方式。Socket是计算机网络通信的基础，存在于许多不同类型的网络协议中，最常见的是基于TCP&#x2F;IP协议的Socket。在应用层和网络层之间，套接字充当了一个接口的角色</p>
<p><strong>套接字关键特点</strong></p>
<ul>
<li><strong>通信端点</strong>：Socket是网络通信的端点，每个Socket都有一个对应的IP地址和端口号</li>
<li><strong>支持不同的通信类型</strong>：套接字可以用于不同类型的网络通信，如TCP（传输控制协议）和UDP（用户数据报协议）</li>
<li><strong>面向连接和无连接</strong>：TCP套接字是面向连接的，意味着在数据传输之前需要建立一个稳定的连接；UDP套接字是无连接的，它们发送独立的数据包而不需要建立稳定的连接</li>
<li><strong>数据传输</strong>：套接字允许应用程序通过网络发送和接收数据</li>
</ul>
<h5 id="（1）套接字相关API"><a href="#（1）套接字相关API" class="headerlink" title="（1）套接字相关API"></a>（1）套接字相关API</h5><h6 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h6><p><code>socket()</code> 函数用于创建一个新的套接字，它是网络通信的基本操作之一。这个函数定义了套接字的类型、所使用的协议族以及具体的协议类型。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li><code>domain</code>：指定套接字使用的协议族，常见的有 <code>AF_INET</code>（表示IPv4网络协议）、<code>AF_INET6</code>（表示IPv6网络协议）等</li>
<li><code>type</code>：指定套接字的类型。常见的类型有 <code>SOCK_STREAM</code>（表示面向连接的套接字，通常用于TCP）和 <code>SOCK_DGRAM</code>（表示无连接的套接字，通常用于UDP）</li>
<li><code>protocol</code>：指定具体的协议。通常设置为0，表示选择默认协议（对于 <code>SOCK_STREAM</code> 是TCP，对于 <code>SOCK_DGRAM</code> 是UDP）</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功时，返回一个套接字描述符（一个正整数）。</li>
<li>失败时，返回-1，并设置 <code>errno</code> 以指示错误原因</li>
</ul>
<h6 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h6><p><code>bind()</code> 函数用于<strong>将套接字与特定的IP地址和端口号绑定</strong>。它通常用于服务器端的套接字，以便指定和监听来自客户端的连接请求</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sockfd</code>：是由 <code>socket()</code> 函数调用返回的套接字文件描述符。</li>
<li><code>addr</code>：是指向 <code>struct sockaddr</code> 结构的指针，该结构包含了要绑定的IP地址和端口号。</li>
<li><code>addrlen</code>：指定了 <code>addr</code> 结构的大小。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li><strong>成功</strong>：当 <code>bind()</code> 函数成功绑定套接字到指定的地址和端口时，它返回 <code>0</code>。</li>
<li><strong>失败</strong>：如果出现错误，<code>bind()</code> 函数返回 <code>-1</code>。此外，全局变量 <code>errno</code> 被设置为一个特定的错误代码，以提供有关错误的更多信息</li>
</ul>
<p><strong>使用步骤</strong>：</p>
<ul>
<li>创建一个套接字使用 <code>socket()</code>。</li>
<li>填充 <code>struct sockaddr</code> 结构（或其它相关结构，如 <code>struct sockaddr_in</code> 对于IPv4）。</li>
<li>调用 <code>bind()</code> 将套接字与指定的IP地址和端口号绑定。</li>
</ul>
<h6 id="struct-sockaddr"><a href="#struct-sockaddr" class="headerlink" title="struct sockaddr"></a>struct sockaddr</h6><p>在C语言中用于网络编程的 <code>struct sockaddr</code> 是一个通用的地址结构，用于处理各种类型的套接字地址。这个结构通常与专用的地址结构一起使用，如 <code>struct sockaddr_in</code>（用于IPv4地址）和 <code>struct sockaddr_in6</code>（用于IPv6地址）。由于历史原因和向后兼容性，<code>struct sockaddr</code> 被广泛用于套接字函数中，如 <code>bind()</code>, <code>connect()</code>, <code>accept()</code> 等。</p>
<p><strong><code>struct sockaddr</code>的定义</strong>；</p>
<p><code>struct sockaddr</code> 在 <code>&lt;sys/socket.h&gt;</code> 头文件中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;  <span class="comment">// 地址族（AF_INET, AF_INET6, AF_UNIX 等）</span></span><br><span class="line">    <span class="type">char</span>        sa_data[<span class="number">14</span>]; <span class="comment">// 14字节，足以容纳任何类型的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>为什么使用<code>struct sockaddr</code></strong></p>
<p><code>struct sockaddr</code> <strong>本身并不常直接用于存储地址信息</strong>，因为它不提供足够的空间来存储具体的地址详情。相反，<strong>更具体的结构</strong>如 <code>struct sockaddr_in</code> 用于IPv4地址，而 <code>struct sockaddr_in6</code> 用于IPv6地址。这些结构包含了特定于协议的地址信息，如IP地址和端口号</p>
<p><strong>当调用套接字函数时，这些特定的地址结构被转换</strong>为 <code>struct sockaddr</code> 类型的指针，以便提供一个通用的接口。例如，<code>bind()</code> 函数接受 <code>struct sockaddr *</code> 类型的参数，尽管实际传递的可能是 <code>struct sockaddr_in *</code> 类型的地址</p>
<p><strong><code>struct sockaddr_in</code>的定义</strong></p>
<p>对于IPv4网络编程，通常使用 <code>struct sockaddr_in</code>，它在 <code>&lt;netinet/in.h&gt;</code> 中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">short</span>            sin_family;   <span class="comment">// 地址族，AF_INET</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>   sin_port;     <span class="comment">// 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>   <span class="title">sin_addr</span>;</span>     <span class="comment">// IPv4地址</span></span><br><span class="line">    <span class="type">char</span>             sin_zero[<span class="number">8</span>];  <span class="comment">// 填充以保持与struct sockaddr相同的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 <code>struct in_addr</code> 结构仅包含一个无符号长整型的IP地址。</p>
<p><code>struct in_addr</code> 类型的 <code>sin_addr</code> 成员用于存储IPv4网络地址。<code>struct in_addr</code> 是专门设计来容纳IPv4地址的结构</p>
<p><strong><code>struct in_addr</code> 的定义</strong>：</p>
<p>在 <code>&lt;netinet/in.h&gt;</code> 头文件中，<code>struct in_addr</code> 通常被定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr; <span class="comment">// 32位IPv4地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>s_addr</code> 是一个无符号的32位整数，用于存储IPv4地址。在网络通信中，IPv4地址通常以网络字节序（大端）存储。<code>s_addr</code> 是一个无符号的32位整数，用于存储IPv4地址。在网络通信中，IPv4地址通常以网络字节序（大端）存储。</p>
<p><strong>使用<code>struct in_addr</code></strong></p>
<p>在使用 <code>struct sockaddr_in</code> 结构时，你通常会通过操作 <code>sin_addr</code> 的 <code>s_addr</code> 成员来指定IPv4地址。以下是一些常见的用法：</p>
<ul>
<li><p><strong>指定任意地址</strong>：使用 <code>INADDR_ANY</code>，它通常被定义为 <code>0.0.0.0</code>，这表示套接字可以绑定到机器上的任何IP地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指定具体的IP地址</strong>：使用 <code>inet_addr()</code> 函数将点分十进制的IP地址字符串转换为合适的格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.1.1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>或者使用 <code>inet_aton()</code> 函数，这是一个更健壮的选择</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ip</span>;</span></span><br><span class="line">inet_aton(<span class="string">&quot;192.168.1.1&quot;</span>, &amp;ip);</span><br><span class="line">addr.sin_addr = ip;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="inet-addr"><a href="#inet-addr" class="headerlink" title="inet_addr()"></a>inet_addr()</h6><p><code>inet_addr()</code> 函数用于将一个点分十进制的IPv4地址字符串转换为一个网络字节序的整数值。这个函数是处理IPv4地址的传统方法，<strong>但它已经被更现代和灵活的 <code>inet_pton()</code> 函数所取代。尽管如此，<code>inet_addr()</code> 仍然在许多程序中使用</strong></p>
<p><code>inet_addr()</code> 函数的原型定义在 <code>&lt;arpa/inet.h&gt;</code> 头文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cp</code>：指向以零结尾的字符数组的指针，这个数组包含了一个点分十进制的IP地址（如 “192.168.1.1”）。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功时，函数返回一个无符号的32位整数，表示IPv4地址的网络字节序。</li>
<li>失败时，如果输入不是有效的IPv4地址，它返回 <code>INADDR_NONE</code>，通常等于 <code>-1</code>（或 <code>0xFFFFFFFF</code>）。</li>
</ul>
<h6 id="inet-pton"><a href="#inet-pton" class="headerlink" title="inet_pton()"></a>inet_pton()</h6><p><code>inet_pton()</code> 函数是用于将点分十进制的IP地址（如 “192.168.1.1”）转换为网络字节序的二进制形式的函数。这个函数是 <code>inet_addr()</code> 的一个更现代和通用的替代，它支持IPv4和IPv6地址</p>
<p><code>inet_pton()</code> 函数的原型定义在 <code>&lt;arpa/inet.h&gt;</code> 头文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>af</code>：指定地址族，<code>AF_INET</code> 用于IPv4地址，<code>AF_INET6</code> 用于IPv6地址。</li>
<li><code>src</code>：指向要转换的以零结尾的字符数组（即C字符串）的指针，这个数组包含了一个点分十进制的IP地址（对于IPv4）或一个十六进制的IP地址（对于IPv6）。</li>
<li><code>dst</code>：指向一个足够大的缓冲区的指针，该缓冲区用于存储转换后的网络地址。对于IPv4，这通常是一个 <code>struct in_addr</code>；对于IPv6，这通常是一个 <code>struct in6_addr</code>。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>返回 <code>1</code> 表示转换成功。</li>
<li>返回 <code>0</code> 表示 <code>src</code> 不包含有效的IP地址。</li>
<li>返回 <code>-1</code> 表示发生错误，<code>errno</code> 会设置为相应的错误代码。</li>
</ul>
<h6 id="inet-ntop"><a href="#inet-ntop" class="headerlink" title="inet_ntop()"></a>inet_ntop()</h6><p><code>inet_ntop</code> 函数是一种在C语言中用于网络编程的函数，它用于将网络地址（如IPv4或IPv6地址）从其数值形式转换为标准文本形式（如点分十进制格式的IPv4地址或冒号分隔格式的IPv6地址）。与旧的 <code>inet_ntoa</code> 函数相比，<code>inet_ntop</code> 提供了更大的灵活性和安全性，它支持IPv6，并且是线程安全的。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>af</code>: 地址族，<code>AF_INET</code> 用于IPv4地址，<code>AF_INET6</code> 用于IPv6地址。</li>
<li><code>src</code>: 指向一个包含要转换的网络地址的缓冲区的指针。</li>
<li><code>dst</code>: 指向目的缓冲区的指针，这里将存储转换后的文本地址。</li>
<li><code>size</code>: 目的缓冲区的大小</li>
</ul>
<p>返回值：</p>
<p>如果函数成功，返回一个指向结果字符串的指针。如果发生错误，则返回 <code>NULL</code></p>
<p><strong>注意</strong>：</p>
<p>使用 <code>inet_ntop</code> 时，您需要提供足够大的缓冲区来存储转换后的地址。对于IPv4，这个缓冲区应至少为16个字符的长度（包括终止空字符）。对于IPv6，建议的最小大小是46个字符。</p>
<h6 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h6><p><code>listen</code> 函数的作用是启动监听来自客户端的连接请求</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>sockfd</code>：这是由之前调用 <code>socket</code> 函数得到的套接字文件描述符。</li>
<li><code>backlog</code>：这个参数指定了队列中最多可以容纳的等待接受的连接请求的数量。它决定了同时可以有多少个客户端处于连接等待状态。</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果函数调用成功，它会返回0。</li>
<li>如果调用失败，会返回-1，并设置相应的错误码，可以通过 <code>errno</code> 获取错误详情。</li>
</ul>
<p><strong>使用流程</strong>：</p>
<ul>
<li>创建套接字：使用 <code>socket</code> 函数创建一个套接字</li>
<li>绑定地址：使用 <code>bind</code> 函数将套接字与特定的IP地址和端口号绑定</li>
<li>监听连接：使用 <code>listen</code> 函数开始监听连接请求</li>
<li>接受连接：使用 <code>accept</code> 函数接受来自客户端的连接</li>
</ul>
<h6 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h6><p>套接字编程的 <code>accept</code> 函数<strong>用于服务器端接受来自客户端的连接请求</strong>。一旦 <code>listen</code> 函数在服务器端套接字上启动了对连接请求的监听，<code>accept</code> 函数就可以用来接受这些请求</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<ul>
<li><code>sockfd</code>：这是服务器端监听的套接字的文件描述符，之前由 <code>socket</code> 函数创建并通过 <code>bind</code> 和 <code>listen</code> 函数设置</li>
<li><code>addr</code>：这是一个指向 <code>struct sockaddr</code> 的指针，用于接收一个返回值，表示连接到服务器的客户端的地址。该参数可以设置为 <code>NULL</code>，如果你不需要获取客户端地址。</li>
<li><code>addrlen</code>：这是一个指向 <code>socklen_t</code> 类型变量的指针，初始时应该设置为指向一个值，表示 <code>addr</code> 结构的大小。函数返回时，这个值会被更新为实际接收到的地址的大小。如果 <code>addr</code> 是 <code>NULL</code>，<code>addrlen</code> 也应该是 <code>NULL</code></li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时返回一个新的套接字文件描述符，用于与连接的客户端进行通信。</li>
<li>失败时返回-1，并设置 <code>errno</code> 以指示错误原因</li>
</ul>
<h6 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h6><p>接字编程的 <code>connect</code> 函数用于<strong>客户端与服务器端建立连接</strong>。这个函数在客户端套接字上调用，指定服务器的地址和端口，以便建立到服务器的连接。</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>参数;</p>
<ul>
<li><code>sockfd</code>：这是一个套接字文件描述符，之前由 <code>socket</code> 函数创建。</li>
<li><code>addr</code>：这是一个指向 <code>struct sockaddr</code> 的指针，它包含了目的地（服务器）的地址和端口信息。对于IPv4，通常使用 <code>struct sockaddr_in</code> 来设置该参数，并将其转换为 <code>struct sockaddr</code> 类型的指针进行传递。</li>
<li><code>addrlen</code>：这是 <code>addr</code> 参数所指向的地址结构的大小</li>
</ul>
<p>返回值</p>
<ul>
<li>成功时返回0。</li>
<li>失败时返回-1，并设置 <code>errno</code> 以指示错误原因。</li>
</ul>
<h6 id="send-—TCP"><a href="#send-—TCP" class="headerlink" title="send()—TCP"></a>send()—TCP</h6><p>套接字编程的 <code>send</code> 函数用于向一个已连接的套接字发送数据。这个函数常<strong>用于客户端和服务器端的套接字通信中</strong></p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>sockfd</code>：这是一个指向已连接套接字的文件描述符。</li>
<li><code>buf</code>：这是一个指针，指向要发送的数据的缓冲区。</li>
<li><code>len</code>：这是要发送的数据的字节数。</li>
<li><code>flags</code>：这是指定调用执行方式的标志位集合。常用的标志包括 <code>MSG_OOB</code>（发送带外数据），<code>MSG_DONTROUTE</code>（不使用路由表），和 <code>MSG_NOSIGNAL</code>（防止发送信号）。在大多数情况下，这个值可以设为0。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时返回实际发送的字节数。</li>
<li>失败时返回-1，并设置 <code>errno</code> 以指示错误原因。</li>
</ul>
<h6 id="recv-—TCP"><a href="#recv-—TCP" class="headerlink" title="recv()—TCP"></a>recv()—TCP</h6><p>套接字编程的 <code>recv</code> 函数用于<strong>从一个已连接的套接字接收数据</strong>。这个函数常用于客户端和服务器端的套接字通信中，用于读取从另一端发送过来的数据</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>参数原型</p>
<ul>
<li><code>sockfd</code>：这是一个套接字文件描述符，表示已经建立连接的套接字。</li>
<li><code>buf</code>：这是一个指针，指向用于接收数据的缓冲区。</li>
<li><code>len</code>：这是缓冲区的大小，指定最多可以接收的字节数。</li>
<li><code>flags</code>：这是指定调用执行方式的标志位集合。常用的标志包括 <code>MSG_PEEK</code>（查看数据但不从队列中移除）和 <code>MSG_WAITALL</code>（等待所有请求的数据到达才返回）。在大多数情况下，这个值可以设为0。</li>
</ul>
<p>返回值</p>
<ul>
<li>成功时返回接收到的字节数。如果连接已经结束，返回0。</li>
<li>失败时返回-1，并设置 <code>errno</code> 以指示错误原因。</li>
</ul>
<h6 id="sendto-—UDP"><a href="#sendto-—UDP" class="headerlink" title="sendto()—UDP"></a>sendto()—UDP</h6><p>在C语言中，<code>sendto</code> 函数是用于发送数据到特定目的地的网络编程函数，<strong>特别是在使用无连接的网络协议（如UDP）时</strong>。该函数允许你发送数据到指定的地址和端口，这在UDP通信中是必需的，因为UDP是一种无连接的协议，不会维持一个持久的连接状态。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><code>sockfd</code>: 这是套接字描述符，它引用了一个已经打开的套接字。</li>
<li><code>buf</code>: 指向包含要发送数据的缓冲区的指针。</li>
<li><code>len</code>: 要发送的数据的字节长度。</li>
<li><code>flags</code>: 通常设置为0，但可以指定额外的标志来控制发送行为。</li>
<li><code>dest_addr</code>: 指向包含目的地址（如对方的IP地址和端口）的 <code>struct sockaddr</code> 结构的指针。</li>
<li><code>addrlen</code>: <code>dest_addr</code> 指向的结构的大小。</li>
</ul>
<p>返回值：</p>
<p>如果函数成功，返回发送的字节数。如果出现错误，则返回-1，并设置相应的错误码。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li><p><strong>UDP套接字</strong>: <code>sendto</code> 通常在UDP客户端和服务器中使用，用于向特定的地址和端口发送数据包。</p>
</li>
<li><p><strong>错误处理</strong>: 应检查返回值以确定是否成功发送了数据，并相应地处理错误情况。</p>
</li>
</ul>
<h6 id="recvfrom-—UDP"><a href="#recvfrom-—UDP" class="headerlink" title="recvfrom()—UDP"></a>recvfrom()—UDP</h6><p><code>recvfrom</code> 函数是用于从网络套接字接收数据的函数，特别是在使用无连接的网络协议（如UDP）时。这个函数不仅接收数据，还可以获取发送方的地址信息(<strong>UDP是无连接的需要记住发送方是谁</strong>)，这在UDP通信中非常重要，因为UDP是无连接的，不会保持与发送方的持续连接状态。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><p><code>sockfd</code>: 这是套接字文件描述符，它引用了你想从中接收数据的套接字。</p>
</li>
<li><p><code>buf</code>: 这个指针指向一个缓冲区，该缓冲区用于存储接收到的数据。</p>
</li>
<li><p><code>len</code>: 这是缓冲区的大小，指定了最多可以接收多少字节的数据。</p>
</li>
<li><p><code>flags</code>: 这通常设置为0，但可以设置为控制接收行为的特定标志。</p>
</li>
<li><p><code>src_addr</code>: 这是一个指向 <code>struct sockaddr</code> 结构的指针，用于存储发送方的地址信息。</p>
</li>
<li><p><code>addrlen</code>: 这是一个指向 <code>socklen_t</code> 变量的指针，该变量在调用之前应该被初始化为 <code>src_addr</code> 指向的结构的大小。调用完成后，它将被设置为实际地址结构的大小。</p>
</li>
</ul>
<p>返回值：</p>
<ul>
<li><code>recvfrom</code> 函数返回接收到的字节数，或者在出错时返回-1。</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li><strong>UDP套接字</strong>: 通常在UDP服务器和客户端中使用<code>recvfrom</code>来接收数据包，因为UDP是无连接的。</li>
<li><strong>错误处理</strong>: 通过检查返回值和错误代码来处理可能发生的网络错误。</li>
</ul>
<h6 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h6><p>关闭套接字</p>
<hr>
<h5 id="（2）特殊地址0-0-0-0"><a href="#（2）特殊地址0-0-0-0" class="headerlink" title="（2）特殊地址0.0.0.0"></a>（2）特殊地址0.0.0.0</h5><p>在网络编程中，IP地址 <code>0.0.0.0</code> 有一个特殊的含义。它通常不用作一个特定的目标地址，而是用于表示一个“不指定的”或“任意的”地址。这个地址的具体含义取决于其使用的上下文</p>
<ul>
<li><p><strong>在服务器端</strong>：</p>
<p>当一个服务器程序绑定到IP地址 <code>0.0.0.0</code> 时，它表明该服务器将接受针对主机的所有IPv4地址的网络连接。这对于多网卡（多接口）的机器特别有用，因为它允许服务器在所有网络接口上监听，而不需要为每个接口指定一个单独的IP地址。</p>
<p>例如，如果一台服务器有两个网络接口，一个绑定了IP地址 <code>192.168.1.5</code>，另一个绑定了 <code>10.0.0.5</code>，那么绑定到 <code>0.0.0.0</code> 将允许该服务器在两个接口上都接受连接。</p>
</li>
<li><p><strong>在客户端</strong>：</p>
<p>在客户端使用 <code>0.0.0.0</code> 时，它通常表示“任意IPv4地址”或“从任何网络接口出去”。然而，实际中，客户端很少使用这个地址，因为在发起网络连接时，通常需要指定一个明确的目的地址。</p>
</li>
<li><p><strong>在路由表中</strong>：</p>
</li>
<li><p>在路由表中，<code>0.0.0.0</code> 通常用来表示默认路由（也称为“缺省网关”）。这意味着，如果没有为特定目的地找到更具体的路由，数据包将被发送到这个默认路由。</p>
</li>
</ul>
<p>因此，<code>0.0.0.0</code> 在不同的场景中有不同的用途，但总的来说，它代表了一种“任何”或“通用”的概念，在网络配置和编程中具有重要意义。</p>
<hr>
<hr>
<h4 id="3-报式套接字-UDP"><a href="#3-报式套接字-UDP" class="headerlink" title="3.报式套接字(UDP)"></a>3.报式套接字(UDP)</h4><p>报式套接字（Datagram Socket）是一种在网络通信中使用的套接字类型，它提供<strong>了无连接的、不可靠的、独立的消息传输。报式套接字通常与用户数据报协议（UDP）一起使用，适用于那些不需要建立连接、可以容忍一定丢包、追求传输效率的场景</strong>，如视频会议、在线游戏、实时系统等。</p>
<p><strong>报式套接字主要特性</strong>：</p>
<ul>
<li><strong>无连接</strong>：数据传输前不需要建立连接；每个数据包（报文）独立发送，彼此之间没有依赖关系</li>
<li><strong>不可靠性</strong>：不保证数据包的可靠到达，可能会丢失、重复或乱序；没有确认机制和重传机制</li>
<li><strong>数据有边界</strong>：数据包作为独立单元发送，每个包的边界被保留；接收方能够识别出单独的数据包</li>
<li><strong>效率高</strong>：由于缺乏连接建立和维持、无需确认和重传机制，使得通信效率较高</li>
</ul>
<p><strong>创建报式套接字</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这里，<code>AF_INET</code> 指定使用IPv4地址，<code>SOCK_DGRAM</code> 指定使用报式套接字，<code>0</code> 表示默认协议（通常是UDP）</p>
<p><strong>使用报式套接字</strong>：</p>
<ul>
<li><strong>发送数据</strong>：使用 <code>sendto()</code> 函数，指定目的地址和端口，将数据包发送出去</li>
<li><strong>接收数据</strong>：使用 <code>recvfrom()</code> 函数，从套接字接收数据包</li>
</ul>
<p><strong>收发双方的步骤</strong>：</p>
<ul>
<li><p>被动端（先收包的一方，先运行）：</p>
<p>取得SOCKET</p>
<p>给SOCKET取得地址（bind()）</p>
<p>收&#x2F;发消息</p>
<p>关闭SOCKET</p>
</li>
<li><p>主动端：</p>
<p>取得SOCKET</p>
<p>给SOCKET取得地址（可省略）</p>
<p>发&#x2F;收消息</p>
<p>关闭SOCKET</p>
</li>
</ul>
<h5 id="（1）注意"><a href="#（1）注意" class="headerlink" title="（1）注意"></a>（1）注意</h5><p>被动端的第二步，给SOCKET取得地址，无法省略，因为需要告知发送方，自己的IP与端口才可以用于接收信息</p>
<p>主动端的第二步，给SOCKET取得地址，可以省略，若进行省略，则可以得到机器当前空闲的端口进行使用，而ip则是主机ip</p>
<hr>
<h5 id="（2）报式套接字传输实例"><a href="#（2）报式套接字传输实例" class="headerlink" title="（2）报式套接字传输实例"></a>（2）报式套接字传输实例</h5><h6 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h6><p>使用UDP套接字进行数据通信传输</p>
<p><code>proto.h</code></p>
<p>通信协议头文件，在头文件中定义接收方使用的端口，以及通信所使用的数据格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 通信协议</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BASIC_PROTO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_PROTO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCVPORT <span class="string">&quot;1989&quot;</span>   <span class="comment">// 做实验尽量使用1024以上的端口，因为这些端口一般都是预留下来的</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 11</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="type">uint32_t</span> math;</span><br><span class="line">    <span class="type">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"><span class="comment">// __attribute__((packed)) 告知编译器 结构体不进行地址对齐</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//BASIC_PROTO_H</span></span></span><br></pre></td></tr></table></figure>



<h6 id="接收方源码"><a href="#接收方源码" class="headerlink" title="接收方源码"></a>接收方源码</h6><p><code>rever.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 接收方</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSTRSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">recvbuf</span>;</span>  <span class="comment">// 用于存储接收的信息结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span>   <span class="comment">// 定义一个用于ipv4协议的地址结构体 之后强转为struct sockaddr*，用于bind的第二个参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span>   <span class="comment">// 用于在recvfrom 函数中存储发送方的地址IP信息</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];  <span class="comment">// 存储发送方点分式 IP</span></span><br><span class="line">    laddr.sin_family = AF_INET; <span class="comment">// IPV4协议族</span></span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT));   <span class="comment">// 通信协议头文件指定的 端口号,并且字节序要进行转换，从主机字节序转换为网络字节序</span></span><br><span class="line">    <span class="comment">// 使用 inet_addr()函数将点分十进制的IP地址字符串转换为合适的格式--无符号的整型数</span></span><br><span class="line">    <span class="comment">// 地址可能变化，因此可是选择万能地址0.0.0.0</span></span><br><span class="line">    <span class="comment">// laddr.sin_addr.s_addr = inet_addr(&quot;0.0.0.0&quot;); // IPV4的地址 32位无符号的整型数---但是实际的IP地址是点分式如:192.168.1.1 因此需要进行使用inet_addr函数进行转换</span></span><br><span class="line">    <span class="comment">// 替代上文该句代码</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得socket</span></span><br><span class="line">    <span class="comment">// 1.AF_INET 为ipv4网络协议族</span></span><br><span class="line">    <span class="comment">// 2.SOCK_DGRAM 为报式套接字传输方式，通常用于UDP</span></span><br><span class="line">    <span class="comment">// 3.不确定使用什么协议时，可以直接使用参数 0（即报式套接字的默认协议,IPPROTO_UDP）</span></span><br><span class="line">    <span class="comment">// 4.返回一个套接字描述符</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字与特定的IP地址和端口号绑定</span></span><br><span class="line">    <span class="comment">// 1.函数调用返回的套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 2.是指向struct sockaddr结构的指针，该结构包含了要绑定的IP地址和端口号，参数2，可以使用(struct sockaddr *)进行转换但是(void *)是万能的</span></span><br><span class="line">    <span class="comment">// 3.指定了addr结构的大小</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="type">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*！！！*/</span></span><br><span class="line">    <span class="comment">/*特别重要需要对socklen_t raddr_len进行初始化，否则第一次通信时，会出错*/</span></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从Socket上接收信息 -- UDP使用 recvfrom</span></span><br><span class="line">        <span class="comment">// 1.socket函数返回的套接字描述符</span></span><br><span class="line">        <span class="comment">// 2.接收的信息存储的结构体，在通信协议中有定义</span></span><br><span class="line">        <span class="comment">// 3.无特殊要求就填写0</span></span><br><span class="line">        <span class="comment">// 4.用于存储发送方的地址IP信息结构体，根据具体协议定义（如:IPV4或者IPV6），最后需要进行强转为(struct sockaddr *)类型</span></span><br><span class="line">        <span class="comment">// 5. 参数4存储发送方地址的结构体大小,类型为 socklen_t</span></span><br><span class="line">        recvfrom(sd,&amp;recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="comment">// 打印发送方的地址与端口,端口号需要从网络字节序转换为主机字节序</span></span><br><span class="line">        <span class="comment">// 地址需要从32号无符号整数转换为 点分式 192.168.0.0类型 使用函数 inet_ntop函数转换为点分式并且存储至 ipstr中</span></span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---MESSAGE FROM %s:%d---\n&quot;</span>,ipstr, ntohs(raddr.sin_port));</span><br><span class="line">        <span class="comment">// 打印接收的结构体中的信息 name 是char 类型的为单字节 不需要转换字节序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name:%s\n&quot;</span>,recvbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;chinese:%d\n&quot;</span>,ntohl(recvbuf.chinese));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;math:%d\n&quot;</span>,ntohl(recvbuf.math));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收方（被动方先运行），编译接收方源码，运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make rever</span><br><span class="line">$ ./rever</span><br></pre></td></tr></table></figure>

<p>使用指令查看机器网络状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -anu   // netstat -aut 查看tcp通信情况</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>0.0.0.0;1989</code>在运行（地址与端口）</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401162225625.png" alt="image-20240116222533582"></p>
<h6 id="发送方源码"><a href="#发送方源码" class="headerlink" title="发送方源码"></a>发送方源码</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 发送方</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span> <span class="comment">// 待发送的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span> <span class="comment">// 发送目标的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;USage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得套接字 IPV4协议族 UDP套接字</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;scoket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将socket与地址绑定可以省略 因为UDP通信不需要进行连接，地址ip（本机ip）与端口(系统会分配一个空闲的给程序)</span></span><br><span class="line">    <span class="comment">// bind()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义需要发送的数据</span></span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">&quot;ZXZ&quot;</span>);  <span class="comment">// char为单字节 无需进行字节序转换</span></span><br><span class="line">    <span class="comment">// 下面数据需要进行 从主机字节序向网络字节序的转换</span></span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化发送 目标（远端的）的地址</span></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,argv[<span class="number">1</span>],&amp;raddr.sin_addr); <span class="comment">//地址用户写的是点分式 而程序需要的使用unint32_t的整型数，需要进行转换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信息至socket UDP使用 sendto函数</span></span><br><span class="line">    <span class="comment">// 1.socket函数套接字描述符</span></span><br><span class="line">    <span class="comment">// 2.指向包含要发送数据的缓冲区的指针</span></span><br><span class="line">    <span class="comment">// 3.要发送的数据的字节长度</span></span><br><span class="line">    <span class="comment">// 4.通常设置为0，但可以指定额外的标志来控制发送行为</span></span><br><span class="line">    <span class="comment">// 5.指向包含目的地址（如对方的IP地址和端口）的struct sockaddr结构的指针</span></span><br><span class="line">    <span class="comment">// 6.dest_addr指向的结构的大小</span></span><br><span class="line">    <span class="comment">// 返回值小于0 则报错结束</span></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf, <span class="keyword">sizeof</span>(sbuf),<span class="number">0</span>,(<span class="type">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Send successful!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make snder</span><br><span class="line">$ ./snder 127.0.0.1    // 127.0.0.1 本地ip  因为是在该实例是在一个机器内运行 本机运行</span><br></pre></td></tr></table></figure>



<h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p>可以发现接收方接收信息显示如下：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401162229599.png" alt="image-20240116222906568"></p>
<hr>
<hr>
<h4 id="4-多点通讯"><a href="#4-多点通讯" class="headerlink" title="4.多点通讯"></a>4.多点通讯</h4><p>多点通讯属于报式套接字，流式套接字是点对点的通信</p>
<h5 id="（1）广播（全网广播-子网广播）"><a href="#（1）广播（全网广播-子网广播）" class="headerlink" title="（1）广播（全网广播\子网广播）"></a>（1）广播（全网广播\子网广播）</h5><h6 id="255-255-255-255"><a href="#255-255-255-255" class="headerlink" title="255.255.255.255"></a>255.255.255.255</h6><p>地址 <code>255.255.255.255</code> 在计算机网络中是一个特殊的广播地址。这个地址用于网络广播，它允许一台计算机发送信息给同一子网内的所有其他设备。在使<strong>用这个地址时，数据包会被发送到与发送者在同一本地网络（LAN）内的所有接收者</strong></p>
<p>值得注意的是，这个地址仅限于本地网络使用，它不会被路由器转发到互联网上。这意味着，使用这个地址的信息只能在同一子网内的设备之间传播。在更广泛的网络应用中，这个地址并不用于公共互联网通信。</p>
<h6 id="Socket-options"><a href="#Socket-options" class="headerlink" title="Socket options"></a>Socket options</h6><p>在计算机网络中，<code>Socket Options</code>是用于修改套接字行为的一系列配置。套接字是网络通信中用于发送和接收数据的端点。在编程中，尤其是在TCP&#x2F;IP（传输控制协议&#x2F;互联网协议）栈的上下文中，<strong>可以设置各种套接字选项，以控制其行为和性能</strong>。这些选项包括但不限于：</p>
<ul>
<li><strong>O_REUSEADDR</strong>：允许重用本地地址和端口。这对于服务器快速重启非常有用，可以立即绑定到相同的地址和端口。</li>
<li><strong>SO_KEEPALIVE</strong>：启用保活机制。如果在一定时间内没有数据交换，TCP将自动发送保活探测包。</li>
<li><strong>SO_LINGER</strong>：控制套接字关闭的行为。它可以用来确保数据完全发送或设置套接字关闭前的超时时间。</li>
<li><strong>SO_RCVBUF</strong> 和 <strong>SO_SNDBUF</strong>：分别设置接收和发送缓冲区的大小。这对于控制数据传输的性能很重要。</li>
<li><strong>SO_TIMEOUT</strong>：设置套接字操作的超时时间，如接收和发送数据。</li>
<li><strong>TCP_NODELAY</strong>（针对TCP套接字）：禁用Nagle算法来减少发送延迟。这对于需要低延迟的应用很有用，如实时游戏或音视频通信。</li>
<li><strong>SO_BROADCAST</strong>：设置或获取广播标志。启用时，数据报套接字被允许发送数据包到一个广播地址。这个选项对面向流的套接字没有影响。(<strong>打开这个开关则可以实现广播</strong>,但是没有打开可能也可以接收到广播地址的数据包，这个属于未定义行为)</li>
<li><strong>IP_MULTICAST_IF</strong>：是一个套接字选项（socket option），用于指定用于传出多播数据包的接口。在多播通信中，当你的设备有多个网络接口时，<code>IP_MULTICAST_IF</code> 允许你选择其中一个接口用于发送多播流量。这在服务器端编程中尤其有用，因为它确保多播数据包通过正确的网络接口发送。</li>
</ul>
<h6 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt()"></a>setsockopt()</h6><p><code>setsockopt()</code> 函数用于设置套接字的选项，以控制其行为。这个函数是 Socket 编程接口的一部分，广泛用于网络通信程序中。<code>setsockopt()</code> 函数允许程序员设置各种套接字级别的选项，例如 TCP&#x2F;IP 协议的参数、缓冲区大小、超时设置等</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>sockfd</strong>：这是要设置选项的套接字的文件描述符。</li>
<li><strong>level</strong>：指定选项所在的<strong>协议层</strong>。例如，要设置 TCP 协议的选项，可以使用 <code>IPPROTO_TCP</code>。对于通用的套接字选项，使用 <code>SOL_SOCKET</code>。</li>
<li><strong>optname</strong>：这是你想要设置的选项。例如，<code>SO_REUSEADDR</code>、<code>SO_RCVBUF</code> 等。</li>
<li><strong>optval</strong>：指向包含新选项值的缓冲区的指针（<strong>这个参数的确切类型和内容取决于参数3，用户想要设置的具体套接字选项</strong>，对于布尔类型的选项，通常设置为1表示启用或0表示禁用，如SO_BROADCAST，允许发送广播消息，就是bool类型的选项）</li>
<li><strong>optlen</strong>：optval 缓冲区的大小。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时，<code>setsockopt()</code> 返回 0</li>
<li>失败时返回 -1，并设置 <code>errno</code> 以指示错误</li>
</ul>
<h6 id="getsockopt"><a href="#getsockopt" class="headerlink" title="getsockopt()"></a>getsockopt()</h6><p><code>getsockopt()</code> 函数用于获取套接字的当前选项设置。这个函数是Socket编程接口的一部分，用于检索套接字选项的状态，如缓冲区大小、超时设置等</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>sockfd</strong>：这是要获取选项的套接字的文件描述符。</li>
<li><strong>level</strong>：指定选项所在的协议层。例如，要获取 TCP 协议的选项，可以使用 <code>IPPROTO_TCP</code>。对于通用的套接字选项，使用 <code>SOL_SOCKET</code>。</li>
<li><strong>optname</strong>：这是你想要获取的选项。例如，<code>SO_REUSEADDR</code>、<code>SO_RCVBUF</code> 等。</li>
<li><strong>optval</strong>：指向一个缓冲区的指针，在这个缓冲区中，<code>getsockopt()</code> 会存放获取的选项值。</li>
<li><strong>optlen</strong>：一开始是一个指向包含 optval 缓冲区大小的变量的指针。当 <code>getsockopt()</code> 返回时，这个变量被设置为实际获取的选项值的大小。</li>
</ul>
<p>返回值</p>
<ul>
<li>成功时，<code>getsockopt()</code> 返回 0；</li>
<li>失败时返回 -1，并设置 <code>errno</code> 以指示错误</li>
</ul>
<h6 id="if-nametoindex"><a href="#if-nametoindex" class="headerlink" title="if_nametoindex()"></a>if_nametoindex()</h6><p><code>if_nametoindex</code> 是一个在 Unix 和类 Unix 系统（比如 Linux）上常用的函数，它用于将网络接口名称（如 “eth0”、”wlan0” 等）转换为对应的接口索引号。这个接口索引号通常用于网络编程中，特别是在处理多播或原始套接字时。</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">if_nametoindex</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ifname)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><strong>ifname</strong>:网络接口名称</li>
</ul>
<p>返回值：</p>
<ul>
<li>网络接口索引号</li>
</ul>
<h6 id="ip-ro-sh"><a href="#ip-ro-sh" class="headerlink" title="ip ro sh"></a>ip ro sh</h6><p>ubuntu终端命令 <code>ip ro sh</code> 是 <code>ip route show</code> 的缩写形式。这个命令<strong>用于显示系统的路由表信息</strong>。路由表是操作系统用来决定如何将数据包从一个网络传输到另一个网络的规则集。</p>
<p>具体来说，这个命令可以提供以下信息：</p>
<ul>
<li><strong>目的网络</strong>：显示数据包的目的地网络和掩码。</li>
<li><strong>网关</strong>：数据包被发送到的下一个跳跃点（如果适用）。</li>
<li><strong>源地址</strong>：出站数据包的源地址（如果有特定路由策略）。</li>
<li><strong>使用的接口</strong>：用于发送数据包的网络接口，例如 <code>eth0,</code> <code>wlan0 </code>等。</li>
</ul>
<p>举个例子，如果你在终端中运行 <code>ip ro sh</code>，可能会看到类似这样的输出：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> dev eth0 </span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span> dev eth0 proto kernel scope link src <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span> </span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li>第一行表示默认路由（<code>default</code>），所有不属于本地子网的流量都会通过这个路由发送。这里的默认网关是 <code>192.168.1.1</code>，通过 <code>eth0</code> （以太网接口）接口。</li>
<li>第二行描述了本地子网的路由。它显示了子网 <code>192.168.1.0/24</code> 是直接通过 <code>eth0</code> 接口可达的，本机的IP地址是 <code>192.168.1.2</code>。</li>
</ul>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401182236457.png" alt="image-20240118223637419"></p>
<hr>
<h5 id="（2）广播实例程序"><a href="#（2）广播实例程序" class="headerlink" title="（2）广播实例程序"></a>（2）广播实例程序</h5><h6 id="通信协议-1"><a href="#通信协议-1" class="headerlink" title="通信协议"></a>通信协议</h6><p><code>proto.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by zxz on 2024/1/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BASIC_PROTO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_PROTO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCVPORT <span class="string">&quot;1989&quot;</span>   <span class="comment">// 做实验尽量使用1024以上的端口，因为这些端口一般都是预留下来的</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 11</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="type">uint32_t</span> math;</span><br><span class="line">    <span class="type">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"><span class="comment">// __attribute__((packed)) 告知编译器 结构体不进行地址对齐</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//BASIC_PROTO_H</span></span></span><br></pre></td></tr></table></figure>



<h6 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h6><p>发送方需要向广播地址，进行发包，在发送方中需要将目标地址改为<code>255.255.255.255</code>网络广播地址，此外需要在程序中设置Socket Options,开启套接字广播允许标志</p>
<p><code>snder.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 发送方</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span> <span class="comment">// 待发送的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span> <span class="comment">// 发送目标的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得套接字 IPV4协议族 UDP套接字</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;scoket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Socket属性</span></span><br><span class="line">    <span class="comment">// 1.套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 2.选项所在的协议层，实例程序需要在套接字层面进行操作，即SOL_SOCKET</span></span><br><span class="line">    <span class="comment">// 3.想要设置的选项，如允许发送广播信息：SO_BROADCAST</span></span><br><span class="line">    <span class="comment">// 4.optval指向包含新选项值的缓冲区的指针</span></span><br><span class="line">    <span class="comment">// 4.参数4（根据参数3，设置的选项填写参数4，对于布尔类型的选项，通常设置为1表示启用或0表示禁用）</span></span><br><span class="line">    <span class="comment">// 5.optval缓冲区的大小</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_BROADCAST,&amp;(val),<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将socket与地址绑定可以省略 地址ip（本机ip）与端口(系统会分配一个空闲的给程序)</span></span><br><span class="line">    <span class="comment">// bind()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义需要发送的数据</span></span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">&quot;ZXZ&quot;</span>);  <span class="comment">// char为单字节 无需进行字节序转换</span></span><br><span class="line">    <span class="comment">// 下面数据需要进行 从主机字节序向网络字节序的转换</span></span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化发送 目标（远端的）的地址---广播地址为 255.255.255.255</span></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;255.255.255.255&quot;</span>,&amp;raddr.sin_addr); <span class="comment">//地址用户写的是点分式 而程序需要的使用unint32_t的整型数，需要进行转换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信息至socket UDP使用 sendto函数</span></span><br><span class="line">    <span class="comment">// 1.socket函数套接字描述符</span></span><br><span class="line">    <span class="comment">// 2.指向包含要发送数据的缓冲区的指针</span></span><br><span class="line">    <span class="comment">// 3.要发送的数据的字节长度</span></span><br><span class="line">    <span class="comment">// 4.通常设置为0，但可以指定额外的标志来控制发送行为</span></span><br><span class="line">    <span class="comment">// 5.指向包含目的地址（如对方的IP地址和端口）的struct sockaddr结构的指针</span></span><br><span class="line">    <span class="comment">// 6.dest_addr指向的结构的大小</span></span><br><span class="line">    <span class="comment">// 返回值小于0 则报错结束</span></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf, <span class="keyword">sizeof</span>(sbuf),<span class="number">0</span>,(<span class="type">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Send successful!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h6><p>接收方，需要在广播地址处，进行收包操作，需要在程序中对套接字属性进行设置，开启网络广播允许标志</p>
<p><code>rever.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 接收方</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSTRSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">recvbuf</span>;</span>  <span class="comment">// 用于存储接收的信息结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span>   <span class="comment">// 定义一个用于ipv4协议的地址结构体 之后强转为struct sockaddr*，用于bind的第二个参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span>   <span class="comment">// 用于在recvfrom 函数中存储发送方的地址IP信息</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];  <span class="comment">// 存储发送方点分式 IP</span></span><br><span class="line">    laddr.sin_family = AF_INET; <span class="comment">// IPV4协议族</span></span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT));   <span class="comment">// 通信协议头文件指定的 端口号,并且字节序要进行转换，从主机字节序转换为网络字节序</span></span><br><span class="line">    <span class="comment">// 使用 inet_addr()函数将点分十进制的IP地址字符串转换为合适的格式--无符号的整型数</span></span><br><span class="line">    <span class="comment">// 地址可能变化，因此可是选择万能地址0.0.0.0</span></span><br><span class="line">    <span class="comment">// laddr.sin_addr.s_addr = inet_addr(&quot;0.0.0.0&quot;); // IPV4的地址 32位无符号的整型数---但是实际的IP地址是点分式如:192.168.1.1 因此需要进行使用inet_addr函数进行转换</span></span><br><span class="line">    <span class="comment">// 替代上文该句代码</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得socket</span></span><br><span class="line">    <span class="comment">// 1.AF_INET 为ipv4网络协议族</span></span><br><span class="line">    <span class="comment">// 2.SOCK_DGRAM 为报式套接字传输方式，通常用于UDP</span></span><br><span class="line">    <span class="comment">// 3.不确定使用什么协议时，可以直接使用参数 0（即报式套接字的默认协议,IPPROTO_UDP）</span></span><br><span class="line">    <span class="comment">// 4.返回一个套接字描述符</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  设置Socket属性,启用广播标志，用于在广播地址收包</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_BROADCAST,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字与特定的IP地址和端口号绑定</span></span><br><span class="line">    <span class="comment">// 1.函数调用返回的套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 2.是指向struct sockaddr结构的指针，该结构包含了要绑定的IP地址和端口号，参数2，可以使用(struct sockaddr *)进行转换但是(void *)是万能的</span></span><br><span class="line">    <span class="comment">// 3.指定了addr结构的大小</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="type">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*！！！*/</span></span><br><span class="line">    <span class="comment">/*特别重要需要对socklen_t raddr_len进行初始化，否则第一次通信时，会出错*/</span></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从Socket上接收信息 -- UDP使用 recvfrom</span></span><br><span class="line">        <span class="comment">// 1.socket函数返回的套接字描述符</span></span><br><span class="line">        <span class="comment">// 2.接收的信息存储的结构体，在通信协议中有定义</span></span><br><span class="line">        <span class="comment">// 3.无特殊要求就填写0</span></span><br><span class="line">        <span class="comment">// 4.用于存储发送方的地址IP信息结构体，根据具体协议定义（如:IPV4或者IPV6），最后需要进行强转为(struct sockaddr *)类型</span></span><br><span class="line">        <span class="comment">// 5. 参数4存储发送方地址的结构体大小,类型为 socklen_t</span></span><br><span class="line">        recvfrom(sd,&amp;recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="comment">// 打印发送方的地址与端口,端口号需要从网络字节序转换为主机字节序</span></span><br><span class="line">        <span class="comment">// 地址需要从32号无符号整数转换为 点分式 192.168.0.0类型 使用函数 inet_ntop函数转换为点分式并且存储至 ipstr中</span></span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---MESSAGE FROM %s:%d---\n&quot;</span>,ipstr, ntohs(raddr.sin_port));</span><br><span class="line">        <span class="comment">// 打印接收的结构体中的信息 name 是char 类型的为单字节 不需要转换字节序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name:%s\n&quot;</span>,recvbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;chinese:%d\n&quot;</span>,ntohl(recvbuf.chinese));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;math:%d\n&quot;</span>,ntohl(recvbuf.math));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h6><p>终端对源码进行编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make rever</span><br><span class="line">$ make snder</span><br></pre></td></tr></table></figure>

<p>打开一个终端，运行接收方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./rever</span><br></pre></td></tr></table></figure>

<p>打开一个终端，运行发送方</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./snder</span><br></pre></td></tr></table></figure>

<p>接收方接收的消息，如图所是，发送方IP为<code>198.168.1.106</code>,</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401182257355.png" alt="image-20240118225728309"></p>
<p>终端使用命令<code>ip ro sh</code>,可以知道,本机ip为 <code>192.168.1.106</code>是子网<code>192.168.1.0/24</code>通过以太网接口<code>enp5s0可达的</code>（表示本机ip的数据包通过以太网接口<code>eth0</code>发送）</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401182306252.png" alt="image-20240118230648220"></p>
<hr>
<h5 id="（3）抓包软件wireshark使用"><a href="#（3）抓包软件wireshark使用" class="headerlink" title="（3）抓包软件wireshark使用"></a>（3）抓包软件wireshark使用</h5><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install wireshark</span><br></pre></td></tr></table></figure>

<p>运行要需要root用户才可以,<code>sudo</code>之后输入用户密码即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wireshark</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401191257362.png" alt="image-20240119125714305"></p>
<h6 id="wireshark使用实例"><a href="#wireshark使用实例" class="headerlink" title="wireshark使用实例"></a>wireshark使用实例</h6><p>运行终端指令：<code>ip ro sh</code>,可以发现，本机ip<code>192.168.1.106</code>的数据包是从网关<code>enp5s0</code>发出的。</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401191314650.png" alt="image-20240119131423617"></p>
<p>运行<code>./rever</code>可执行文件，与<code>./snder</code>可执行文件</p>
<p><code>./rever</code>方接收的信息为如下：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401191318121.png" alt="image-20240119131826082"></p>
<p>信息从ip为<code>192.168.1.106</code>端口为<code>57864</code>发出，因此使用抓包软件，需要对<code>enp5s0</code>网卡的数据进行监测</p>
<p>打开<code>wireshark</code>软件，对网关<code>enp5s0</code>进行选择</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401191320269.png" alt="image-20240119132056222"></p>
<p>打开状态栏中的<code>分析</code>中的<code>显示过滤器表达式</code>，如下：</p>
<p>在过滤器表达式的左边<code>字段名称</code>中选择，<code>IPV4 Internet Protocol Version 4</code>下的<code>ip.dst Destination Host</code></p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401191325395.png" alt="image-20240119132552338"></p>
<p>在关系栏中选择，<code>==</code>关系，值中填写<code>255.255.255.255</code>。表示的含义是<code>snder</code>方发出的信息的目的ip是广播地址<code>255.255.255.255</code></p>
<p>可以捕获的信息如下：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401191329556.png" alt="image-20240119132903513"></p>
<hr>
<h5 id="（4）多播-组播"><a href="#（4）多播-组播" class="headerlink" title="（4）多播\组播"></a>（4）多播\组播</h5><p>多播（Multicast）和组播是网络通信中的概念，用于描述在一个网络中从一个或多个源向多个目的地高效传送信息的过程。</p>
<p><strong>多播</strong>：</p>
<ul>
<li><strong>定义</strong>：多播是一种网络传输机制，它允许<strong>单个数据源同时向多个接收者发送数据（而广播是所有可能的目标是有区别的）</strong>。这与单播（一个源到一个目标）和广播（一个源到所有可能的目标）相对。</li>
<li><strong>用途</strong>：多播主要用于节省带宽和提高效率，因为数据包只发送一次，但可以被网络中的多个接收者同时接收。这在流媒体、视频会议、实时应用程序等场景中非常有用。</li>
<li><strong>如何工作</strong>：在多播中，数据包被发送到一个特定的多播组地址。网络设备（如路由器）识别这个地址，并将数据包路由到订阅了该多播组的所有接收者。</li>
</ul>
<p><strong>组播</strong></p>
<ul>
<li><strong>定义</strong>：组播通常是指在特定的网络协议（如 IP 组播）中实现的多播。</li>
<li><strong>IP 组播</strong>：在 IP 网络中，组播使用特定的地址范围（例如，IPv4 中的 224.0.0.0 到 239.255.255.255）。组播地址代表一个组，数据发送到这个地址将被分发给加入该组的所有成员。</li>
</ul>
<h6 id="224-224-224-224"><a href="#224-224-224-224" class="headerlink" title="224.224.224.224"></a>224.224.224.224</h6><p><code>224.224.224.224</code> 是一个 IP 地址，属于 IP 组播（IP Multicast）地址范围。IP 组播是一种网络通信机制，用于有效地将数据包从一个源发送到多个目的地。</p>
<p><strong>IP 组播地址范围</strong></p>
<ul>
<li>IP 组播地址被定义在特定的范围内。对于 IPv4，这个范围是 <code>224.0.0.0</code> 到 <code>239.255.255.255</code>。</li>
<li>这个范围内的地址用于表示网络中的一个组播组，而不是特定的单个主机。</li>
</ul>
<p><strong><code>224.224.224.224</code> 的特殊用途</strong></p>
<ul>
<li>在实际中，<code>224.224.224.224</code> 这样的地址通常用于组播通信，比如视频流、多点会议系统，或者其他需要同时发送数据到多个接收者的应用。</li>
<li>不过，这个特定的地址并没有被分配给任何 “众所周知的” 组播服务（像其他一些较低的组播地址那样）。这意味着它可能被用于特定应用程序或网络的自定义用途。</li>
</ul>
<hr>
<h5 id="（5）多播-组播实例程序"><a href="#（5）多播-组播实例程序" class="headerlink" title="（5）多播\组播实例程序"></a>（5）多播\组播实例程序</h5><p><strong>流程</strong>:发送方，应该创建多播组，并且发送消息，而接收方则是加入发送方创建的的多播组，并且接收消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">/* IP multicast group</span></span><br><span class="line"><span class="comment">                                                address */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_address</span>;</span>   <span class="comment">/* IP address of local</span></span><br><span class="line"><span class="comment">                                                interface */</span></span><br><span class="line">               <span class="type">int</span>            imr_ifindex;   <span class="comment">/* interface index */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>



<h6 id="通信协议-2"><a href="#通信协议-2" class="headerlink" title="通信协议"></a>通信协议</h6><p>在通信协议中定义，多播组号</p>
<p><code>proto.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by zxz on 2024/1/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BASIC_PROTO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_PROTO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MTROUP <span class="string">&quot;224.2.2.2&quot;</span>  <span class="comment">// 多播组号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCVPORT <span class="string">&quot;1989&quot;</span>   <span class="comment">// 做实验尽量使用1024以上的端口，因为这些端口一般都是预留下来的</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 11</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="type">uint32_t</span> math;</span><br><span class="line">    <span class="type">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"><span class="comment">// __attribute__((packed)) 告知编译器 结构体不进行地址对齐</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//BASIC_PROTO_H</span></span></span><br></pre></td></tr></table></figure>



<h6 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h6><p><code>snder.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 发送方</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span> <span class="comment">// 待发送的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span> <span class="comment">// 发送目标的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得套接字 IPV4协议族 UDP套接字</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;scoket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Socket属性---创建多播组</span></span><br><span class="line">    <span class="comment">// 1.套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 2.选项所在的协议层，实例程序需要在IP层面进行操作，即IPPROTO_IP</span></span><br><span class="line">    <span class="comment">// 3.想要设置的选项，如允许发送多播信息,创建多播组:IP_MULTICAST_IF</span></span><br><span class="line">    <span class="comment">// 4.optval指向包含新选项值的缓冲区的指针</span></span><br><span class="line">    <span class="comment">// 4.参数4（根据参数3，设置的选项填写参数4，根据参数3：IP_MULTICAST_IF，需要的参数4为 结构体 ip_mreqn 或者ip_mreq,与IP_ADD_MEMBERSHIP）</span></span><br><span class="line">    <span class="comment">// 5.optval缓冲区的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">mreq</span>;</span></span><br><span class="line">    inet_pton(AF_INET,MTROUP,&amp;mreq.imr_multiaddr); <span class="comment">// 将多播组地址转换为  转换为 mreq.imr_multiaddr需要的unint_32</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;mreq.imr_address); <span class="comment">// 多播组的网络接口的 IP 地址 万能地址0.0.0.0</span></span><br><span class="line">    mreq.imr_ifindex = if_nametoindex(<span class="string">&quot;enp5s0&quot;</span>);  <span class="comment">// 网络接口（网卡）索引号,可以通过终端命令 ip ad sh 进行查看</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,IPPROTO_IP,IP_MULTICAST_IF,&amp;(mreq),<span class="keyword">sizeof</span>(mreq)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将socket与地址绑定可以省略 因为UDP通信不需要进行连接，地址ip（本机ip）与端口(系统会分配一个空闲的给程序)</span></span><br><span class="line">    <span class="comment">// bind()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义需要发送的数据</span></span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">&quot;ZXZ&quot;</span>);  <span class="comment">// char为单字节 无需进行字节序转换</span></span><br><span class="line">    <span class="comment">// 下面数据需要进行 从主机字节序向网络字节序的转换</span></span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化发送 目标（远端的）的地址---组播地址为 224.2.2.2</span></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,MTROUP,&amp;raddr.sin_addr); <span class="comment">//地址用户写的是点分式 而程序需要的使用unint32_t的整型数，需要进行转换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信息至socket UDP使用 sendto函数</span></span><br><span class="line">    <span class="comment">// 1.socket函数套接字描述符</span></span><br><span class="line">    <span class="comment">// 2.指向包含要发送数据的缓冲区的指针</span></span><br><span class="line">    <span class="comment">// 3.要发送的数据的字节长度</span></span><br><span class="line">    <span class="comment">// 4.通常设置为0，但可以指定额外的标志来控制发送行为</span></span><br><span class="line">    <span class="comment">// 5.指向包含目的地址（如对方的IP地址和端口）的struct sockaddr结构的指针</span></span><br><span class="line">    <span class="comment">// 6.dest_addr指向的结构的大小</span></span><br><span class="line">    <span class="comment">// 返回值小于0 则报错结束</span></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf, <span class="keyword">sizeof</span>(sbuf),<span class="number">0</span>,(<span class="type">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Send successful!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h6><p><code>rever.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 接收方</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSTRSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">recvbuf</span>;</span>  <span class="comment">// 用于存储接收的信息结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span>   <span class="comment">// 定义一个用于ipv4协议的地址结构体 之后强转为struct sockaddr*，用于bind的第二个参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span>   <span class="comment">// 用于在recvfrom 函数中存储发送方的地址IP信息</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];  <span class="comment">// 存储发送方点分式 IP</span></span><br><span class="line">    laddr.sin_family = AF_INET; <span class="comment">// IPV4协议族</span></span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT));   <span class="comment">// 通信协议头文件指定的 端口号,并且字节序要进行转换，从主机字节序转换为网络字节序</span></span><br><span class="line">    <span class="comment">// 使用 inet_addr()函数将点分十进制的IP地址字符串转换为合适的格式--无符号的整型数</span></span><br><span class="line">    <span class="comment">// 地址可能变化，因此可是选择万能地址0.0.0.0</span></span><br><span class="line">    <span class="comment">// laddr.sin_addr.s_addr = inet_addr(&quot;0.0.0.0&quot;); // IPV4的地址 32位无符号的整型数---但是实际的IP地址是点分式如:192.168.1.1 因此需要进行使用inet_addr函数进行转换</span></span><br><span class="line">    <span class="comment">// 替代上文该句代码</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得socket</span></span><br><span class="line">    <span class="comment">// 1.AF_INET 为ipv4网络协议族</span></span><br><span class="line">    <span class="comment">// 2.SOCK_DGRAM 为报式套接字传输方式，通常用于UDP</span></span><br><span class="line">    <span class="comment">// 3.不确定使用什么协议时，可以直接使用参数 0（即报式套接字的默认协议,IPPROTO_UDP）</span></span><br><span class="line">    <span class="comment">// 4.返回一个套接字描述符</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  设置Socket属性,加入多播组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">mreq</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET,MTROUP,&amp;mreq.imr_multiaddr);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;mreq.imr_address); <span class="comment">// 网络接口ip，0.0.0.0使用默认的网路接口ip</span></span><br><span class="line">    mreq.imr_ifindex = if_nametoindex(<span class="string">&quot;enps50&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&amp;mreq,<span class="keyword">sizeof</span>(mreq)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字与特定的IP地址和端口号绑定</span></span><br><span class="line">    <span class="comment">// 1.函数调用返回的套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 2.是指向struct sockaddr结构的指针，该结构包含了要绑定的IP地址和端口号，参数2，可以使用(struct sockaddr *)进行转换但是(void *)是万能的</span></span><br><span class="line">    <span class="comment">// 3.指定了addr结构的大小</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="type">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*！！！*/</span></span><br><span class="line">    <span class="comment">/*特别重要需要对socklen_t raddr_len进行初始化，否则第一次通信时，会出错*/</span></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从Socket上接收信息 -- UDP使用 recvfrom</span></span><br><span class="line">        <span class="comment">// 1.socket函数返回的套接字描述符</span></span><br><span class="line">        <span class="comment">// 2.接收的信息存储的结构体，在通信协议中有定义</span></span><br><span class="line">        <span class="comment">// 3.无特殊要求就填写0</span></span><br><span class="line">        <span class="comment">// 4.用于存储发送方的地址IP信息结构体，根据具体协议定义（如:IPV4或者IPV6），最后需要进行强转为(struct sockaddr *)类型</span></span><br><span class="line">        <span class="comment">// 5. 参数4存储发送方地址的结构体大小,类型为 socklen_t</span></span><br><span class="line">        recvfrom(sd,&amp;recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="comment">// 打印发送方的地址与端口,端口号需要从网络字节序转换为主机字节序</span></span><br><span class="line">        <span class="comment">// 地址需要从32号无符号整数转换为 点分式 192.168.0.0类型 使用函数 inet_ntop函数转换为点分式并且存储至 ipstr中</span></span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---MESSAGE FROM %s:%d---\n&quot;</span>,ipstr, ntohs(raddr.sin_port));</span><br><span class="line">        <span class="comment">// 打印接收的结构体中的信息 name 是char 类型的为单字节 不需要转换字节序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name:%s\n&quot;</span>,recvbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;chinese:%d\n&quot;</span>,ntohl(recvbuf.chinese));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;math:%d\n&quot;</span>,ntohl(recvbuf.math));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="编译运行-1"><a href="#编译运行-1" class="headerlink" title="编译运行"></a>编译运行</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make snder rever</span><br></pre></td></tr></table></figure>

<p>分别打开终端运行接收方与发送方</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401191535465.png" alt="image-20240119153503430"></p>
<hr>
<hr>
<h4 id="5-流式套接字-TCP"><a href="#5-流式套接字-TCP" class="headerlink" title="5.流式套接字(TCP)"></a>5.流式套接字(TCP)</h4><p><strong>收发双方的步骤</strong>：</p>
<ul>
<li><p>被动端（S端先收包的一方，先运行）：</p>
<p>取得SOCKET</p>
<p>给SOCKET取得地址</p>
<p>将SOCKET设置为监听模式</p>
<p>接受连接</p>
<p>收&#x2F;发消息</p>
<p>关闭SOCKET</p>
</li>
<li><p>主动端（C端）：</p>
<p>取得SOCKET</p>
<p>给SOCKET取得地址（可省略）</p>
<p>发送连接</p>
<p>发&#x2F;收消息</p>
<p>关闭SOCKET</p>
</li>
</ul>
<h5 id="（1）流式套接字程序实例"><a href="#（1）流式套接字程序实例" class="headerlink" title="（1）流式套接字程序实例"></a>（1）流式套接字程序实例</h5><h6 id="通信协议-3"><a href="#通信协议-3" class="headerlink" title="通信协议"></a>通信协议</h6><p>通信协议中需要确定发送端运行时候占用机器的端口号，以及服务端与客户端通信连接后，返回给客户端的信息格式<code>FMT_STAMP</code>。</p>
<p><code>proto.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 通信协议</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BASIC_PROTO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASIC_PROTO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERPORT <span class="string">&quot;1989&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMT_STAMP <span class="string">&quot;%lld\r\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//BASIC_PROTO_H</span></span></span><br></pre></td></tr></table></figure>



<h6 id="接收方（Server第一版）"><a href="#接收方（Server第一版）" class="headerlink" title="接收方（Server第一版）"></a>接收方（Server第一版）</h6><p><code>Server.c</code></p>
<p><strong>第一版</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器接收连接后 需要告知客户端</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_job</span><span class="params">(<span class="type">int</span> sd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 获取当前时间戳返回</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="comment">// 参数2：格式化字符串输出</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf,FMT_STAMP,(<span class="type">long</span> <span class="type">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 收发信息</span></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;send()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="type">int</span> new_sd;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span> <span class="comment">// 本地地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span> <span class="comment">// 远端地址</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得Socket</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);</span><br><span class="line">    <span class="comment">// 为socket绑定好本端的ip与本端的端口号</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="type">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Socket 设置为监听模式</span></span><br><span class="line">    <span class="comment">// 参数2：队列中最多可以容纳的的等待接收的连接请求数量</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sd,<span class="number">200</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="comment">// 参数2：用于接收一个返回值，表示连接到服务器的客户端的地址</span></span><br><span class="line">        new_sd = accept(sd,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(new_sd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出对端的ip与端口</span></span><br><span class="line">        <span class="comment">// ip地址被转换为点分式则是字符型 单字节 不需要进行字节序的转换</span></span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client:%s:%d\n&quot;</span>,ipstr, ntohs(raddr.sin_port));</span><br><span class="line"></span><br><span class="line">        server_job(new_sd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        close(new_sd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行<code>server.c</code></p>
<p>打开一个终端运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./server</span><br></pre></td></tr></table></figure>

<p>打开另外一个终端，使用指令<code>nc</code> ，是ubuntu自带的客户端，指定服务器ip 与 端口号即可以与服务器进行通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 0.0.0.0 1989</span><br></pre></td></tr></table></figure>

<p>客户端端接收的信息如下，接收到服务端返回的时间戳</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401201635427.png" alt="image-20240120163541389"></p>
<p>运行服务端的终端，输出与其连接的客户端的ip与端口号</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401201636973.png" alt="image-20240120163630925"></p>
<p>使用<code>Crtl+C</code>，将服务端程序终止，再次运行会出现如下情况：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401201638476.png" alt="image-20240120163815424"></p>
<p>显示服务端<code>bind</code>失败，需要使用的ip与端口已经为占用，这是因为，使用<code>Ctrl+C</code>终端程序运行，是使用信号中断进程的运行，在服务端程序中，并没有执行到<code>close(sd)</code>,关闭套接字描述符的代码，因此在一小段时间内，该套接字还是会显示打开的状态，则ip与端口就会依然被占用。一段时间过后，系统发现后，则会主动进行资源的释放与回收。</p>
<p>如何改进呢？如下：</p>
<h6 id="接收方（Server第二版）"><a href="#接收方（Server第二版）" class="headerlink" title="接收方（Server第二版）"></a>接收方（Server第二版）</h6><p>设置套接字的属性，如套接字在上一次使用中没有来的及释放，那么在下一次重新使用bind绑定因为没有来得及释放而被占用的ip与端口时，则会立马释放，以此来使得此次<code>bind</code>成功</p>
<p><strong>SO_REUSEADDR</strong></p>
<ul>
<li><code>SO_REUSEADDR</code> 是一个套接字选项，用于在套接字编程中控制地址重用的行为。这个选项使得在同一端口上可以快速重启一个监听服务，而不必等待操作系统关闭前一个服务的套接字</li>
</ul>
<p>在程序中添加代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置套接字属性</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>server.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 接收接收端</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器接收连接后 需要告知客户端</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_job</span><span class="params">(<span class="type">int</span> sd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 获取当前时间戳返回</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="comment">// 参数2：格式化字符串输出</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf,FMT_STAMP,(<span class="type">long</span> <span class="type">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 收发信息</span></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;send()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="type">int</span> new_sd;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span> <span class="comment">// 本地地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span> <span class="comment">// 远端地址</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得Socket</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字属性</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);</span><br><span class="line">    <span class="comment">// 为socket绑定好本端的ip与本端的端口号</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="type">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Socket 设置为监听模式</span></span><br><span class="line">    <span class="comment">// 参数2：队列中最多可以容纳的的等待接收的连接请求数量</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sd,<span class="number">200</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="comment">// 参数2：用于接收一个返回值，表示连接到服务器的客户端的地址</span></span><br><span class="line">        new_sd = accept(sd,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(new_sd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出对端的ip与端口</span></span><br><span class="line">        <span class="comment">// ip地址被转换为点分式则是字符型 单字节 不需要进行字节序的转换</span></span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client:%s:%d\n&quot;</span>,ipstr, ntohs(raddr.sin_port));</span><br><span class="line"></span><br><span class="line">        server_job(new_sd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        close(new_sd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行<code>server.c</code></p>
<p>打开一个终端运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./server</span><br></pre></td></tr></table></figure>

<p>打开另外一个终端，使用指令<code>nc</code> ，是ubuntu自带的客户端，指定服务器ip 与 端口号即可以与服务器进行通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 0.0.0.0 1989</span><br></pre></td></tr></table></figure>

<p>客户端端接收的信息如下，接收到服务端返回的时间戳</p>
<p>运行服务端的终端，输出与其连接的客户端的ip与端口号</p>
<p>使用<code>Crtl+C</code>，将服务端程序终止，再次运行会出现如下情况：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401201700674.png" alt="image-20240120170023633"></p>
<p>没有出现如第一版，bind失败的情形。</p>
<h6 id="发送端1"><a href="#发送端1" class="headerlink" title="发送端1"></a>发送端1</h6><p><code>Client.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 发送方</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span> <span class="comment">// 远端地址</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stamp;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得socket</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 套接字绑定ip与端口---主动端可以省略</span></span><br><span class="line">    <span class="comment">// bind();</span></span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,argv[<span class="number">1</span>],&amp;raddr.sin_addr);</span><br><span class="line">    <span class="comment">// 发送连接</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sd,(<span class="type">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;&#x27;connect()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收信息</span></span><br><span class="line">    <span class="comment">// recv();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当此前建立连接成功之后，可以获得一个用于通信的套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 可以不使用recv函数接收信息，换个思路，将套接字文件描述符，转换为文件流的使用</span></span><br><span class="line">    <span class="comment">// fdopen用于将现有文件描述符（file descriptor）转换为一个 FILE* 指针</span></span><br><span class="line">    fp = fdopen(sd,<span class="string">&quot;r+w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fdopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从文件流中读取，服务端发送回来的信息,读取的信息存储至 stamp中</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fscanf</span>(fp,FMT_STAMP,&amp;stamp) &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Bad format!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将取得信息输出至标准输出</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;stamp == %lld\n&quot;</span>,stamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="发送端2"><a href="#发送端2" class="headerlink" title="发送端2"></a>发送端2</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stamp;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> BUF[BUFSIZE];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取socket</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,argv[<span class="number">1</span>],&amp;raddr.sin_addr);</span><br><span class="line">    <span class="comment">// 发送连接</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sd,(<span class="type">void</span> *)&amp;raddr,<span class="keyword">sizeof</span> raddr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受服务端回传的数据</span></span><br><span class="line">    <span class="keyword">if</span>(recv(sd,BUF,<span class="keyword">sizeof</span> BUF,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符数组中的数据转化为长整型</span></span><br><span class="line">    stamp = strtoll(BUF,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;stamp = %lld\n&quot;</span>,stamp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make Client</span><br></pre></td></tr></table></figure>

<p>先打开一个终端，运行服务端程序，等待客户端发送连接请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./server</span><br></pre></td></tr></table></figure>

<p>再打开另外一个终端，运行客户端程序，发送连接请求，并且若连接成功则打印，服务端回传的信息</p>
<p>客户端显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401202250841.png" alt="image-20240120225041799"></p>
<p>服务端显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401202250654.png" alt="image-20240120225059610"></p>
<h6 id="接收方（Server第三版并发版）"><a href="#接收方（Server第三版并发版）" class="headerlink" title="接收方（Server第三版并发版）"></a>接收方（Server第三版并发版）</h6><p>为了提高服务端的执行效率，服务端将接收连接以其之前的工作由父进程执行操作，而<code>server_job</code>等操作交由子进程进行操作</p>
<p><code>server.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器接收连接后 需要告知客户端</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_job</span><span class="params">(<span class="type">int</span> sd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 获取当前时间戳返回</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="comment">// 参数2：格式化字符串输出</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf,FMT_STAMP,(<span class="type">long</span> <span class="type">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 收发信息</span></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;send()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="type">int</span> new_sd;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span> <span class="comment">// 本地地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span> <span class="comment">// 远端地址</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得Socket</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字属性</span></span><br><span class="line">    <span class="comment">// 尽快的释放绑定的ip与端口</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);</span><br><span class="line">    <span class="comment">// 为socket绑定好本端的ip与本端的端口号</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="type">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Socket 设置为监听模式</span></span><br><span class="line">    <span class="comment">// 参数2：队列中最多可以容纳的的等待接收的连接请求数量</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sd,<span class="number">200</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="comment">// 参数2：用于接收一个返回值，表示连接到服务器的客户端的地址</span></span><br><span class="line">        new_sd = accept(sd,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(new_sd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子进程</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程的操作</span></span><br><span class="line">        <span class="comment">// 容易出现的bug:创建子进程后，会将父进程的资源复制一份，因此子进程会将new_sd与sd都进行拷贝</span></span><br><span class="line">        <span class="comment">// 但是每次使用完应该将不需要使用的套接字描述符进行关闭</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将子进程中的sd进行关闭，不需要在进行使用</span></span><br><span class="line">            close(sd);</span><br><span class="line">            <span class="comment">// 输出对端的ip与端口</span></span><br><span class="line">            <span class="comment">// ip地址被转换为点分式则是字符型 单字节 不需要进行字节序的转换</span></span><br><span class="line">            inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d]:Client:%s:%d\n&quot;</span>,getpid(),ipstr, ntohs(raddr.sin_port));</span><br><span class="line"></span><br><span class="line">            server_job(new_sd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭</span></span><br><span class="line">            close(new_sd);</span><br><span class="line">            <span class="comment">// 正常关闭子进程</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 父进程还需要进行的操作，将new_sd进行关闭</span></span><br><span class="line">        	close(new_sd);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make server</span><br></pre></td></tr></table></figure>

<p>分别打开终端运行<code>server</code>与<code>Client</code></p>
<p>发送方显示：</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401211114031.png" alt="image-20240121111401992"></p>
<p>接收方显示;</p>
<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401211114961.png" alt="image-20240121111416922"></p>
<hr>
<h5 id="（2）静态进程池套接字实现"><a href="#（2）静态进程池套接字实现" class="headerlink" title="（2）静态进程池套接字实现"></a>（2）静态进程池套接字实现</h5><p>在之前的流式套接字实例中，若在服务端，加入进程池的机制，当父进程建立连接之后，进程池中的子进程开始对任务进行竞争，那情况如何呢？</p>
<p><code>accept</code> 调用通常是线程安全的，并且操作系统内核会负责处理多个并发的 <code>accept</code> 调用。这意味着多个线程可以安全地在同一个监听套接字上调用 <code>accept</code> 而不会相互干扰，因此accept函数不需要额外增加信号量或者进程锁相关</p>
<h6 id="接收方（Server第四版静态进程池版本）"><a href="#接收方（Server第四版静态进程池版本）" class="headerlink" title="接收方（Server第四版静态进程池版本）"></a>接收方（Server第四版静态进程池版本）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_loop</span><span class="params">(<span class="type">int</span> sd)</span>;</span><br><span class="line"><span class="comment">// 服务器接收连接后 需要告知客户端</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_job</span><span class="params">(<span class="type">int</span> sd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 获取当前时间戳返回</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="comment">// 参数2：格式化字符串输出</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf,FMT_STAMP,(<span class="type">long</span> <span class="type">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 收发信息</span></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;send()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd,i;</span><br><span class="line">    <span class="type">int</span> new_sd;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span> <span class="comment">// 本地地址</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得Socket</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字属性</span></span><br><span class="line">    <span class="comment">// 尽快的释放绑定的ip与端口</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);</span><br><span class="line">    <span class="comment">// 为socket绑定好本端的ip与本端的端口号</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="type">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Socket 设置为监听模式</span></span><br><span class="line">    <span class="comment">// 参数2：队列中最多可以容纳的的等待接收的连接请求数量</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sd,<span class="number">200</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;PROCNUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            server_loop(sd);</span><br><span class="line">            <span class="comment">// 关闭子进程的sd</span></span><br><span class="line">            <span class="comment">// 这些代码执行不到，因为在server_loop 函数中存在while循环，而子进程不会跳出while循环</span></span><br><span class="line">            close(sd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程资源回收---代码也执行不到</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;PROCNUM;i++)</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_loop</span><span class="params">(<span class="type">int</span> sd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> new_sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span> <span class="comment">// 远端地址</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="comment">// 参数2：用于接收一个返回值，表示连接到服务器的客户端的地址</span></span><br><span class="line">        new_sd = accept(sd,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(new_sd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出对端的ip与端口</span></span><br><span class="line">        <span class="comment">// ip地址被转换为点分式则是字符型 单字节 不需要进行字节序的转换</span></span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]--Client:%s:%d\n&quot;</span>,getpid(),ipstr, ntohs(raddr.sin_port));</span><br><span class="line"></span><br><span class="line">        server_job(new_sd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        close(new_sd);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行还是正常的</p>
<hr>
<h5 id="（3）套接字动态进程池实现"><a href="#（3）套接字动态进程池实现" class="headerlink" title="（3）套接字动态进程池实现"></a>（3）套接字动态进程池实现</h5><p>进程池中，父进程需要统筹管理进程池中的资源，当存在有子进程状态发生变化时，就要对进程池中的资源进行扫描，发现存在资源被空闲占用时，就需要将空闲的子进程杀死，释放其占用的资源。当发现存在此时进程池中子进程数量少于最小值时，需要创建子进程满足数量最小值，并执行任务</p>
<p><strong>主进程每次间隔3s，就会扫描进程池，更新当前忙碌的子进程数量与空闲的子进程数量，当当前空闲的数量小于MINSPARESERVER，则会继续创建子进程使得存在子进程调用accept函数，等待客户端的连接。而不是每次发现有客户端发送连接请求了之后在去创建子进程。而且一开始就创建好空闲的子进程使用accept阻塞等待客户端连接请求</strong></p>
<p>进程池还有一个思路：专门创建一个子进程用于accept函数阻塞等待客户端请求，当服务端连接上客户端，则创建其他子进程用于与客户端通信收发数据。</p>
<p><code>server.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSPARESERVER 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSPARESERVER 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCLIENTS 20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINEBUFSIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_NOTIFY SIGUSR2  <span class="comment">// SIGUSR2 是一个用户定义的信号</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    STATE_IDEL = <span class="number">0</span>, <span class="comment">// 空闲态</span></span><br><span class="line">    STATE_BUSY      <span class="comment">// 忙碌态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">server_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">server_st</span> *<span class="title">serverpool</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> idle_count=<span class="number">0</span>,busy_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数不执行任何操作</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usr2_handler</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程工作函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_job</span><span class="params">(<span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span>  <span class="comment">// 远端地址</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="type">int</span> ppid;</span><br><span class="line">    <span class="type">int</span> client_sd;</span><br><span class="line">    <span class="type">time_t</span> stamp;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">    <span class="type">char</span> linebuf[LINEBUFSIZE];</span><br><span class="line">    ppid = getppid();  <span class="comment">// 获得当前进程的父进程ID</span></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span> raddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 服务端子进程接受连接---返回一个可以用于与客户端通信的套接字文件描述符</span></span><br><span class="line">        client_sd = accept(sd,(<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(client_sd &lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// accept是系统调用</span></span><br><span class="line">            <span class="comment">// 若不是假错，是真错误情况</span></span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR || errno != EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程将进行工作，将其状态设置为忙碌态</span></span><br><span class="line">        serverpool[pos].state = STATE_BUSY;</span><br><span class="line">        <span class="comment">// 在子进程的工作函数中，子进程的状态发生了改变，因此需要通知主进程对进程池进行扫描与控制</span></span><br><span class="line">        kill(ppid,SIG_NOTIFY);</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="comment">// 输出与服务端子进程连接的远端地址信息</span></span><br><span class="line">        <span class="comment">// printf(&quot;[%d]client:%s:%d\n&quot;,getpid(),ipstr, ntohs(raddr.sin_port));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得当前时刻的时间戳</span></span><br><span class="line">        stamp = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 将获得的时间戳放到linebuf中</span></span><br><span class="line">        len = <span class="built_in">snprintf</span>(linebuf,LINEBUFSIZE,FMT_STAMP,stamp);</span><br><span class="line">        <span class="comment">// 向客户端回传数据，告知接受连接</span></span><br><span class="line">        send(client_sd,linebuf,len,<span class="number">0</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        close(client_sd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 服务端子进程工作结束，将其状态变为空闲态</span></span><br><span class="line">        serverPool[pos].state =  STATE_IDLE;</span><br><span class="line">        <span class="comment">// 为什么: 在子进程的工作函数中，子进程的状态发生了改变，因此需要通知主进程对进程池进行扫描与控制</span></span><br><span class="line">        <span class="comment">// 将SIG_NOTIFY信号传递给父进程</span></span><br><span class="line">        <span class="comment">// 这时候父进程在while循环使用sigsuspend(&amp;oset)函数解除了信号SIG_NOTIFY的阻塞</span></span><br><span class="line">        <span class="comment">// 父进程会调用usr2_handler在主进程的while循环中return一次，然后重新执行while循环</span></span><br><span class="line">        <span class="comment">// 重新在while循环中，主进程对进程池进行扫描与控制</span></span><br><span class="line">        kill(ppid,SIG_NOTIFY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加一个服务端子进程</span></span><br><span class="line"><span class="comment"> * 当前只是创建一个服务端的子进程但是并没有实际使用创建的子进程进行工作</span></span><br><span class="line"><span class="comment"> * 因此其状态为STATE_IDLE空闲态</span></span><br><span class="line"><span class="comment"> * 在子进程中调用server_job函数才会正式开始工作，子进程状态才会变为忙碌状态</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add_1_server</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> slot;</span><br><span class="line">    <span class="keyword">if</span>(idle_count + busy_count &gt;= MAXCLIENTS)</span><br><span class="line">        <span class="comment">// 出错情况--进程池满无法继续增加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(slot = <span class="number">0</span>;slot&lt;MAXCLIENTS;slot++)</span><br><span class="line">        <span class="keyword">if</span>(serverpool[slot].pid == <span class="number">-1</span>)</span><br><span class="line">            <span class="comment">// 当前slot位置的进程号是空闲的</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 将当前创建的子进程状态先设置为空闲态</span></span><br><span class="line">    serverpool[slot].state = STATE_IDEL;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)  <span class="comment">// 子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程工作</span></span><br><span class="line">        server_job(slot);</span><br><span class="line">        <span class="comment">// 子进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>          <span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        serverpool[slot].pid = pid;</span><br><span class="line">        idle_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除一个服务端子进程*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">del_1_server</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(idle_count==<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 当前空闲状态的进程数量为0，则不用删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXCLIENTS;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若当前进程池位置被占用，但是该进程为空闲态则删除</span></span><br><span class="line">        <span class="keyword">if</span>(serverpool[i].pid != <span class="number">-1</span> &amp;&amp; serverpool[i].state == STATE_IDEL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// kill函数用于发送信号给进程</span></span><br><span class="line">            <span class="comment">// SIGTERM信号 用于请求进程正常终止</span></span><br><span class="line">            kill(serverpool[i].pid,SIGTERM);</span><br><span class="line">            serverpool[i].pid=<span class="number">-1</span>;</span><br><span class="line">            idle_count--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*检查进程池*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">scan_pool</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> busy = <span class="number">0</span>,idle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;MAXCLIENTS;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(serverpool[i].pid == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 检测当前进程是否还存在</span></span><br><span class="line">        <span class="comment">// 当 sig 为 0 时，kill() 实际上并不发送任何信号。它只是用于检测指定 pid 的进程或进程组是否存在，以及调用进程是否有权限向其发送信号</span></span><br><span class="line">        <span class="keyword">if</span>(kill(serverpool[i].pid,<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不存在则解除位置i的占用</span></span><br><span class="line">            serverpool[i].pid = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(serverpool[i].state == STATE_IDEL)</span><br><span class="line">        &#123;</span><br><span class="line">            idle++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(serverpool[i].state == STATE_BUSY)&#123;</span><br><span class="line">            busy++;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 输出错误</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Unknown state\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 中断该进程</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    idle_count = idle;</span><br><span class="line">    busy_count = busy;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1.这个部分的处理是的主进程对于SIGCHLD信号的行为为忽视，并且不会考虑子进程终止时的主动收尸*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>,<span class="title">osa</span>;</span>    <span class="comment">// 定义信号的新行为与旧行为的结构体</span></span><br><span class="line">    <span class="comment">// 功能：下面结构体sa初始化的功能是（特定的），当子进程的状态发生改变时，父进程对该信号SIGCHLD进行忽视</span></span><br><span class="line">    <span class="comment">// 功能：并且，创建的子进程，结束时自行消亡，不等待父进程收尸</span></span><br><span class="line">    sa.sa_handler = SIG_IGN;    <span class="comment">// 对于信号SIGCHLD的反映行为是 (SIG_IGN忽视)</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);   <span class="comment">// 处理该信号时额外需要被阻塞的信号集合，但是程序中将当前集合设置为空集</span></span><br><span class="line">    <span class="comment">// SA_NOCLDWAIT 标志的主要作用是在子进程终止时，操作系统不保留子进程的状态信息，也不发送 SIGCHLD 信号给父进程。这种方式适用于那些不关心子进程状态的父进程，或者有其他机制来管理和监控子进程的程序。这样，父进程也就不需要调用 wait() 或 waitpid() 来清理子进程状态。</span></span><br><span class="line">    sa.sa_flags = SA_NOCLDWAIT; <span class="comment">// 其他特殊要求，修改信号的行为标志,SA_NOCLDWAIT阻止子进程变为僵尸状态，免去收尸的困扰</span></span><br><span class="line">    <span class="comment">// 用于修改信号SIGCHLD的行为</span></span><br><span class="line">    <span class="comment">// 其中SIGCHLD信号，是一个由操作系统发送给父进程的信号，用来通知父进程其一个或多个子进程的状态发生了改变</span></span><br><span class="line">    <span class="comment">// SIGCHLD 用于通知父进程其子进程的状态发生变化。可以用来处理子进程的终止、暂停、恢复等状态。</span></span><br><span class="line">    sigaction(SIGCHLD,&amp;sa,&amp;osa);</span><br><span class="line">    <span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2.为用户自定义的信号SIG_NOTIFY修改行为*/</span></span><br><span class="line">    <span class="comment">// struct sigaction sa,osa;</span></span><br><span class="line">    sa.sa_handler = usr2_handler;   <span class="comment">// 对于信号SIG_NOTIFY的反映行为是 usr2_handler一个处理函数</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);       <span class="comment">// 处理该信号是额外需要被阻塞的信号集合，但是程序中将当前集合设置为空集</span></span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;                <span class="comment">// 无其他特殊要求</span></span><br><span class="line">    sigaction(SIG_NOTIFY,&amp;sa,&amp;osa);</span><br><span class="line">    <span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3.将SIG_NOTIFY设置为阻塞信号*/</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>,oset;</span><br><span class="line">    <span class="comment">// 将set集合中的信号清空</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">// 将信号SIG_NOTIFY 添加到set集合中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIG_NOTIFY);</span><br><span class="line">    <span class="comment">// 将set 集合中的信号进行阻塞</span></span><br><span class="line">    <span class="comment">// 执行下面的代码时，SIG_NOTIFY信号会被阻塞，这个信号不会传递到进程</span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">    <span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4.初始化进程池*/</span></span><br><span class="line">    <span class="comment">// 使用匿名内存映射代替malloc为进程池开辟空间</span></span><br><span class="line">    serverpool = mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> server_st)*MAXCLIENTS,PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建失败</span></span><br><span class="line">    <span class="keyword">if</span>(serverpool == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化进程池的信息</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;MAXCLIENTS;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        serverpool[i].pid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5.获得套接字，并且绑定ip与端口，进行客户端连接请求的监听*/</span></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置套接字属性，使得套接字连接意外终止时，可以使得在同一端口上可以快速重启一个监听服务</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为本地ip与端口进行绑定,被动端无法省略</span></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr); <span class="comment">// 点分式 转unint_32整型</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="type">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听模式</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sd,<span class="number">100</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程---先创建最少数量的空闲服务端</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;MINSPARESERVER;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        add_1_server();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This ServerPool Running...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用于暂时替换进程的信号屏蔽字并暂停进程执行</span></span><br><span class="line">        <span class="comment">// 调用sigsuspend使用程序开始时的信号集替换当前进程的信号屏蔽集，这个时候进程是可以接收到SIG_NOTIFY信号(未被屏蔽)的,则这个时候该进程可以受到信号SIG_NOTIFY的影响了</span></span><br><span class="line">        <span class="comment">// 这样会使得进程进行阻塞等待的状态，直到接收到一个未屏蔽的信号。该信号将被传递给进程，并触发相应的信号处理程序或默认行为</span></span><br><span class="line">        <span class="comment">// 在信号处理程序返回或默认行为执行完毕后，sigsuspend() 恢复进程的原始信号屏蔽集，即SIG_NOTIFY信号又变成了进程的阻塞信号</span></span><br><span class="line">        <span class="comment">// 直到while循环下一次再次执行到sigsuspend该函数，往复执行</span></span><br><span class="line">        sigsuspend(&amp;oset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描进程池</span></span><br><span class="line">        scan_pool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// control the pool</span></span><br><span class="line">        <span class="keyword">if</span>(idle_count &gt; MAXSPARESERVER)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若空闲的服务端子进程 多余最大的空闲允许值时，则杀死一部分服务端子进程</span></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;(idle_count-MAXSPARESERVER);i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 杀死一个服务端子进程</span></span><br><span class="line">                del_1_server();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(idle_count &lt; MINSPARESERVER)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若空闲的服务端子进程 少余最小的空闲允许值时，则增加一部分服务端子进程</span></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;(MINSPARESERVER-idle_count);i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加一个服务端子进程</span></span><br><span class="line">                add_1_server();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在终端打印输出进程池状态</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;MAXCLIENTS;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 进程池位置没有被占用，输出 s</span></span><br><span class="line">            <span class="keyword">if</span>(serverpool[i].pid == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">            <span class="comment">// 进程池位置被占用但是其状态为STATE_IDEL则输出 .</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(serverpool[i].state == STATE_IDEL)</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="comment">// 进程池位置被占用但是其状态为STATE_BUSY则输出 x</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终端为行缓冲，在输出缓冲区遇到`\n`会将缓冲区内容输出至终端</span></span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程恢复最初的信号屏蔽字的状态</span></span><br><span class="line">    <span class="comment">// SIG_SETMASK：将当前信号屏蔽字设置为 oset 指定的值</span></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;oset,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(serverPool, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> server_st) * MAXCLIENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主进程退出</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行启动server端</p>
<p>另开一个终端，运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> (./client 127.0.0.1 &amp;);<span class="built_in">sleep</span> 1;<span class="keyword">done</span>   // 每秒运行一次指令 ./client</span><br><span class="line">或者</span><br><span class="line">$ <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> (./client 0.0.0.0 &amp;);<span class="built_in">sleep</span> 1;<span class="keyword">done</span>   // 每秒运行一次指令 ./client</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202401231601767.png" alt="image-20240123160159720"></p>
<p>服务端显示进程池中各个子进程的运行状态</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://maxswordsman.github.io">Maxswordsman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://maxswordsman.github.io/2024/01/31/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%EF%BC%8813%EF%BC%89/">https://maxswordsman.github.io/2024/01/31/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%EF%BC%8813%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://maxswordsman.github.io" target="_blank">Maxswordsman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></div><div class="post_share"><div class="social-share" data-image="/image/head2.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/14/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/IPV4%E6%B5%81%E5%AA%92%E4%BD%93/IPV4%E6%B5%81%E5%AA%92%E4%BD%93%E9%A1%B9%E7%9B%AE-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/" title="IPV4流媒体网络多播-前置知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IPV4流媒体网络多播-前置知识</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/31/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO%EF%BC%8812%EF%BC%89/" title="UNIX环境编程-高级IO（12）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UNIX环境编程-高级IO（12）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/Linux%E5%9F%BA%E7%A1%80/" title="Linux基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-28</div><div class="title">Linux基础</div></div></a></div><div><a href="/2023/08/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%80%9A%E4%BF%A1/" title="IO多路复用-多线程并发通信"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-28</div><div class="title">IO多路复用-多线程并发通信</div></div></a></div><div><a href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-MAKEFILE%EF%BC%884%EF%BC%89/" title="UNIX环境编程-MAKEFILE（4）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">UNIX环境编程-MAKEFILE（4）</div></div></a></div><div><a href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%883%EF%BC%89/" title="UNIX环境编程-动态内存管理（3）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">UNIX环境编程-动态内存管理（3）</div></div></a></div><div><a href="/2023/12/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%EF%BC%8811%EF%BC%89/" title="UNIX环境编程-并发（11）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-25</div><div class="title">UNIX环境编程-并发（11）</div></div></a></div><div><a href="/2023/07/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86%EF%BC%885%EF%BC%89/" title="UNIX环境编程-数据结构部分（5）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-02</div><div class="title">UNIX环境编程-数据结构部分（5）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/head2.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Maxswordsman</div><div class="author-info__description">不颓好胜之心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/maxswordsman"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/maxswordsman" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2723937292@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://gitee.com/zhou-xuezhi" target="_blank" title="Gitee"><i class="iconfont  icon-gitee" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%EF%BC%8813%EF%BC%89"><span class="toc-text">进程通信-套接字编程（13）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%A1%E9%81%93"><span class="toc-text">一、管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-text">1.匿名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89pipe%E5%87%BD%E6%95%B0"><span class="toc-text">（1）pipe函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-text">2.命名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93"><span class="toc-text">（1）命令行创建管道</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">二、消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ftok%E5%87%BD%E6%95%B0"><span class="toc-text">1.ftok函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">2.消息队列的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89msgget%E5%87%BD%E6%95%B0"><span class="toc-text">（1）msgget函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89msgsnd%E4%B8%8Emsgrcv%E5%87%BD%E6%95%B0"><span class="toc-text">（2）msgsnd与msgrcv函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#msgsnd"><span class="toc-text">msgsnd</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#msgrcv"><span class="toc-text">msgrcv</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-msgctl"><span class="toc-text">3.msgctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">4.实例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8D%8F%E8%AE%AE"><span class="toc-text">（1）协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8E%A5%E6%94%B6%E7%AB%AF"><span class="toc-text">（2）接收端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8F%91%E9%80%81%E7%AB%AF"><span class="toc-text">（3）发送端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-text">（4）运行结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-ftp%E5%AE%9E%E4%BE%8B"><span class="toc-text">5.消息队列-ftp实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%94%B6%E5%8F%91%E5%8D%8F%E8%AE%AE"><span class="toc-text">（1）收发协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B"><span class="toc-text">6.消息队列-信号量数组实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3API"><span class="toc-text">（1）信号量集合相关API</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#semget"><span class="toc-text">semget</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#semop"><span class="toc-text">semop</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#semctl"><span class="toc-text">semctl</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AE%9E%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-text">（2）实例程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%A1%B9%E7%9B%AE%E5%AE%9E%E4%BE%8B"><span class="toc-text">7.进程间通信-共享内存项目实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3API"><span class="toc-text">（1）共享内存相关API</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#shmget"><span class="toc-text">shmget</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shmat"><span class="toc-text">shmat</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shmdt"><span class="toc-text">shmdt</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shmctl"><span class="toc-text">shmctl</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AE%9E%E4%BE%8B%E7%A8%8B%E5%BA%8F-1"><span class="toc-text">（2）实例程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">三、套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E4%BC%A0%E8%BE%93%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98"><span class="toc-text">1.跨主机传输要注意的主要问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">（1）基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-text">大小端存储</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#32%E4%BD%8D%E6%9C%BA%E5%99%A8%E4%B8%8E64%E4%BD%8D%E6%9C%BA%E5%99%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-text">32位机器与64位机器数据类型存储字节数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AD%97%E8%8A%82%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-text">（2）字节序问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">网络字节序</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98"><span class="toc-text">（3）结构体对齐问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-text">（4）数据类型长度问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A5%97%E6%8E%A5%E5%AD%97-Socket"><span class="toc-text">2.套接字-Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9B%B8%E5%85%B3API"><span class="toc-text">（1）套接字相关API</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#socket"><span class="toc-text">socket()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bind"><span class="toc-text">bind()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#struct-sockaddr"><span class="toc-text">struct sockaddr</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#inet-addr"><span class="toc-text">inet_addr()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#inet-pton"><span class="toc-text">inet_pton()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#inet-ntop"><span class="toc-text">inet_ntop()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#listen"><span class="toc-text">listen()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#accept"><span class="toc-text">accept()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#connect"><span class="toc-text">connect()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#send-%E2%80%94TCP"><span class="toc-text">send()—TCP</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#recv-%E2%80%94TCP"><span class="toc-text">recv()—TCP</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sendto-%E2%80%94UDP"><span class="toc-text">sendto()—UDP</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#recvfrom-%E2%80%94UDP"><span class="toc-text">recvfrom()—UDP</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#close"><span class="toc-text">close()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%89%B9%E6%AE%8A%E5%9C%B0%E5%9D%800-0-0-0"><span class="toc-text">（2）特殊地址0.0.0.0</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8A%A5%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97-UDP"><span class="toc-text">3.报式套接字(UDP)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B3%A8%E6%84%8F"><span class="toc-text">（1）注意</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8A%A5%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97%E4%BC%A0%E8%BE%93%E5%AE%9E%E4%BE%8B"><span class="toc-text">（2）报式套接字传输实例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">通信协议</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E6%BA%90%E7%A0%81"><span class="toc-text">接收方源码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E6%BA%90%E7%A0%81"><span class="toc-text">发送方源码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%9A%E7%82%B9%E9%80%9A%E8%AE%AF"><span class="toc-text">4.多点通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%B9%BF%E6%92%AD%EF%BC%88%E5%85%A8%E7%BD%91%E5%B9%BF%E6%92%AD-%E5%AD%90%E7%BD%91%E5%B9%BF%E6%92%AD%EF%BC%89"><span class="toc-text">（1）广播（全网广播\子网广播）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#255-255-255-255"><span class="toc-text">255.255.255.255</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Socket-options"><span class="toc-text">Socket options</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#setsockopt"><span class="toc-text">setsockopt()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#getsockopt"><span class="toc-text">getsockopt()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#if-nametoindex"><span class="toc-text">if_nametoindex()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ip-ro-sh"><span class="toc-text">ip ro sh</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B9%BF%E6%92%AD%E5%AE%9E%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-text">（2）广播实例程序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-1"><span class="toc-text">通信协议</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9"><span class="toc-text">发送方</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9"><span class="toc-text">接收方</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C"><span class="toc-text">编译运行</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6wireshark%E4%BD%BF%E7%94%A8"><span class="toc-text">（3）抓包软件wireshark使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#wireshark%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text">wireshark使用实例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%A4%9A%E6%92%AD-%E7%BB%84%E6%92%AD"><span class="toc-text">（4）多播\组播</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#224-224-224-224"><span class="toc-text">224.224.224.224</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%A4%9A%E6%92%AD-%E7%BB%84%E6%92%AD%E5%AE%9E%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-text">（5）多播\组播实例程序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-2"><span class="toc-text">通信协议</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9-1"><span class="toc-text">发送方</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9-1"><span class="toc-text">接收方</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-1"><span class="toc-text">编译运行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B5%81%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97-TCP"><span class="toc-text">5.流式套接字(TCP)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B5%81%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BE%8B"><span class="toc-text">（1）流式套接字程序实例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-3"><span class="toc-text">通信协议</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%EF%BC%88Server%E7%AC%AC%E4%B8%80%E7%89%88%EF%BC%89"><span class="toc-text">接收方（Server第一版）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%EF%BC%88Server%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89"><span class="toc-text">接收方（Server第二版）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AB%AF1"><span class="toc-text">发送端1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AB%AF2"><span class="toc-text">发送端2</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%EF%BC%88Server%E7%AC%AC%E4%B8%89%E7%89%88%E5%B9%B6%E5%8F%91%E7%89%88%EF%BC%89"><span class="toc-text">接收方（Server第三版并发版）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%9D%99%E6%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">（2）静态进程池套接字实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%EF%BC%88Server%E7%AC%AC%E5%9B%9B%E7%89%88%E9%9D%99%E6%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-text">接收方（Server第四版静态进程池版本）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8A%A8%E6%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-text">（3）套接字动态进程池实现</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Maxswordsman</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>