<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UNIX环境编程-并发（11）</title>
      <link href="/2023/12/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%EF%BC%8811%EF%BC%89/"/>
      <url>/2023/12/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%EF%BC%8811%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="UNIX环境编程-并发（11）"><a href="#UNIX环境编程-并发（11）" class="headerlink" title="UNIX环境编程-并发（11）"></a>UNIX环境编程-并发（11）</h2><h3 id="一、信号"><a href="#一、信号" class="headerlink" title="一、信号"></a>一、信号</h3><h4 id="1-信号的概念"><a href="#1-信号的概念" class="headerlink" title="1.信号的概念"></a>1.信号的概念</h4><p>​信号是软件层面的中断，信号的响应依赖于中断</p><p>（<code>signal</code>）是一种用于异步通知进程某个事件已经发生的机制。当进程收到一个信号时，它可以有几种不同的反应，包括忽略该信号、执行默认的信号处理动作，或者调用一个用户定义的处理函数</p><h5 id="（1）同步与异步"><a href="#（1）同步与异步" class="headerlink" title="（1）同步与异步"></a>（1）同步与异步</h5><p><strong>同步</strong></p><p>在同步操作中，一个任务必须等待前一个任务完成后才能继续执行。这意味着您在等待任务完成时不能做任何其他事情</p><p>特点</p><ul><li>执行顺序是可预测的。</li><li>容易编写和理解，因为操作按预期的顺序执行。</li><li>可能会浪费<code>CPU</code>时间，因为它在等待外部资源（如磁盘<code>IO</code>、网络请求等）时可能会处于闲置状态</li></ul><p><strong>异步</strong><br>在异步操作中，你可以在等待某个任务完成时继续执行其他任务。当那个任务完成后，系统通常会使用回调、事件或其他机制来通知你</p><p>特点</p><ul><li>执行顺序不是固定的，可能需要额外的工具或方法（如回调、promises、futures等）来处理。</li><li>可以更充分地利用<code>CPU</code>，因为它可以在等待外部资源时执行其他任务。</li><li>可能会更难编写和理解，特别是当涉及到大量的异步操作和回调时</li></ul><h4 id="2-signal"><a href="#2-signal" class="headerlink" title="2.signal()"></a>2.signal()</h4><p>在<code>ubuntu </code>终端中输入<code>kill -l</code> 可以查看各类信号</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202308081122519.png" alt="image-20230808112209488"></p><h5 id="（1）函数原型"><a href="#（1）函数原型" class="headerlink" title="（1）函数原型"></a>（1）函数原型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个 void (*func)(int) 函数指针类型 typedef 为 sighandler_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">// void (*signal(int signum,void (*handler)(int)))(int);</span></span><br></pre></td></tr></table></figure><p><code>signal()</code> 函数用于处理信号。这是一个基本的信号处理接口，它允许程序员为特定的信号定义一个处理函数</p><p><strong>参数</strong></p><ul><li><code>signum</code> 是要捕获或忽略的信号。</li><li><code>handler</code> 是当指定的信号发生时要调用的函数的指针(函数指针，回调函数)，或者是以下特定的值：<ul><li><code>SIG_IGN</code>：忽略该信号。</li><li><code>SIG_DFL</code>：采取信号的默认动作。</li></ul></li></ul><p>函数返回值是之前关联到指定信号的处理函数的地址，或者是<code>SIG_IGN</code>、<code>SIG_DFL</code>。如果出错，则返回 <code>SIG_ERR</code></p><h5 id="（2）程序实例"><a href="#（2）程序实例" class="headerlink" title="（2）程序实例"></a>（2）程序实例</h5><p>将文件描述符1号位置 每秒输入一个字符 * 即标准输出中每秒打印一个*号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将文件描述符1号位置 每秒输入一个字符 * 即标准输出</span></span><br><span class="line">write(<span class="number">1</span>,<span class="string">&quot;*&quot;</span>,<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若此时在终端中键入<code>ctrl + c</code>则会打断打印输出，即信号<code>SIGINT</code></p><ul><li>**<code>SIGINT</code>**：中断信号(终端终端符)。当用户从键盘按下<code>Ctrl+C</code>时发送。通常用于中断进程</li><li>**<code>SIGQUIT</code>**：退出信号。和<code>SIGINT</code>类似，但会导致进程核心转储,<code>Ctrl+\</code></li></ul><h6 id="忽略SIGINT信号"><a href="#忽略SIGINT信号" class="headerlink" title="忽略SIGINT信号"></a>忽略<code>SIGINT</code>信号</h6><p>在程序中使用<code>signal</code>函数，忽略<code>SIGINT</code>信号，使得<code>ctrl + c</code>无法打断其输出打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">signal(SIGINT,SIG_IGN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将文件描述符1号位置 每秒输入一个字符 * 即标准输出</span></span><br><span class="line">write(<span class="number">1</span>,<span class="string">&quot;*&quot;</span>,<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202308081536776.png" alt="image-20230808153642731"></p><h6 id="捕获SIGINT信号，执行其他任务"><a href="#捕获SIGINT信号，执行其他任务" class="headerlink" title="捕获SIGINT信号，执行其他任务"></a>捕获<code>SIGINT</code>信号，执行其他任务</h6><p>当程序捕获<code>SIGINT</code>信号时，则在终端打印输出一个<code>!</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">int_handler</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将文件描述符1号位置 输入一个字符 ！ 即标准输出</span></span><br><span class="line">write(<span class="number">1</span>,<span class="string">&quot;!&quot;</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获到SIGINT信号时，则使用回调函数int_handler</span></span><br><span class="line">signal(SIGINT,int_handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将文件描述符1号位置 每秒输入一个字符 * 即标准输出</span></span><br><span class="line">write(<span class="number">1</span>,<span class="string">&quot;*&quot;</span>,<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202308081544916.png" alt="image-20230808154410899"></p><p>当程序执行过程中，若一直键入<code>ctrl + c</code>，程序不会执行10s，一瞬间会输出完，出现如下情况</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202308081552950.png" alt="image-20230808155203918"></p><h6 id="重点：信号会打断阻塞的系统调用"><a href="#重点：信号会打断阻塞的系统调用" class="headerlink" title="重点：信号会打断阻塞的系统调用"></a>重点：信号会打断阻塞的系统调用</h6><p>当一个进程在执行某个阻塞的系统调用（如<code>read()</code>, <code>write()</code>, <code>accept()</code>, <code>sleep()</code>等）时接收到某些信号，并且为该信号设置了处理函数，则该系统调用可能会被中断并提前返回。这是因为信号处理函数被执行，系统调用返回错误，并且<code>errno</code>被设置为<code>EINTR</code>，表示系统调用被一个信号中断</p><p>例如，考虑一个进程正在执行一个阻塞的<code>read()</code>调用，等待从文件或套接字中读取数据。如果在这期间该进程接收到一个信号，并且已经为该信号注册了处理函数，那么<code>read()</code>可能会返回<code>-1</code>，并且<code>errno</code>会被设置为<code>EINTR</code>。</p><p>为了处理这种情况，通常的策略是在检测到系统调用因为<code>EINTR</code>而失败后重新执行该系统调用。这样可以确保系统调用能够完成其原始的任务。</p><p><strong>这是一个简单的处理<code>read()</code>被信号中断的例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> ret;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ret = read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 不是信号打断的，则是真的出错了</span></span><br><span class="line">        <span class="comment">// 若是假的错误，则不会进入if语句，并且重新回到read函数位置，重新得到ret,若正常执行，则会跳出do-while语句</span></span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (ret &lt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>为了避免某些系统调用被中断的行为，你可以使用<code>sigaction()</code>代替<code>signal()</code>来注册信号处理器，并设置<code>SA_RESTART</code>标志。这会使得大多数被此信号中断的系统调用自动重新启动</p><h4 id="3-信号的不可靠"><a href="#3-信号的不可靠" class="headerlink" title="3.信号的不可靠"></a>3.信号的不可靠</h4><p>信号的行为不可靠</p><p>信号机制在早期的UNIX系统中被认为是不可靠的，主要是因为以下原因：</p><ul><li><strong>信号丢失</strong>：在早期的实现中，如果一个信号在其处理程序执行时再次被发送，那么这个信号可能会被忽略。也就是说，如果两次连续发送同一个信号，而在第一个信号的处理程序还没有执行完毕时，第二个信号就到达了，那么第二个信号可能不会被注意到。</li><li><strong>信号不排队</strong>：对于大多数信号来说，不论发送了多少次同样的信号，如果之前的信号尚未处理，则只会保留一次。也就是说，如果你发送了三次<code>SIGUSR1</code>信号，但在处理第一个信号之前，其他两个信号就到达了，那么这两个信号可能被视为一个。</li><li><strong>默认行为和信号处理的改变</strong>：当一个进程接收到一个它没有为其注册处理函数的信号时，它会执行该信号的默认行为（如终止）。但在早期的<code>signal()</code>实现中，当一个信号处理程序被调用时，该信号的行为会被重置为默认行为。这意味着，如果在处理某个信号时再次接收到同样的信号，那么可能会执行该信号的默认行为，而不是再次调用信号处理程序。</li><li><strong>非原子性</strong>：在信号处理函数和主程序之间，存在竞态条件，这可能导致不确定的行为。</li></ul><p>由于上述原因，程序员必须在使用信号时特别小心。为了解决这些问题，后来的<code>UNIX</code>系统和<code>POSIX</code>标准引入了更为可靠的信号处理机制，如<code>sigaction()</code>函数和<code>sigprocmask()</code>函数等，它们提供了更加详细和可控的信号处理能力。</p><p>在现代的<code>UNIX-like</code>系统中，尽管许多早期的问题已经被解决，但仍然建议在设计信号处理时采取谨慎的态度，并充分了解特定平台上的信号语义和行为</p><h4 id="4-可重入函数"><a href="#4-可重入函数" class="headerlink" title="4.可重入函数"></a>4.可重入函数</h4><p>重入：第一次调用没有结束，第二次调用就开始了，但是不会出错</p><p>在计算机编程中，特别是在多线程和信号处理的上下文中，”可重入”是一个重要的概念。<strong>一个函数如果是可重入的，那么它可以在它自身还未完成之前被安全地再次调用</strong>。这意味着多个线程可以同时或者在中断上下文中调用这样的函数，而不必担心会引发竞态条件或其他未定义的行为</p><p><strong>所有的系统调用均为可重入的</strong>，一部分标准的库函数也是可重入的，如:<code>memcpy()</code></p><p>以下是使函数可重入的一些关键属性：</p><ul><li><strong>不使用全局和静态变量</strong>：全局和静态变量在函数的多次调用之间是持久的，所以如果一个函数修改了这样的变量，那么其它的调用可能会看到不一致的状态。</li><li><strong>不修改其参数</strong>：函数不应该修改其传入的参数，除非这些修改是调用者所期望的。</li><li><strong>不调用其他非可重入的函数</strong>：这是很直观的，因为如果一个可重入的函数调用了一个非可重入的函数，那么整个调用链就不能被视为是可重入的。</li><li><strong>使用局部变量代替其他形式的存储</strong>：局部变量在栈上分配，所以每次函数调用都会有其自己的一套局部变量。</li><li><strong>线程安全</strong>：虽然可重入性和线程安全性并不完全相同，但可重入函数在多线程环境中也是线程安全的。</li></ul><p>在信号处理中，可重入性尤为重要，因为你无法预测何时会接收到一个信号。如果一个信号处理函数调用了一个非可重入的函数（例如许多标准库函数），那么可能会出现竞态条件，导致不确定的行为</p><p>例如，<code>malloc()</code> 和 <code>free()</code> 这样的内存管理函数在多线程或信号处理上下文中通常不是可重入的，因为它们维护了一个全局的内存分配表。因此，如果在信号处理器中使用这些函数可能是危险的</p><h4 id="5-信号的响应过程"><a href="#5-信号的响应过程" class="headerlink" title="5.信号的响应过程"></a>5.信号的响应过程</h4><p><a href="https://www.bilibili.com/video/BV18p4y167Md/?p=186&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><p>​信号从收到至响应有一个不可以避免的延迟</p><p>​思考：如何忽略掉一个信号？</p><p>​思考：标准信号为什么丢失？</p><p>​标准信号的响应没有严格的顺序</p><p>​</p><h4 id="6-常用函数"><a href="#6-常用函数" class="headerlink" title="6.常用函数"></a>6.常用函数</h4><h5 id="（1）kill"><a href="#（1）kill" class="headerlink" title="（1）kill()"></a>（1）kill()</h5><p><code>kill</code>函数是用来发送信号给进程的。这个函数定义在<code>&lt;signal.h&gt;</code>头文件中</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><p><code>pid</code>：这是要接收信号的进程的进程ID。</p><ul><li>如果 <code>pid &gt; 0</code>，则信号发送给该<code>pid</code>对应的进程。</li><li>如果 <code>pid == 0</code>，则信号发送给当前进程和同一个进程组的所有进程（组内广播）。</li><li>如果 <code>pid == -1</code>，则信号发送给除了<code>init</code>进程（其<code>PID</code>通常为<code>1</code>）之外的所有进程（全局广播）。调用进程必须有相应的权限。</li><li>如果 <code>pid</code> &lt; -1，则信号发送给进程组ID为<code>-pid</code>的所有进程。</li></ul><p><code>sig</code>：要发送的信号编号。例如，<code>SIGKILL</code>，<code>SIGTERM</code>等。发送0信号可以用来检查一个进程是否存在（它不会导致进程终止或接收任何实际的信号</p><p><strong>返回值</strong></p><ul><li>成功：返回<code>0</code></li><li>失败：返回<code>-1</code>，并设置<code>errno</code>来表示错误原因</li></ul><p><strong>程序实例</strong></p><p>要终止<code>PID</code>为<code>12345</code>的进程，你可以这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">kill(<span class="number">12345</span>, SIGKILL);</span><br></pre></td></tr></table></figure><p>杀死一个进程通常应该更为优雅。许多程序首先发送<code>SIGTERM</code>信号来请求进程终止，给它机会进行清理工作。如果那不起作用，然后再发送<code>SIGKILL</code></p><p>注意：直接使用<code>kill</code>需要谨慎，因为不当地发送信号可能导致不希望的副作用，比如数据丢失或进程不正常终止</p><h5 id="（2）raise"><a href="#（2）raise" class="headerlink" title="（2）raise()"></a>（2）raise()</h5><p><code>raise</code>函数用于发送一个信号给当前执行的进程。它也定义在<code>&lt;signal.h&gt;</code>头文件中</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><p><code>sig</code>：要发送的信号编号。例如，<code>SIGABRT</code>，<code>SIGINT</code>，<code>SIGTERM</code>等</p><p><strong>返回值</strong></p><ul><li>成功：返回0</li><li>失败：返回非0值</li></ul><p><strong>程序实例</strong></p><p>你可能在一个程序中使用<code>raise</code>来生成一个中断信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raising the interrupt signal...\n&quot;</span>);</span><br><span class="line">    raise(SIGINT);  <span class="comment">// Sends an interrupt signal to itself.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After raise.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，程序会发送一个<code>SIGINT</code>信号给自己，模拟像通过键盘发送的<code>Ctrl+C</code>命令。这通常会导致进程终止，除非你有一个针对这个信号的处理函数。</p><p>使用<code>raise</code>函数可以在程序中触发信号处理程序，或者模拟外部条件导致的信号</p><h5 id="（3）alarm"><a href="#（3）alarm" class="headerlink" title="（3）alarm()"></a>（3）alarm()</h5><p>这个函数用于为调用进程设置一个实时闹钟，当这个闹钟超时时，系统会向该进程发送一个<code>SIGALRM</code>信号。它定义在<code>&lt;unistd.h&gt;</code>头文件中</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><p><code>seconds</code>：设置的超时时间，单位为秒。当设置为<code>0</code>时，任何之前设置的闹钟都会被取消</p><p><strong>返回值</strong></p><ul><li>如果之前已经设置了一个闹钟，且它尚未超时，那么<code>alarm</code>函数会返回之前那个闹钟的剩余时间（秒）。否则，它返回0。</li></ul><p>当<code>alarm</code>设置的时间到达时，操作系统会向进程发送<code>SIGALRM</code>信号。默认情况下，这会终止进程。但你可以使用<code>signal</code>或<code>sigaction</code>函数来定义自己的处理函数，从而在收到<code>SIGALRM</code>信号时执行特定的操作</p><ul><li><code>SIGALRM</code>默认行为：当进程接收到<code>SIGALRM</code>信号且没有为它设置处理程序时，默认的行为是终止进程</li><li><code>SIGALRM</code><strong>自定义处理</strong>：你可以使用<code>signal</code>或<code>sigaction</code>函数为<code>SIGALRM</code>定义自己的处理程序，这样你就可以在接收到信号时执行特定的操作，而不是让进程终止</li></ul><p><strong>实例程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_alarm</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alarm went off!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGALRM, handle_alarm);  <span class="comment">// Set up the signal handler</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Setting an alarm for 5 seconds...\n&quot;</span>);</span><br><span class="line">    alarm(<span class="number">5</span>);  <span class="comment">// Set the alarm</span></span><br><span class="line">    pause();  <span class="comment">// Wait for signals to arrive (like SIGALRM)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Exiting program.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序设置了一个5秒的闹钟，并使用<code>pause</code>函数等待信号的到来。当闹钟超时，会执行<code>handle_alarm</code>函数，打印出“Alarm went off!”。然后程序继续执行并退出</p><p>注意：<code>alarm</code>函数只能设置一个闹钟。如果在前一个闹钟超时前再次调用它，前一个闹钟会被新的值替代</p><h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ul><li><strong>定时操作</strong>：你可以使用<code>alarm</code>和<code>SIGALRM</code>来在程序中执行定时任务。例如，如果你的程序在网络上等待数据，但你不希望它永远等待，你可以设置一个闹钟作为超时机制。</li><li><strong>资源限制</strong>：例如，当运行某些计算密集型任务时，你可能希望限制它们的执行时间</li></ul><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li>因为<code>alarm</code>只能设置一个闹钟，所以每次调用<code>alarm</code>都会重置之前的闹钟。</li><li>信号机制不是实时的，所以当你设置一个很短的闹钟时，不一定能够精确地在你期望的时间内触发。</li><li>在信号处理程序中，你应该避免调用可能会改变程序状态或不是异步信号安全的函数</li></ul><h6 id="定时循环程序程序实例"><a href="#定时循环程序程序实例" class="headerlink" title="定时循环程序程序实例"></a>定时循环程序程序实例</h6><p><strong>使用<code>time()函数进行定时</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">time_t</span> end;</span><br><span class="line"><span class="type">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// time(NULL)可以获得当前的时间戳，单位为秒</span></span><br><span class="line">end = time(<span class="literal">NULL</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(time(<span class="literal">NULL</span>) &lt;= end)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序运行<code>5s</code>后，在终端打印输出，在该目录下新建<code>out</code>文件，将程序实际运行程序重定向输入至<code>out</code>中</p><p>运行结果,实际运行时间比<code>5s</code>多一点，存在误差</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/signal$ time ./<span class="number">5</span> &gt;&gt; ./out </span><br><span class="line"></span><br><span class="line">real<span class="number">0</span>m5<span class="number">.317</span>s</span><br><span class="line">user<span class="number">0</span>m5<span class="number">.309</span>s</span><br><span class="line">sys<span class="number">0</span>m0<span class="number">.008</span>s</span><br></pre></td></tr></table></figure><p><strong>使用<code>alarm()</code>函数进行定时</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> loop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alrm_handler</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">loop = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    signal(SIGALRM,alrm_handler);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 程序运行5s之后向进程发送SIGALRM信号</span></span><br><span class="line">alarm(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(loop)</span><br><span class="line">count++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当loop = 0时，即5s之后打印输出 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端中使用指令<code>time ./6 &gt;&gt; ./out</code>运行程序，程序打印结果重定向至<code>out</code>文件中</p><p>程序结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/signal$ time ./<span class="number">6</span> &gt;&gt; ./out </span><br><span class="line"></span><br><span class="line">real<span class="number">0</span>m5<span class="number">.002</span>s</span><br><span class="line">user<span class="number">0</span>m4<span class="number">.998</span>s</span><br><span class="line">sys<span class="number">0</span>m0<span class="number">.004</span>s</span><br></pre></td></tr></table></figure><p><strong>使用alarm()信号的方式去定时，相较于time()精度更高</strong></p><h6 id="使用单一计时器，构造一组函数，实现任意数量的计时器"><a href="#使用单一计时器，构造一组函数，实现任意数量的计时器" class="headerlink" title="使用单一计时器，构造一组函数，实现任意数量的计时器"></a>使用单一计时器，构造一组函数，实现任意数量的计时器</h6><p>关于<strong>因为<code>alarm</code>只能设置一个闹钟，所以每次调用<code>alarm</code>都会重置之前的闹钟</strong></p><h5 id="（4）pause"><a href="#（4）pause" class="headerlink" title="（4）pause()"></a>（4）pause()</h5><p><code>pause</code>函数被用于使进程暂停执行，直到它接收到一个信号。一旦进程接收到信号，<code>pause</code>函数返回，然后进程可以继续执行。这个函数定义在<code>&lt;unistd.h&gt;</code>头文件中</p><p><code>pause</code>函数会使调用它的进程休眠，直到该进程捕获到一个信号。无论信号是否被捕获或忽略，<code>pause</code>都会返回</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><ul><li><code>pause</code>函数永远不会成功返回。如果被中断，它将返回<code>-1</code>，并设置<code>errno</code>为<code>EINTR</code></li></ul><p><code>pause</code>函数在某些场景下是有用的，尤其是当你希望进程在等待外部事件（通常是信号）发生时保持休眠</p><h5 id="（5）abort"><a href="#（5）abort" class="headerlink" title="（5）abort()"></a>（5）abort()</h5><p><code>abort</code>函数是一个标准库函数，位于头文件 <code>&lt;stdlib.h&gt;</code> 中。它的主要功能是用于终止程序的执行。当调用<code>abort</code>函数时，程序会立即停止运行，并生成一个终止信号，通常会导致程序的终止</p><p><code>abort</code>函数通常在以下情况下被调用：</p><ul><li><p><strong>严重错误：</strong> 当程序遇到无法恢复的错误或异常情况时，可以调用<code>abort</code>来中止程序。例如，内存分配失败，或者发生了不应该出现的情况。</p></li><li><p><strong>调试：</strong> 在调试过程中，可以使用<code>abort</code>函数来强制终止程序并获取调试信息，以便进行分析</p></li></ul><h5 id="（6）system"><a href="#（6）system" class="headerlink" title="（6）system()"></a>（6）system()</h5><p><code>system</code>函数是一个标准库函数，位于头文件 <code>&lt;stdlib.h&gt;</code> 中。它用于在程序中执行系统命令或外部程序，并等待命令执行完毕后继续程序的执行</p><p><code>system</code>函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure><p>参数 <code>command</code> 是一个字符串，表示要执行的系统命令或外部程序。当调用<code>system</code>函数时，它会启动一个新的进程来执行指定的命令，然后等待命令执行完毕。函数的返回值表示命令执行的状态：</p><ul><li>如果命令执行成功，<code>system</code>函数返回一个正整数值（通常是<code>0</code>）。</li><li>如果命令执行失败，或者无法执行命令，<code>system</code>函数返回一个非零值。</li></ul><p>程序实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> commandResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 system 函数来执行一个系统命令</span></span><br><span class="line">    commandResult = system(<span class="string">&quot;ls -l&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据返回值判断命令执行状态</span></span><br><span class="line">    <span class="keyword">if</span> (commandResult == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Command executed successfully.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Command execution failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>system(&quot;ls -l&quot;)</code> 执行了一个简单的 <code>ls -l</code> 命令，该命令会列出当前目录的文件和文件夹的详细信息。程序根据<code>system</code>函数的返回值判断命令是否执行成功</p><h5 id="（7）sleep"><a href="#（7）sleep" class="headerlink" title="（7）sleep()"></a>（7）sleep()</h5><p><code>sleep</code>函数是一个标准库函数，位于头文件 <code>&lt;unistd.h&gt;</code> 中。它的作用是让程序在指定的时间内暂停（休眠）执行，以达到一定的延迟效果。<code>sleep</code>函数接受一个以秒为单位的整数参数，表示程序需要休眠的时间</p><p><code>sleep</code>函数的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned int sleep(unsigned int seconds);</span><br></pre></td></tr></table></figure><p>参数 <code>seconds</code> 是一个无符号整数，表示程序需要休眠的秒数。函数会使程序休眠指定的秒数，然后继续执行</p><p>需要注意的是，<code>sleep</code>函数的精度是以秒为单位，如果需要更精细的延迟，可以使用其他系统调用，如 <code>usleep</code> 或 <code>nanosleep</code>，它们允许以微秒和纳秒为单位进行延迟</p><p><strong>此外，<code>sleep</code>函数通常在单线程环境下使用，如果在多线程程序中使用，它可能会导致整个程序休眠</strong>，而不仅仅是调用线程。在多线程环境中，可以考虑使用线程专用的延迟函数来避免这种情况</p><h4 id="7-信号集"><a href="#7-信号集" class="headerlink" title="7.信号集"></a>7.信号集</h4><p>信号是一种中断机制，用于通知进程某些特定事件的发生。信号集是一组信号的集合，用于表示多个信号</p><p>在C语言中，您可以使用以下库函数和数据结构来处理信号集：</p><ul><li><code>sigset_t</code>：这是一个数据结构，用于表示信号集。</li><li><code>sigemptyset(sigset_t *set)</code>：初始化信号集为空集。</li><li><code>sigfillset(sigset_t *set)</code>：将所有信号添加到信号集。</li><li><code>sigaddset(sigset_t *set, int signum)</code>：将指定信号添加到信号集。</li><li><code>sigdelset(sigset_t *set, int signum)</code>：从信号集中删除指定信号。</li><li><code>sigismember(const sigset_t *set, int signum)</code>：检查指定信号是否在信号集中</li></ul><h5 id="（1）sigprocmask函数"><a href="#（1）sigprocmask函数" class="headerlink" title="（1）sigprocmask函数"></a>（1）sigprocmask函数</h5><p>该函数无法决定信号什么时候来，但是可以决定信号何时被响应</p><p><code>sigprocmask</code>函数用于检查或更改进程的信号屏蔽字。这可以用于<strong>阻塞或解阻某些信号</strong>，使得在某些代码段执行时，这些信号不会被传递到进程</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>how</code>：这决定了如何更改当前的信号屏蔽字。它可以是以下之一：<ul><li><code>SIG_BLOCK</code>：将<code>set</code>中的信号添加到当前的屏蔽字中。</li><li><code>SIG_UNBLOCK</code>：从当前的屏蔽字中删除<code>set</code>中的信号。</li><li><code>SIG_SETMASK</code>：设置当前的屏蔽字为<code>set</code>。</li></ul></li><li><code>set</code>：是一个指向信号集的指针，该信号集指定了要进行上述操作的信号。如果<code>set</code>为NULL，则<code>how</code>的值不重要，信号屏蔽字不会被更改。</li><li><code>oldset</code>：如果不是<code>NULL</code>，则进程的当前信号屏蔽字将被存储在<code>oldset</code>中</li></ul><p>返回值：</p><ul><li>如果成功，则返回<code>0</code>。</li><li>如果出错，则返回<code>-1</code>，并设置<code>errno</code>以指示错误。</li></ul><p><strong>程序实例1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个信号的集合</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>,oset,saveset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定信号添加到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对set中的信号进行解除阻塞（这是由于该程序的目的是为了先阻塞后解除阻塞，需要保证在进入循环之前信号时解除阻塞的），将set中信号的状态存储到saveset中，便于程序运行结束之后的恢复</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 将set中的信号添加到当前的屏蔽字中,阻塞set中的信号，这些信号不会被传递到进程,并将set中信号状态保存到oset中</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将文件描述符1号位置 每秒输入一个字符 * 即标准输出</span></span><br><span class="line">            write(<span class="number">1</span>,<span class="string">&quot;*&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(<span class="number">1</span>,<span class="string">&quot;\n&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置当前屏蔽字为oset这样，就会解除之前对于set中信号的阻塞</span></span><br><span class="line">        <span class="comment">// 按照程序的逻辑在换行的时候会对SIGINT作出响应，当对终端键入ctrl + c时，会打断终端运行</span></span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;oset,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对set中的信号状态进行恢复</span></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序运行之后，在终端时入<code>ctrl+c</code>不会立刻进行响应信号，在打印<code>*</code>的过程中打印<code>!</code>号，而是会在换行之后作出响应，因为这个时候解除了对于信号的阻塞</p><p>注意编写信号有关的程序，需要保证信号在全局的状态是不变的，即运行程序后，信号的状态不变，因此在使用函数对某信号进行阻塞时，应该先对其状态进行保存，在使用运行程序结束后，对信号的状态进行恢复</p><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/signal$ ./<span class="number">7</span></span><br><span class="line">**^C*^C**</span><br><span class="line">!***^C**</span><br><span class="line">!*****</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>程序实例2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">int_handler</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// // 将文件描述符1号位置 输入一个字符 ！ 即标准输出</span></span><br><span class="line">    write(<span class="number">1</span>,<span class="string">&quot;!&quot;</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个信号的集合</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>,oset,saveset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获到SIGINT信号时，则使用回调函数int_handler</span></span><br><span class="line">    <span class="comment">// 这样就会对该信号的主要作用进行忽略</span></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定信号添加到信号集中</span></span><br><span class="line">    <span class="comment">// 在终端键入 ctrl +c ---&gt; SIGINT</span></span><br><span class="line">    <span class="comment">// 在终端键入 ctrl +\---&gt; SIGQUIT</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT | SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对set中的信号进行解除阻塞（这是由于该程序的目的是为了先阻塞后解除阻塞，需要保证在进入循环之前信号时解除阻塞的），将set中信号的状态存储到saveset中，便于程序运行结束之后的恢复</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 将set中的信号添加到当前的屏蔽字中,阻塞set中的信号，这些信号不会被传递到进程,并将set中信号状态保存到oset中</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将文件描述符1号位置 每秒输入一个字符 * 即标准输出</span></span><br><span class="line">            write(<span class="number">1</span>,<span class="string">&quot;*&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(<span class="number">1</span>,<span class="string">&quot;\n&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置当前屏蔽字为oset这样，就会解除之前对于set中信号的阻塞</span></span><br><span class="line">        <span class="comment">// 按照程序的逻辑在新起一行，开始进行打印的时候键入 ctrl+\ 均会使得程序终止运行</span></span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;oset,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对set中的信号状态进行恢复</span></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-信号屏蔽字-x2F-Pending集的处理"><a href="#8-信号屏蔽字-x2F-Pending集的处理" class="headerlink" title="8.信号屏蔽字&#x2F;Pending集的处理"></a>8.信号屏蔽字&#x2F;Pending集的处理</h4><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=197&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><h4 id="9-扩展"><a href="#9-扩展" class="headerlink" title="9.扩展"></a>9.扩展</h4><h5 id="（1）sigsuspend"><a href="#（1）sigsuspend" class="headerlink" title="（1）sigsuspend()"></a>（1）sigsuspend()</h5><p><code>sigsuspend</code>是<code>UNIX</code>和类<code>UNIX</code>系统中<code>C</code>语言的一个系统调用函数，用于暂时替换进程的信号屏蔽字并暂停进程执行，直到接收到一个信号。一旦进程接收到一个信号，<code>sigsuspend</code>将返回，并恢复进程的原始信号屏蔽字</p><p>这个函数在某些场景中非常有用，特别是当进程希望等待一个信号但不希望被其他信号中断时</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>mask</code>：指向要设置的新信号屏蔽字的信号集。</li></ul><p>返回值：</p><ul><li><code>sigsuspend</code>总是返回<code>-1</code>，并设置<code>errno</code>为<code>EINTR</code>，表示由信号中断</li></ul><h5 id="（2）sigaction"><a href="#（2）sigaction" class="headerlink" title="（2）sigaction()"></a>（2）sigaction()</h5><p><code>sigaction()</code> 是一个在<code> Unix-like</code> 系统中用于检查或修改信号行为的函数。它被设计用来取代早期的 <code>signal()</code> 函数，因为它提供了更多的功能和更明确的语义。</p><p>信号是 <code>UNIX </code>系统中进程间通讯的方式之一。当进程接收到一个信号时，它可以选择忽略该信号、捕获该信号并执行相应的处理程序，或者按照默认方式处理该信号（例如，<code>SIGTERM</code> 信号的默认处理方式是终止进程）</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>signum</code>: 需要检查或修改行为的信号。</li><li><code>act</code>: 如果不为 <code>NULL</code>，则它指向一个定义新行为的 <code>sigaction</code> 结构体。</li><li><code>oldact</code>: 如果不为<code> NULL</code>，则在调用之后，这个结构体会被设置为信号的旧行为</li></ul><p><code>sigaction</code> 结构体的定义可能如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line">   void     (*sa_handler)(int);</span><br><span class="line">   void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line">   sigset_t   sa_mask;</span><br><span class="line">   int        sa_flags;</span><br><span class="line">   void     (*sa_restorer)(void);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>sa_handler</code>: 对于信号的反应（例如：<code>SIG_IGN</code>, <code>SIG_DFL</code>, 或者一个函数指针）。</li><li><code>sa_sigaction</code>: 一个替代 <code>sa_handler</code> 的处理函数，但它提供更多信息。</li><li><code>sa_mask</code>: 在处理该信号时，额外需要被阻塞的信号集。</li><li><code>sa_flags</code>: 修改行为的标志。</li><li><code>sa_restorer</code>: 以前用于内部恢复操作，现在已经不再使用</li></ul><p>一些常见的 <code>sa_flags</code> 值：</p><ul><li><code>SA_SIGINFO</code>: 使用 <code>sa_sigaction</code> 而不是 <code>sa_handler</code>。</li><li><code>SA_RESTART</code>: 使某些被信号中断的系统调用可重启。</li><li><code>SA_NOCLDSTOP</code>: 如果信号是 <code>SIGCHLD</code>，则只有当子进程退出时才会收到，而不是当它停止时</li></ul><p>程序实例：使用 <code>sigaction</code> 来设置一个处理 <code>SIGINT</code> 信号（通常是 <code>Ctrl+C</code> 产生的）的处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_sigint</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nCaught signal %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    sa.sa_handler = handle_sigint;</span><br><span class="line">    sa.sa_flags = SA_RESTART; </span><br><span class="line">    sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个处理函数 <code>handle_sigint</code> 来捕获 <code>SIGINT</code> 信号，并使用 <code>sigaction</code> 函数将其设为 <code>SIGINT</code> 信号的处理程序</p><h5 id="（3）setitimer"><a href="#（3）setitimer" class="headerlink" title="（3）setitimer()"></a>（3）setitimer()</h5><p><code>setitimer</code> 是用于设置间隔计时器的函数。与之相关的是 <code>getitimer</code>，用于获取当前设置的计时器的值</p><p><strong>该函数时间精度很高，而且误差不会累积</strong></p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>which</code>: 指定要设置的计时器的类型，通常可以是：<ul><li><code>ITIMER_REAL</code>: 实时计时器，当计时器超时时，将发送 <code>SIGALRM</code> 信号。</li><li><code>ITIMER_VIRTUAL</code>: 虚拟计时器，仅在进程执行时减少。</li><li><code>ITIMER_PROF</code>: 类似于 <code>ITIMER_VIRTUAL</code>，但还包括了当系统执行 behalf 时的时间。</li></ul></li><li><code>new_value</code>: 指定新计时器的间隔和值。</li><li><code>old_value</code>: 如果不为<code>NULL</code>，那么在调用之前计时器的当前值将存储在此处</li></ul><p><code>itimerval</code> 结构体的定义大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">// 计时器重启时的新值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">// 计时器的当前值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>timeval</code> 结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> tv_sec;  <span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span> tv_usec; <span class="comment">// 微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回值</p><ul><li>0成功，-1表示失败</li></ul><p>使用 <code>setitimer</code> 时，还需要处理可能由计时器超时产生的信号，如 <code>SIGALRM</code></p><h3 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h3><h4 id="1-线程的概念"><a href="#1-线程的概念" class="headerlink" title="1.线程的概念"></a>1.线程的概念</h4><p>线程通俗理解为<strong>一个正在运行的函数</strong></p><p><strong>在之前的进程就是容器用于承载多个线程</strong></p><p>线程，在计算机科学中通常指的是线程的执行单元。在操作系统中，一个程序可以有多个线程，每个线程可以并行（或伪并行在单核<code>CPU</code>上）执行。线程比进程更轻量级，<strong>多个线程共享同一个地址空间和资源（线程通信相对于进程简单），但每个线程有其自己的指令指针、堆栈</strong>等</p><p><strong>一个进程中至少有一个线程</strong></p><p><strong>线程的优点</strong>：</p><ul><li><strong>效率</strong>：线程的创建和销毁比进程要快得多，切换线程的成本也比切换进程要小。</li><li><strong>资源共享</strong>：因为线程之间共享相同的地址空间，所以一个线程可以访问另一个线程的数据。这使得数据交换变得容易，但也意味着需要同步机制来避免资源竞争和数据不一致。</li><li><strong>响应速度</strong>：在多线程程序中，即使一个线程被阻塞（例如等待<code>I/O</code>操作），其他线程仍然可以继续执行。</li><li><strong>利用多核</strong>：现代的多核处理器可以同时执行多个线程，这使得多线程程序可以真正地并行执行，从而提高了性能</li></ul><p><strong>线程缺点</strong>：</p><ul><li><strong>同步和死锁</strong>：当多个线程试图访问共享资源时，可能会发生资源竞争，这需要使用同步机制（如互斥锁、信号量等）来解决。但不恰当的使用同步机制可能导致死锁。</li><li><strong>数据不一致</strong>：多个线程并发修改共享数据可能导致数据不一致。</li><li><strong>调试困难</strong>：多线程程序的行为可能是不确定的，因此调试可能比单线程程序更加困难。</li><li><strong>设计复杂性</strong>：编写和维护多线程代码需要更高的专业知识和经验</li></ul><p>在ubuntu可以使用命令:<code>ps axm</code> 查看线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps axm</span><br></pre></td></tr></table></figure><h5 id="（1）线程标识符"><a href="#（1）线程标识符" class="headerlink" title="（1）线程标识符"></a>（1）线程标识符</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> thread_id;</span><br></pre></td></tr></table></figure><h5 id="（2）pthread-equal"><a href="#（2）pthread-equal" class="headerlink" title="（2）pthread_equal()"></a>（2）pthread_equal()</h5><p><code>pthread_equal</code>是一个用于比较两个线程<code>ID</code>是否相同的函数</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>t1</code> 和 <code>t2</code>：要比较的线程<code>ID</code>。</li></ul><p>返回值：</p><ul><li>如果两个线程<code>ID</code>相同，则返回非零值。</li><li>如果两个线程<code>ID</code>不同，则返回<code>0</code></li></ul><h5 id="（3）pthread-self"><a href="#（3）pthread-self" class="headerlink" title="（3）pthread_self()"></a>（3）pthread_self()</h5><p><code>pthread_self</code> 是 <code>POSIX </code>线程库中的一个函数，用于获取调用线程的线程<code>ID</code>。这个函数在你需要在某个线程内部知道它自己的线程ID时特别有用</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li>调用线程的线程<code>ID</code></li></ul><h4 id="2-线程创建"><a href="#2-线程创建" class="headerlink" title="2.线程创建"></a>2.线程创建</h4><h5 id="（1）pthread-create"><a href="#（1）pthread-create" class="headerlink" title="（1）pthread_create()"></a>（1）pthread_create()</h5><p><code>pthread_create</code> 是<code>POSIX</code>线程库中的一个函数，用于创建一个新的线程。这个函数允许开发者定义一个函数，这个函数将会在新创建的线程中运行</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>thread</code>：指向 <code>pthread_t</code> 类型的指针，用于存储新创建线程的线程ID。</li><li><code>attr</code>：指向 <code>pthread_attr_t</code> 类型的指针，用于设置线程属性（如堆栈大小）。如果传递 <code>NULL</code>，则会使用默认属性(<strong>一般默认就可以解决80%的问题</strong>)。</li><li><code>start_routine</code>：指针，指向新线程启动时需要调用的函数。这个函数的返回类型必须为 <code>void *</code>，并且接受一个 <code>void *</code> 参数。</li><li><code>arg</code>：传递给 <code>start_routine</code> 的参数</li></ul><p>返回值：</p><ul><li>如果线程成功创建，返回<code>0</code>。</li><li>如果发生错误，返回一个非<code>0</code>的错误代码（<code>error number</code>）</li></ul><p>程序实例</p><p><code>create1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针函数 return NULL 指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Thread is working!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line"></span><br><span class="line">err = pthread_create(&amp;tid,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0表示成功 非0则失败</span></span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(Proj_1)    <span class="comment"># 工程名字可以与可执行程序名不一样</span></span><br><span class="line"><span class="keyword">add_executable</span>(create1 create1.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找pthread库</span></span><br><span class="line"><span class="keyword">find_package</span>(Threads REQUIRED)</span><br><span class="line"><span class="comment"># 链接pthread库到你的目标</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(create1 Threads::Threads)</span><br></pre></td></tr></table></figure><p>运行之后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/thread/create1/build$ ./create1 </span><br><span class="line">Begin!</span><br><span class="line">End!</span><br></pre></td></tr></table></figure><p>最后运行程序之后并没有显示调用线程函数中的输出内容，（<strong>线程的调用取决于调度器策略</strong>）这是因为线程还没有来得及调用，进程已经通过<code>exit(0)</code>结束</p><h4 id="3-线程终止"><a href="#3-线程终止" class="headerlink" title="3.线程终止"></a>3.线程终止</h4><h5 id="（1）终止方式"><a href="#（1）终止方式" class="headerlink" title="（1）终止方式"></a>（1）终止方式</h5><ul><li>线程从启动历程返回.返回值就是线程的退出码</li><li>线程可以被统同一进程中的其他线程取消</li><li>线程调用<code>pthread_exit()</code>函数</li></ul><h5 id="（2）pthread-exit"><a href="#（2）pthread-exit" class="headerlink" title="（2）pthread_exit()"></a>（2）pthread_exit()</h5><p><code>pthread_exit</code>函数用于从调用线程中退出，并提供一个退出值，该值可由另一个线程通过<code>pthread_join</code>获取。当一个线程调用<code>pthread_exit</code>时，线程的清理处理程序将被执行，其存储空间（例如栈）会被回收</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>retval</code>: 是一个指向任意数据类型的指针，表示线程的退出值。如果你不需要返回特定的值，可以简单地传递<code>NULL</code></li></ul><p>说明：</p><ul><li>调用<code>pthread_exit</code>将不会关闭整个进程，只会关闭调用它的线程。</li><li>如果主线程调用了<code>pthread_exit</code>而没有结束程序，那么其他线程仍然可以继续执行。</li><li>如果从主函数返回，其行为类似于调用<code>exit</code>（整个进程都会结束，所有线程都会被关闭）。但是，如果主线程调用<code>pthread_exit</code>，进程不会结束，其他线程可以继续执行</li></ul><h5 id="（3）pthread-join"><a href="#（3）pthread-join" class="headerlink" title="（3）pthread_join()"></a>（3）pthread_join()</h5><p>该函数类似于进程中的<code>wait()</code>函数，用于给线程进行收尸</p><p><code>pthread_join</code> 是 <code>POSIX </code>线程库中的一个函数，用于阻塞调用线程，直到指定的线程终止。这个函数还允许调用线程检索目标线程的退出状态</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><p>参数</p><ul><li><code>thread</code>：是要等待的线程的标识符。</li><li><code>retval</code>：是一个指向指针的指针，用于获取线程的退出值。如果不关心退出值，可以设置为 <code>NULL</code></li></ul><p>返回值</p><ul><li>如果成功，返回 <code>0</code>。</li><li>如果出错，返回一个非零错误代码。</li></ul><p><strong>注意事项</strong>：</p><ul><li>如果目标线程已经终止，但还没有被<code>join</code>，那么它被称为“僵尸线程”。<code>pthread_join</code> 的一个主要用途是从系统中清除僵尸线程。</li><li>一个线程只能被 <code>join</code> 一次。一旦一个线程被成功地 <code>join</code>，它的<code> ID</code> 就可以被再次使用。</li><li>线程不是必须被 <code>join</code>。例如，如果你不关心线程的退出状态，你可以选择不 <code>join</code> 它</li></ul><p><strong>程序实例</strong></p><p><code>create1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针函数 return NULL 指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Thread is working!&quot;</span>);</span><br><span class="line">    <span class="comment">// 线程结束</span></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">void</span> *thread_exit_status;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line"></span><br><span class="line">err = pthread_create(&amp;tid,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0表示成功 非0则失败</span></span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line">&#123;</span><br><span class="line">         <span class="comment">// perror(&quot;pthread_creat()&quot;);</span></span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程结束,对线程进行资源的回收</span></span><br><span class="line">pthread_join(tid,thread_exit_status);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Thread exit status: %ld\n&quot;</span>, (<span class="type">long</span>)thread_exit_status);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程结束</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）栈的清理（线程中的钩子函数）"><a href="#（4）栈的清理（线程中的钩子函数）" class="headerlink" title="（4）栈的清理（线程中的钩子函数）"></a>（4）栈的清理（线程中的钩子函数）</h5><p>在多线程编程中，线程可能在执行期间的任何时间点被取消。当线程被取消时，可能会需要执行一些清理任务，如释放资源、解锁互斥锁等。<code>POSIX</code>线程库提供了<code>pthread_cleanup_push</code>和<code>pthread_cleanup_pop</code>函数，允许你指定在线程退出或被取消时执行的清理任务</p><p><strong><code>pthread_cleanup_push</code> 函数</strong>：</p><p>该函数将清理处理程序（一个函数）推入当前线程的清理处理程序堆栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>routine</code>: 这是一个指向清理函数的指针。当线程退出或被取消时，这个函数将被调用。</li><li><code>arg</code>: 这是传递给清理函数的参数</li></ul><p><strong><code>pthread_cleanup_pop</code> 函数</strong>：</p><p>该函数从当前线程的清理处理程序堆栈中弹出最近推入的清理处理程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>execute</code>: 如果非零，清理函数将被执行；否则，清理函数不会被执行</li></ul><h6 id="程序实例"><a href="#程序实例" class="headerlink" title="程序实例"></a>程序实例</h6><p><code>create2.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanup_func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>((<span class="type">char</span> *) p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针函数 return NULL 指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Thread is working!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压入栈(挂上钩子)</span></span><br><span class="line">pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:1&quot;</span>);</span><br><span class="line">pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:2&quot;</span>);</span><br><span class="line">pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:3&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;push over!&quot;</span>);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程结束</span></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line"></span><br><span class="line">err = pthread_create(&amp;tid,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0表示成功 非0则失败</span></span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程结束,对线程进行资源的回收</span></span><br><span class="line">pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程结束</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.16</span>)</span><br><span class="line">project(Proj_1)    # 工程名字可以与可执行程序名不一样</span><br><span class="line">add_executable(create2 create2.c)</span><br><span class="line"></span><br><span class="line">find_package(Threads REQUIRED)</span><br><span class="line">target_link_libraries(create2 Threads::Threads)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/thread/create2/build$ ./create2 </span><br><span class="line">Begin!</span><br><span class="line">Thread is working!</span><br><span class="line">push over!</span><br><span class="line">cleanup:<span class="number">3</span></span><br><span class="line">cleanup:<span class="number">2</span></span><br><span class="line">cleanup:<span class="number">1</span></span><br><span class="line">End!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>pthread_cleanup_push</code>和<code>pthread_cleanup_pop</code>必须在同一个代码块中，并且对于每个<code>push</code>都必须有一个匹配的<code>pop</code>,<code>pthread_cleanup_pop</code>函数即使放到<code>static void *func(void *p)</code>函数中的<code>pthread_exit(NULL)</code>之后也可以，但是必须要有，<strong>这两个所谓的函数实质上是宏</strong></p><h4 id="4-线程取消"><a href="#4-线程取消" class="headerlink" title="4.线程取消"></a>4.线程取消</h4><h5 id="（1）pthread-cancel"><a href="#（1）pthread-cancel" class="headerlink" title="（1）pthread_cancel()"></a>（1）pthread_cancel()</h5><p><code>pthread_cancel</code> 函数用于请求取消一个线程。需要注意的是，“请求”取消并不意味着线程立即终止。相反，目标线程决定在哪些点上检查取消请求，这些点称为“取消点”</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>参数</p><ul><li><code>thread</code>：要取消的线程的标识符</li></ul><p>返回值</p><ul><li>如果成功，返回 <code>0</code>。</li><li>如果出错，返回一个非零错误代码</li></ul><p>注意事项：</p><ul><li>取消一个线程并不立即终止它，但是会设置一个请求来取消线程。线程在取消点检查这个请求。</li><li>常见的取消点包括一些系统调用，如<code>open()</code>,<code>read()</code>, <code>write()</code>, <code>sleep()</code>和<code>pthread_testcancel()</code>等。</li><li>可以使用<code>pthread_setcancelstate()</code>和<code>pthread_setcanceltype()</code>函数来控制线程的取消行为</li></ul><h6 id="取消状态"><a href="#取消状态" class="headerlink" title="取消状态"></a>取消状态</h6><ul><li>两种：允许与不允许</li></ul><h6 id="允许取消"><a href="#允许取消" class="headerlink" title="允许取消"></a>允许取消</h6><ul><li><p>分为异步cancel，推迟cancel(默认)–&gt;推迟至cancel点在响应</p></li><li><p>cancel点（取消点）: <code>POSIX</code>定义的cancel点，都是可能引发阻塞的系统调用（注意事项的第二点）</p></li></ul><h6 id="pthread-setcancelstate"><a href="#pthread-setcancelstate" class="headerlink" title="pthread_setcancelstate()"></a><code>pthread_setcancelstate()</code></h6><ul><li>设置是否允许取消</li></ul><h6 id="pthread-setcanceltype"><a href="#pthread-setcanceltype" class="headerlink" title="pthread_setcanceltype()"></a><code>pthread_setcanceltype()</code></h6><ul><li>设置取消方式</li></ul><h6 id="pthread-testcancel"><a href="#pthread-testcancel" class="headerlink" title="pthread_testcancel()"></a><code>pthread_testcancel()</code></h6><ul><li>该函数什么都不做，就是一个取消点</li></ul><h5 id="（2）线程分离"><a href="#（2）线程分离" class="headerlink" title="（2）线程分离"></a>（2）线程分离</h5><p>在多线程编程中，线程分离（<code>Detached threads</code>）是一个重要的概念。当一个线程结束运行并退出时，其退出状态需要被另一个线程收集，这通常是通过 <code>pthread_join</code> 函数完成的。如果一个线程没有被其他线程<code>join</code>，那么它的结束状态就会被留在系统中，这种线程被称为“僵尸线程”。</p><p>为了避免这种情况，我们可以创建一个分离的线程。一个分离的线程在结束时会自动清理其资源，不需要其他线程来<code>join</code>它</p><h6 id="如何创建一个分离线程？"><a href="#如何创建一个分离线程？" class="headerlink" title="如何创建一个分离线程？"></a>如何创建一个分离线程？</h6><ul><li>使用 <code>pthread_attr_t</code> 和 <code>pthread_attr_init</code></li></ul><p>可以在创建线程之前设置线程属性使其为分离的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">pthread_create(&amp;tid, &amp;attr, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_attr_destroy(&amp;attr); <span class="comment">// Don&#x27;t forget to destroy the attribute</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>pthread_detach</code></li></ul><p>如果线程已经创建了，你可以使用 <code>pthread_detach</code> 函数来将它设置为分离的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">pthread_detach(tid);</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>分离的线程不能被其他线程<code>join</code>。</li><li>你不应该分离一个线程并且也试图<code>join</code>它。这种行为是未定义的。</li><li>如果你知道一个线程不会被<code>join</code>，最好将其设置为分离的，以确保资源得到适当的清理。</li></ul><h6 id="程序实例-1"><a href="#程序实例-1" class="headerlink" title="程序实例"></a>程序实例</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inside the detached thread\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行完该函数的工作后，对线程进行终止</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 上述被创建的线程以及被分离，不需要通过join进行收尸,会自动清理自己</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread continuing...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);  <span class="comment">// Allow the detached thread to finish</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，创建了一个分离的线程，它会自动清理自己，主线程只是继续运行并在最后休眠了一段时间以等待分离的线程完成</p><h4 id="5-线程竞争"><a href="#5-线程竞争" class="headerlink" title="5.线程竞争"></a>5.线程竞争</h4><p>线程竞争，通常称为竞争条件（<code>Race Condition</code>），发生在两个或更多线程并发访问共享资源，并尝试读、写或修改这些资源，导致执行结果变得不可预测。这是因为线程的调度方式是不确定的，所以你不能预知哪个线程首先访问资源或在什么时候进行访问</p><p>竞争条件可能导致各种问题，包括：</p><ul><li>数据不一致：共享数据可能处于不一致的状态。</li><li>程序崩溃：如果一个线程期望某些数据保持不变，但另一个线程修改了它，可能导致不可预测的行为。</li><li>性能问题：例如，如果两个线程都尝试更新相同的数据，可能需要重试，从而降低效率</li></ul><p><strong>解决方法</strong></p><ul><li>**互斥量 (Mutexes)**：这是一种同步原语，可以确保一次只有一个线程可以访问某些资源或代码段。例如，<code>pthread_mutex_t</code> 是<code>POSIX</code>线程库中的一个常见互斥量。</li><li>**读-写锁 (Read-Write Locks)**：允许多个线程同时读共享资源，但一次只有一个线程可以写。</li><li>**信号量 (Semaphores)**：是一个更通用的同步工具，它可以控制同时访问某个资源的线程数。</li><li>**原子操作 (Atomic Operations)**：这些操作在单个操作中完成，不会被其他线程中断。这些操作通常由硬件支持，并可确保数据的完整性。</li></ul><p>防止竞争条件的关键是识别并保护对共享资源的所有访问，并确保一次只有一个线程可以执行修改。</p><h5 id="（1）程序实例"><a href="#（1）程序实例" class="headerlink" title="（1）程序实例"></a>（1）程序实例</h5><p><strong>该程序目的，创建多个线程同时对一个文件进行读写，最后每次运行程序文件中的数字应该要比运行前大20</strong></p><p>在程序的同级别目录下创建<code>out</code>文件，终端指令<code>echo 1 &gt; ./out</code>向该文件中输入数字1</p><p><code>primer0.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FNAME <span class="string">&quot;../out&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_add</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="type">char</span> linebuf[LINESIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">fp = fopen(FNAME,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件中的一行</span></span><br><span class="line">fgets(linebuf,LINESIZE,fp);</span><br><span class="line"><span class="comment">// 定位到文件开始的位置进行覆盖写入</span></span><br><span class="line">fseek(fp,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="comment">// 此处的sleep可以将错误进行放大，因为若机器为单核的可能程序运行后就是预期的结果</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将l1infbuf字符串中的转为整形+1 在写入文件流fp中</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d\n&quot;</span>,atoi(linebuf)+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭线程</span></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,err;</span><br><span class="line"><span class="type">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;THRNUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">err = pthread_create(tid+i,<span class="literal">NULL</span>,thr_add,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 线程创建失败非0,即为真</span></span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>,strerror(err));</span><br><span class="line"><span class="comment">// 异常退出主进程</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收线程资源（收尸）</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;THRNUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.16</span>)</span><br><span class="line">project(Proj_1)    # 工程名字可以与可执行程序名不一样</span><br><span class="line">add_executable(primer0 primer0.c)</span><br><span class="line"></span><br><span class="line">find_package(Threads REQUIRED)</span><br><span class="line">target_link_libraries(primer0 Threads::Threads)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>最后文件中的值为2,是因为出现了线程竞争，相当于20个线程对文件中的内容取20次，都为1在对文件重复写了20次都为2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/thread/create3/build$ ./primer0 </span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/thread/create3/build$ cat ../out </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h5 id="（2）线程同步"><a href="#（2）线程同步" class="headerlink" title="（2）线程同步"></a>（2）线程同步</h5><h6 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h6><p>互斥量（<code>Mutex</code>, 是 Mutual Exclusion 的缩写）是多线程编程中的一个同步原语，它用于保护对共享资源的并发访问，从而避免竞争条件。一个互斥量在任意时刻都只能被一个线程锁定。如果其他线程试图再次锁定它，它们会被阻塞，直到第一个线程释放互斥量</p><p>在 <code>POSIX</code> 线程<code>（pthreads）</code>库中，互斥量的类型是 <code>pthread_mutex_t</code></p><p><strong>使用互斥量基本步骤</strong></p><ul><li><strong>初始化互斥量</strong>（静态）:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><ul><li><strong>锁定互斥量</strong>: 当你需要保护一段代码或资源时，可以尝试锁定互斥量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure><ul><li><p><strong>访问受保护的资源或代码</strong></p></li><li><p><strong>解锁互斥量</strong>: 访问完成后，你应该立即释放互斥量。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><ul><li><strong>销毁互斥量</strong>: 当不再需要互斥量时，应确保销毁它。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure><h6 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init()"></a>pthread_mutex_init()</h6><p>这个函数用于初始化互斥量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>mutex</code>：指向要初始化的互斥量。</li><li><code>attr</code>：指定互斥量属性，如果设为NULL，则使用默认属性。</li></ul><p><strong>返回值</strong>：</p><ul><li>成功：返回<code>0</code>。</li><li>错误：返回错误号</li></ul><h6 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="pthread_mutex_destroy()"></a>pthread_mutex_destroy()</h6><p>这个函数用于销毁一个已经不再需要的互斥量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>mutex</code>：指向要销毁的互斥量。</li></ul><p><strong>返回值</strong>：</p><ul><li>成功：返回<code>0</code>。</li><li>错误：返回错误号</li></ul><h6 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock()"></a>pthread_mutex_lock()</h6><p>尝试锁定一个互斥量。如果互斥量已经被其他线程锁定，该调用会<strong>阻塞</strong>，直到互斥量可用为止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>mutex</code>：指向要锁定的互斥量。</li></ul><p><strong>返回值</strong>：</p><ul><li>成功：返回<code>0</code>。</li><li>错误：返回错误号</li></ul><h6 id="pthread-mutex-trylock"><a href="#pthread-mutex-trylock" class="headerlink" title="pthread_mutex_trylock()"></a>pthread_mutex_trylock()</h6><p>尝试锁定一个互斥量。如果互斥量已经被其他线程锁定，该调用会立即返回一个<code>EBUSY</code>错误，而不是阻塞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>mutex</code>：指向要尝试锁定的互斥量。</li></ul><p><strong>返回值</strong>：</p><ul><li>成功：返回<code>0</code>。</li><li>错误：返回错误号</li></ul><h6 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock()"></a>pthread_mutex_unlock()</h6><p>解锁一个互斥量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>mutex</code>：指向要解锁的互斥量。</li></ul><p><strong>返回值</strong>：</p><ul><li>成功：返回<code>0</code>。</li><li>错误：返回错误号</li></ul><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>这些函数使你能够在多线程环境中安全地对共享资源进行操作，从而避免产生竞争条件。但要记住，当你使用互斥量时，应确保在所有的代码路径上，<strong>每次锁定都有相应的解锁</strong>，以避免死锁和其他同步问题</p><h5 id="（3）程序实例-互斥量"><a href="#（3）程序实例-互斥量" class="headerlink" title="（3）程序实例(互斥量)"></a>（3）程序实例(互斥量)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FNAME <span class="string">&quot;../out&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥量</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_add</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="type">char</span> linebuf[LINESIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">fp = fopen(FNAME,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个线程无法同时进行操作的资源，锁定互斥量</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 读取文件中的一行</span></span><br><span class="line">fgets(linebuf,LINESIZE,fp);</span><br><span class="line"><span class="comment">// 定位到文件开始的位置进行覆盖写入</span></span><br><span class="line">fseek(fp,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将linfbuf字符串中的转为整形+1 在写入文件流fp中</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d\n&quot;</span>,atoi(linebuf)+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭线程</span></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,err;</span><br><span class="line"><span class="type">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;THRNUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">err = pthread_create(tid+i,<span class="literal">NULL</span>,thr_add,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 线程创建失败非0,即为真</span></span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>,strerror(err));</span><br><span class="line"><span class="comment">// 异常退出主进程</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收线程资源（收尸）</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;THRNUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥量销毁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>休眠一段事件后,正确的结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/thread/create3/build$ ./primer0 </span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/thread/create3/build$ cat ../out </span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><h4 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6.线程池"></a>6.线程池</h4><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=210&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><p>线程池是多线程编程中的一种设计模式，它用于为待执行的任务提供已经启动的线程，而不是为每个任务启动一个新线程。这种方法的好处是可以减少创建和销毁线程的开销，并限制系统中线程的数量，这样可以预防资源的过度使用和系统的过载</p><p>线程池通常由以下几个核心组件组成：</p><ul><li><strong>任务队列</strong>：存储待执行的任务。</li><li><strong>工作者线程</strong>：线程池中的线程，它们不断从任务队列中取出任务并执行。</li><li><strong>线程池管理器</strong>：负责添加、暂停或终止工作者线程</li></ul><p>线程池的工作流程通常如下：</p><ul><li>初始化线程池并创建一定数量的工作者线程。</li><li>当一个新任务到达时，将其添加到任务队列。</li><li>工作者线程从任务队列中取出任务并执行。完成后，它会再次检查队列以获取下一个任务。</li><li>当任务队列为空，线程可以选择休眠等待，或根据具体的线程池策略进行其他操作</li></ul><h5 id="（1）C语言中实现线程池"><a href="#（1）C语言中实现线程池" class="headerlink" title="（1）C语言中实现线程池"></a>（1）C语言中实现线程池</h5><p>C语言本身并不直接支持线程池，但你可以使用<code>pthread</code>库手动实现一个，或使用现有的第三方库，如<code>libthreadpool</code></p><p>如果你决定自己实现线程池，这里有一些建议的步骤：</p><ul><li><strong>定义数据结构</strong>：为线程池、工作者线程和任务定义数据结构。</li><li><strong>初始化线程池</strong>：根据指定的大小创建工作者线程，并初始化任务队列。</li><li><strong>提交任务</strong>：提供一个函数，使用户能够将任务添加到队列。</li><li><strong>工作者线程的主函数</strong>：此函数应从任务队列中提取任务并执行它们。</li><li><strong>清理和关闭</strong>：提供一个函数来停止所有工作者线程并清理线程池。</li></ul><p>虽然从头实现一个线程池是一个很好的学习经验，但如果你要在生产环境中使用线程池，建议使用已经存在且经过良好测试的第三方库，因为线程同步和管理都是比较复杂的主题，容易出错</p><h4 id="7-条件变量"><a href="#7-条件变量" class="headerlink" title="7.条件变量"></a>7.条件变量</h4><p>条件变量是多线程编程中用于线程同步的另一种机制。它允许线程阻塞等待，直到某个特定条件成为真。这是一种有用的机制，特别是在涉及生产者-消费者问题或其他需要多个线程协作的场景中</p><p>在 <code>POSIX </code>线程（<code>pthreads</code>）中，条件变量的类型是 <code>pthread_cond_t</code></p><h5 id="（1）相关函数"><a href="#（1）相关函数" class="headerlink" title="（1）相关函数"></a>（1）相关函数</h5><h6 id="pthread-cond-init"><a href="#pthread-cond-init" class="headerlink" title="pthread_cond_init()"></a><code>pthread_cond_init()</code></h6><p><code>pthread_cond_init</code>函数用于初始化一个条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>cond</strong>: 指向要初始化的条件变量的指针。</li><li><strong>attr</strong>: 指向条件变量属性对象的指针。如果你想使用默认的属性，可以设置为NULL。</li></ul><p>返回值：</p><ul><li><strong>0</strong>: 成功。</li><li><strong>非0</strong>: 错误码，表示发生了错误</li></ul><h6 id="pthread-cond-destroy"><a href="#pthread-cond-destroy" class="headerlink" title="pthread_cond_destroy()"></a><code>pthread_cond_destroy()</code></h6><p><code>pthread_cond_destroy</code>函数用于销毁一个条件变量，并释放与之相关的任何资源。销毁一个已被其他线程阻塞（等待）的条件变量将导致未定义的行为，因此在销毁条件变量之前，确保没有线程正在等待该条件变量是很重要的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>cond</strong>: 指向要销毁的条件变量的指针。</li></ul><p>返回值：</p><ul><li><strong>0</strong>: 成功。</li><li><strong>非0</strong>: 错误码，表示发生了错误</li></ul><h6 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="pthread_cond_wait()"></a><code>pthread_cond_wait()</code></h6><p><code>pthread_cond_wait</code>函数在多线程编程中用于阻塞当前线程，直到另一个线程发出信号通知这个条件变量。通常与一个互斥量（mutex）一起使用，以确保数据的同步访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>cond</strong>: 指向条件变量的指针。</li><li><strong>mutex</strong>: 在调用<code>pthread_cond_wait</code>之前必须被锁定的互斥量。<code>pthread_cond_wait</code>会自动释放此互斥量，然后等待直到条件变量被其他线程发出信号或广播。一旦收到信号或广播，<code>pthread_cond_wait</code>再次锁定互斥量并返回。</li></ul><p>返回值：</p><ul><li><strong>0</strong>: 成功。</li><li><strong>非0</strong>: 错误码</li></ul><h6 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal()"></a><code>pthread_cond_signal()</code></h6><p><code>pthread_cond_signal</code>函数用于从一个或多个等待给定条件变量的线程中唤醒一个线程。它是条件变量操作的核心，使得多线程间可以进行精确的同步操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>cond</strong>: 指向条件变量的指针。</li></ul><p>返回值：</p><ul><li><strong>0</strong>: 成功。</li><li><strong>非0</strong>: 错误码</li></ul><h6 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="pthread_cond_broadcast()"></a><code>pthread_cond_broadcast()</code></h6><p><code>pthread_cond_broadcast</code>函数用于唤醒所有正在给定条件变量上等待的线程。与<code>pthread_cond_signal</code>不同，<code>pthread_cond_signal</code>只唤醒一个等待的线程，而<code>pthread_cond_broadcast</code>则唤醒所有等待的线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>cond</strong>: 指向条件变量的指针。</li></ul><p>返回值：</p><ul><li><strong>0</strong>: 成功。</li><li><strong>非0</strong>: 错误码</li></ul><h5 id="（2）程序实例-1"><a href="#（2）程序实例-1" class="headerlink" title="（2）程序实例"></a>（2）程序实例</h5><p><code>producer</code>线程添加元素到缓冲区，而<code>consumer</code>线程从缓冲区中取出元素。条件变量确保当缓冲区满时，生产者会等待，而当缓冲区为空时，消费者会等待</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥量与条件变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 当生产车间buf满时，无法在进行生产，生产者等待,对互斥量进行解锁，阻塞当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (count == BUFFER_SIZE) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[count++] = i;</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程结束</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer: %d\n&quot;</span>, buffer[--count]);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程结束</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> prod, cons;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;prod, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cons, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回收线程资源</span></span><br><span class="line">    pthread_join(prod, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cons, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-线程-信号量"><a href="#8-线程-信号量" class="headerlink" title="8.线程-信号量"></a>8.线程-信号量</h4><p>信号量（semaphores）是一个同步原语，经常用于限制对资源的并发访问（<strong>可以解决资源有上限的资源共享问题</strong>），或者作为多个线程或进程间的同步手段。在线程编程中，信号量可以用来解决读者-写者问题、生产者-消费者问题等</p><p>在<code>POSIX</code>线程（<code>pthreads</code>）中，<strong>信号量由<code>sem_t</code>类型表示，并通过一系列的函数进行操作</strong>：</p><ul><li><strong>sem_init()</strong> - 初始化一个未命名的信号量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>sem_wait()</strong> - 减少信号量的值。如果信号量的值大于<code>0</code>，则减少其值并立即返回。如果信号量的值为<code>0</code>，则线程会被阻塞，直到信号量值变为大于<code>0</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>sem_trywait()</strong> - 尝试减少信号量的值。如果信号量的值为0，则立即返回错误，否则减少其值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>sem_post()</strong> - 增加信号量的值。增加后，如果有其他线程因为<code>sem_wait</code>被阻塞在这个信号量上，那么其中一个线程会被唤醒</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>sem_destroy()</strong> - 销毁一个未命名的信号量，释放其相关资源</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li>还有其他函数，如<code>sem_getvalue()</code>（获取当前信号量值）和命名信号量相关的函数（如<code>sem_open()</code>, <code>sem_close()</code>, <code>sem_unlink()</code>等）</li></ul><h5 id="（1）相关函数-1"><a href="#（1）相关函数-1" class="headerlink" title="（1）相关函数"></a>（1）相关函数</h5><h6 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init()"></a>sem_init()</h6><p>初始化一个未命名的信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>sem</strong>：这是指向要初始化的信号量对象的指针</li><li><strong>pshared</strong>：这个参数决定了信号量是在同一进程的线程间共享（设置为0），还是在多个进程间共享（设置为非0值）。大多数情况下，我们只在一个进程的线程之间使用信号量，因此将其设置为0</li><li><strong>value</strong>：这是信号量的初始值。例如，如果你想使用信号量作为一个互斥锁，你可以将初始值设置为1</li></ul><p>返回值：</p><ul><li><strong>0</strong>：表示成功。</li><li><strong>-1</strong>：表示出错，此时错误码存放在<code>errno</code>中</li></ul><h6 id="sem-wait"><a href="#sem-wait" class="headerlink" title="sem_wait()"></a>sem_wait()</h6><p>用于降低信号量的值。如果信号量的当前值大于0，它会被减少（通常是减少1）并且函数立即返回。如果信号量的当前值为0，调用此函数的线程将被阻塞，直到信号量值变为大于0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>sem</strong>：指向信号量对象的指针。</li></ul><p>返回值：</p><ul><li><strong>0</strong>：表示成功。</li><li><strong>-1</strong>：表示出错，此时错误码存放在<code>errno</code>中</li></ul><h6 id="sem-trywait"><a href="#sem-trywait" class="headerlink" title="sem_trywait()"></a>sem_trywait()</h6><p>这个函数尝试降低信号量的值，但与 <code>sem_wait()</code> 不同的是，如果信号量当前的值为0，它不会阻塞调用线程，而是立即返回一个错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>sem</strong>：指向信号量对象的指针。</li></ul><p>返回值：</p><ul><li><strong>0</strong>：表示成功，信号量的值被成功减少。</li><li><strong>-1</strong>：表示无法降低信号量的值（例如，当它已经为0时）或其他错误发生。此时，错误码存放在<code>errno</code>中。常见的错误码是<code>EAGAIN</code>，表示信号量的值当前为0</li></ul><h6 id="sem-post"><a href="#sem-post" class="headerlink" title="sem_post()"></a>sem_post()</h6><p>它的作用是增加信号量的值。当信号量的值增加时，如果有线程因调用 <code>sem_wait()</code> 或 <code>sem_trywait()</code> 而阻塞在这个信号量上，那么其中一个线程将被唤醒并继续执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>sem</strong>：指向信号量对象的指针。</li></ul><p>返回值：</p><ul><li><strong>0</strong>：表示成功。</li><li><strong>-1</strong>：表示出错，此时错误码存放在 <code>errno</code> 中</li></ul><h5 id="（2）实例程序"><a href="#（2）实例程序" class="headerlink" title="（2）实例程序"></a>（2）实例程序</h5><h6 id="总资源数为1"><a href="#总资源数为1" class="headerlink" title="总资源数为1"></a>总资源数为1</h6><p>如果生产者和消费者线程使用的信号量对应的<strong>总资源数为1</strong>，那么不管线程有多少个，可以工作的线程只有一个，其余线程由于拿不到资源，都被迫阻塞了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br></pre></td></tr></table></figure><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号量头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用信号量</span></span><br><span class="line"><span class="comment">编写生产者和消费者模型</span></span><br><span class="line"><span class="comment">总资源数为1的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者的信号量</span></span><br><span class="line"><span class="type">sem_t</span> semp;</span><br><span class="line"><span class="comment">//消费者信号量</span></span><br><span class="line"><span class="type">sem_t</span> semc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测生产者是否有资源</span></span><br><span class="line">        sem_wait(&amp;semp);<span class="comment">//资源&gt;0就不会被阻塞---生产者线程会占用一个资源-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newnode</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">//初始化节点</span></span><br><span class="line">        newnode-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        newnode-&gt;next = head;</span><br><span class="line">        head = newnode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者，id:%ld , number:%d\n&quot;</span>, (pthread_self() % <span class="number">100</span>), newnode-&gt;number);</span><br><span class="line">        <span class="comment">//通知消费者消费---消费者资源+1</span></span><br><span class="line">        sem_post(&amp;semc);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);<span class="comment">//休眠控制生产速度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//消费者尝试消费，若有资源则消费者资源-1</span></span><br><span class="line">        sem_wait(&amp;semc);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者，id:%ld , number:%d\n&quot;</span>, (pthread_self() % <span class="number">100</span>), node-&gt;number);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="comment">//通知生产者生产</span></span><br><span class="line">        sem_post(&amp;semp);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//初始化信号变量</span></span><br><span class="line">    <span class="comment">//1.生产者</span></span><br><span class="line">    sem_init(&amp;semp, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//生产者总共的资源数为1---&gt;则可同时工作的线程为1个</span></span><br><span class="line">    <span class="comment">//2.消费者 -&gt; 资源初始化为0 消费则线程启动就阻塞</span></span><br><span class="line">    sem_init(&amp;semc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建生产者消费者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> t1[<span class="number">5</span>], t2[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//创建生产者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;t1[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;t2[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程资源回收</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(t1[i], <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(t2[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁资源释放</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="comment">//信号量的销毁</span></span><br><span class="line">    sem_destroy(&amp;semp);</span><br><span class="line">    sem_destroy(&amp;semc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过测试代码可以得到如下结论：如果生产者和消费者使用的信号量总资源数为1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</p><p>运行结果</p><p>可以看到生产者与消费者交替运行</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312192221267.png" alt="image-20231219222122218"></p><h6 id="总资源数大于1"><a href="#总资源数大于1" class="headerlink" title="总资源数大于1"></a>总资源数大于1</h6><p>如果生产者和消费者线程使用的信号量对应的总资源数为大于1，这种场景下出现的情况就比较多了：</p><ul><li>多个生产者线程同时生产</li><li>多个消费者同时消费</li><li>生产者线程和消费者线程同时生产和消费</li></ul><p>以上不管哪一种情况都可能会出现多个线程访问共享资源的情况，如果想防止共享资源出现数据混乱，那么就需要使用互斥锁进行线程同步，线程线性执行任务 ，处理代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br></pre></td></tr></table></figure><p>在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure><p><strong>这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁</strong>，下面来分析一种死锁的场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，初始化状态下消费者线程没有任务信号量资源，假设某一个消费者线程先运行，调用<code>pthread_mutex_lock(&amp;mutex);</code>对互斥锁加锁成功，然后调用<code>sem_wait(&amp;csem);</code>由于没有资源，因此被阻塞了。其余的消费者线程由于没有抢到互斥锁，因此被阻塞在互斥锁上。对应生产者线程第一步操作也是调用<code>pthread_mutex_lock(&amp;mutex);</code>，但是这时候互斥锁已经被消费者线程锁上了，所有生产者都被阻塞，到此为止，多余的线程都被阻塞了，程序产生了死锁。</p><p><strong>完整代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号量头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用信号量</span></span><br><span class="line"><span class="comment">编写生产者和消费者模型</span></span><br><span class="line"><span class="comment">总资源数为5的情况---&gt;需要线程同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者的信号量</span></span><br><span class="line"><span class="type">sem_t</span> semp;</span><br><span class="line"><span class="comment">//消费者信号量</span></span><br><span class="line"><span class="type">sem_t</span> semc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测生产者是否有资源---是否有空闲的生产者线程</span></span><br><span class="line">        sem_wait(&amp;semp);<span class="comment">//资源&gt;0就不会被阻塞---生产者线程会占用一个资源-1</span></span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//上锁和sem_wait（）两句代码顺序不能乱</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newnode</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">//初始化节点</span></span><br><span class="line">        newnode-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        newnode-&gt;next = head;</span><br><span class="line">        head = newnode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者，id:%ld , number:%d\n&quot;</span>, (pthread_self() % <span class="number">100</span>), newnode-&gt;number);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//通知消费者消费---消费者资源+1</span></span><br><span class="line">        sem_post(&amp;semc);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);<span class="comment">//休眠控制生产速度</span></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//消费者尝试消费，若有资源则消费者资源-1（任务队列中是否有多余的任务）</span></span><br><span class="line">        sem_wait(&amp;semc);</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者，id:%ld , number:%d\n&quot;</span>, (pthread_self() % <span class="number">100</span>), node-&gt;number);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//通知生产者生产</span></span><br><span class="line">        sem_post(&amp;semp);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//初始化信号变量</span></span><br><span class="line">    <span class="comment">//1.生产者</span></span><br><span class="line">    sem_init(&amp;semp, <span class="number">0</span>, <span class="number">5</span>);<span class="comment">//生产者总共的资源数为5---&gt;为了不造成数据的混乱还是需要线程同步---&gt;需要互斥锁的帮助（锁在临界区）</span></span><br><span class="line">    <span class="comment">//2.消费者 -&gt; 资源初始化为0 消费则线程启动就阻塞</span></span><br><span class="line">    sem_init(&amp;semc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建生产者消费者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> t1[<span class="number">5</span>], t2[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//创建生产者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;t1[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;t2[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程资源回收</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(t1[i], <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(t2[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁资源释放</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="comment">//信号量的销毁</span></span><br><span class="line">    sem_destroy(&amp;semp);</span><br><span class="line">    sem_destroy(&amp;semc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与线程同步</title>
      <link href="/2023/12/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2023/12/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="多线程与线程同步"><a href="#多线程与线程同步" class="headerlink" title="多线程与线程同步"></a>多线程与线程同步</h2><p><a href="https://www.bilibili.com/video/BV1sv41177e4/?spm_id_from=333.999.0.0&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程：爱编程的大丙</a></p><p><a href="https://subingwen.cn/linux/thread/">视频文档地址：爱编程的大丙</a></p><h3 id="1-线程与进程区别"><a href="#1-线程与进程区别" class="headerlink" title="1.线程与进程区别"></a>1.线程与进程区别</h3><ul><li><p>进程由独立的地址空间，多个线程共用同一个地址空间</p><ul><li>在一个地址空间中多个线程<strong>独享</strong>：每个线程都有自己的栈区。寄存器</li><li>在一个地址空间中多个线程<strong>共享</strong>：代码段、堆区、全局数据区，打开的文件都是线程共享的</li></ul></li><li><p>线程是程序执行的最小单位，进程是操作系统中最小的资源分配单位</p><ul><li>每个进程对应一个虚拟地址空间，一个进程只能抢一个CPU时间片</li><li>一个地址空间中可以划分出多个线程，在有效的资源基础上，可以抢更多的CPU时间片</li></ul></li><li><p>CPU的调度与切换：线程的上下文切换比进程快</p><ul><li><strong>上下文切换：</strong> 进程\线程分时复用CPU时间片，在切换之前会将上一个任务的状态进行保存（状态存储在寄存器），下次切换回这个任务的时候(<strong>此时再次获得CPU资源-时间片</strong>)，加载这个状态继续运行，<strong>任务从保存到再次加载这个过程就是一次上下文切换</strong></li><li>线程更为廉价，启动&#x2F;退出速度更快，对系统资源冲击小</li></ul></li></ul><h3 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2.创建线程"></a>2.创建线程</h3><h4 id="2-1-线程函数"><a href="#2-1-线程函数" class="headerlink" title="2.1.线程函数"></a>2.1.线程函数</h4><p>每一个线程都有一个唯一的线程<code>ID</code>，<code>ID</code>类型为<code>pthread_t</code>,这个ID是一个<strong>无符号长整型数</strong>，通过以下函数获取当前线程<code>ID</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//返回当前线程ID</span></span><br></pre></td></tr></table></figure><p>在一个进程中调用线程创建函数，就可以得到一个子线程，和进程不同，<strong>需要给每一个线程指定一个处理函数</strong>否则线程无法工作.创建线程(<strong>实际上就是确定调用该线程函数的入口点</strong>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread，<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,<span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),<span class="type">void</span> *arg)</span></span><br><span class="line"><span class="comment">//compile and link with pthread,线程库名字为pthread</span></span><br><span class="line"><span class="comment">//LINUX中编译时，需要链接动态库pthread  C文件名 - lpthread -o 可执行文件名</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>参数：</strong></p><p><code>pthread </code>：传出参数，无符号长整型，线程创建成功，会将线程ID写入到这个指针指向的内存中</p><p><code>attr </code>: 线程的属性，一般情况写入默认值即可，NULL</p><p><code>start_routine </code>：函数指针，用于回调，指向的函数，就是在线程中需要执行的任务。即<strong>子线程运行函数</strong>。创建出子线程处理的动作</p><p>​该函数指针指向函数的参数为<code>void *</code>，因此可以将任意类型的参数传递给子线程执行的函数</p><p>​回调函数的类型应该为<code>void *</code>类型</p><p><code>arg </code>：子线程运行函数的参数。<strong>作为实参传递到start_routine指针指向的函数内部</strong></p><p><code>返回值</code>：0表示成功    -1表示失败</p></li></ul><h4 id="2-2实例"><a href="#2-2实例" class="headerlink" title="2.2实例"></a>2.2实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序执行逻辑:</span></span><br><span class="line"><span class="comment">1.main函数</span></span><br><span class="line"><span class="comment">2.主线程中创建子线程</span></span><br><span class="line"><span class="comment">3.执行主线程</span></span><br><span class="line"><span class="comment">4.执行子线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程执行任务的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程:i = %d\n&quot;</span>,i);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程：%ld\n&quot;</span>,pthread_self());</span><br><span class="line"><span class="comment">//pthread_self()返回当前线程ID---长整型</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pthread_t</span> tid;      <span class="comment">//子线程的线程ID</span></span><br><span class="line">pthread_create(&amp;tid,<span class="literal">NULL</span>,callback,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;主线程：i = %d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;主线程：%ld\n&quot;</span>,pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Linux中编译，需要连接pthread动态库:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc pthrad_create.c -lpthread -o app</span><br><span class="line">执行：</span><br><span class="line">    ./app</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312142204556.png" alt="image-20231214220441534"></p><p><strong>结果分析：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以发现此时并没有执行子线程：</span><br><span class="line">    子线程被创建之后，运行需要抢CPU时间片，在子线程没有抢到CPU时间片之前，主线程以及执行完毕----将地址空间释放</span><br><span class="line">    此时子线程就无法在地址空间执行</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><ul><li><pre><code class="C">#include &lt;usistd.h&gt;//main函数中return 0前添加sleep(3)函数;    //让主线程等一会--主线程放弃CPU资源<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```C</span><br><span class="line">  //修改代码：</span><br><span class="line">  #include&lt;stdio.h&gt;</span><br><span class="line">  #include&lt;stdlib.h&gt;</span><br><span class="line">  #include&lt;pthread.h&gt;</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">  程序执行逻辑:</span><br><span class="line">  1.main函数</span><br><span class="line">  2.主线程中创建子线程</span><br><span class="line">  3.执行主线程</span><br><span class="line">  4.执行子线程</span><br><span class="line">  */</span><br><span class="line">  </span><br><span class="line">  //子线程执行任务的回调函数</span><br><span class="line">  void* callback(void *arg)</span><br><span class="line">  &#123;</span><br><span class="line">  for (int i = 0; i &lt; 5; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  printf(&quot;子线程:i = %d\n&quot;,i);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;子线程：%ld\n&quot;,pthread_self());</span><br><span class="line">  //pthread_self()返回当前线程ID---长整型</span><br><span class="line">  return NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int main(void)</span><br><span class="line">  &#123;</span><br><span class="line">  pthread_t tid;      //子线程的线程ID</span><br><span class="line">  pthread_create(&amp;tid,NULL,callback,NULL);</span><br><span class="line">  for (int i = 0;i&lt;5;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  printf(&quot;主线程：i = %d\n&quot;,i);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;主线程：%ld\n&quot;,pthread_self());</span><br><span class="line">  sleep(3);   //主线程休眠3s</span><br><span class="line">      // 退出进程</span><br><span class="line">  exit(0);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>方案一执行结果：</strong></p></li></ul><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312142206700.png" alt="image-20231214220644673"></p><h3 id="3-线程退出"><a href="#3-线程退出" class="headerlink" title="3.线程退出"></a>3.线程退出</h3><p>线程退出函数，主要使用在主线程里。若想要线程退出，但是不会导致虚拟地址空间的释放(针对主线程),就可以调用线程库中的线程退出函数<br>（<strong>调用该函数，当前线程就会立马退出，不会影响其他线程的执行，在子线程或者主线程都可以使用</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数<code>retval</code></p><p>线程退出时携带的数据，当前子线程的主线程会得到该数据，若不需要，指定为NULL</p></li><li><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程执行任务的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程:i = %d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程：%ld\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="comment">//pthread_self()返回当前线程ID---长整型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;      <span class="comment">//子线程的线程ID</span></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,callback,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功,线程ID：%ld\n&quot;</span>,tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程ID：%ld\n&quot;</span>,ptherad_self());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主线程：i = %d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);   <span class="comment">//线程退出函数，退出主线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>运行结果，主线程退出后，子线程仍然可以继续运行,每次执行的顺序会不一样这取决于CPU系统的调度</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312142213981.png" alt="image-20231214221309944"></p><h3 id="4-线程回收"><a href="#4-线程回收" class="headerlink" title="4.线程回收"></a>4.线程回收</h3><h4 id="4-1线程函数"><a href="#4-1线程函数" class="headerlink" title="4.1线程函数"></a>4.1线程函数</h4><p>线程与进程相似，子线程退出时其内核资源主要由主线程回收，线程库中提供的线程回收函数：<code>phread_join()</code>，该函数是一个<strong>阻塞函数</strong></p><p>（若子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源回收，函数被调用一次，只能回收一个子线程，如果多个子线程则需要进行循环回收）</p><ul><li><p><strong>通过线程回收函数还可以获得子线程退出时传递出来的数据</strong></p></li><li><pre><code class="c">#include &lt;pthread.h&gt;int pthread_join(pthread_t thread,void **retval)    //这是一个阻塞函数，子线程在运行该函数就会阻塞    //子线程退出，函数解除阻塞，回收对应子线程资源<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* **参数：**</span><br><span class="line"></span><br><span class="line">  * thread : 要被回收的子线程的线程ID</span><br><span class="line">  * retval : 二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了`pthread_exit()`传递出的数据，若不需要该参数可以指定为NULL</span><br><span class="line"></span><br><span class="line">* **返回值：**</span><br><span class="line"></span><br><span class="line">  * 线程回收成功返回0，回收失败返回错误号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 4.2回收子线程数据</span><br><span class="line"></span><br><span class="line">##### 4.2.1定义全局/静态变量</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">struct Test</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//子线程执行任务的回调函数</span><br><span class="line">void* callback(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;子线程:i = %d\n&quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;子线程：%ld\n&quot;,pthread_self());</span><br><span class="line"></span><br><span class="line">    struct Test t;</span><br><span class="line">    t.num = 100;</span><br><span class="line">    t.age = 6;</span><br><span class="line">    //线程退出</span><br><span class="line">    pthread_exit(&amp;t);//将结构体地址传给pthread_exit中的指针参数</span><br><span class="line">    //将该数据通过线程退出函数传递出去</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid;      //子线程的线程ID</span><br><span class="line">    pthread_create(&amp;tid,NULL,callback,NULL);</span><br><span class="line">    printf(&quot;主线程：%ld\n&quot;,pthread_self());</span><br><span class="line"></span><br><span class="line">    //定义一个一级指针，用于指向线程tid传递出的数据</span><br><span class="line">    void *ptr;</span><br><span class="line">    //pthread_join()参数为一个二级指针，用于指向，上面的一级指针,二级指针变量存储的是一级指针的地址</span><br><span class="line">    pthread_join(tid,&amp;ptr);</span><br><span class="line">    //此时一级指针ptr指向子线程退出时，传回数据的地址</span><br><span class="line">    struct Test *pt = (struct Test *) ptr;</span><br><span class="line">    printf(&quot;子线程age:%d\n&quot;,pt-&gt;age);</span><br><span class="line">    printf(&quot;子线程num:%d\n&quot;, pt-&gt;num);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><strong>Linux中运行结果：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ggc pt.c -lpthread -o app</span><br><span class="line">./app</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312142223170.png" alt="image-20231214222320116"></p><p><strong>结果分析：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此时的结果，在主线程中打印，子线程退出时，传回的数据，并没有我们预期的结果</span><br><span class="line">    ptr指针，指向的是，子线程传出的数据地址，该地址是子线程的一块（局部变量）栈内存，该块栈内存，被多个线程平均分成若干份占用，但是一个子线程退出，就会将该块内存退还，那么此时内存里的资源也会被释放。</span><br></pre></td></tr></table></figure><p><strong>代码修改：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将回调函数中：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"><span class="comment">//修改为：</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span><span class="comment">//静态变量存放在数据段，其生命周期为程序的执行周期   或者使得struct Test t为全局变量</span></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312142224763.png" alt="image-20231214222423727"></p><h5 id="4-2-2使用子线程栈"><a href="#4-2-2使用子线程栈" class="headerlink" title="4.2.2使用子线程栈"></a>4.2.2使用子线程栈</h5><p>通过函数 <code>pthread_exit()</code>; 可以得知，子线程退出的时候，需要将数据记录到一块内存中，通过参数传出的是存储数据的内存的地址，而不是具体数据，由因为参数是 void* 类型，所有这个万能指针可以指向任意类型的内存地址。先来看第一种方式，将子线程退出数据保存在子线程自己的栈区：</p><p><strong>实例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_join.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">            p.age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 代码执行不到这个位置就退出了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程返回数据: name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>编译并且执行测试代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 编译代码</span><br><span class="line">$ gcc pthread_join.c -lpthread</span><br><span class="line"># 执行程序</span><br><span class="line">$ ./a.out </span><br><span class="line">子线程创建成功, 线程ID: <span class="number">140652794640128</span></span><br><span class="line">我是主线程, 线程ID: <span class="number">140652803008256</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">我是子线程, 线程ID: <span class="number">140652794640128</span></span><br><span class="line">child == i: = <span class="number">0</span></span><br><span class="line">child == i: = <span class="number">1</span></span><br><span class="line">child == i: = <span class="number">2</span></span><br><span class="line">child == i: = <span class="number">3</span></span><br><span class="line">child == i: = <span class="number">4</span></span><br><span class="line">child == i: = <span class="number">5</span></span><br><span class="line">child == i: = <span class="number">6</span></span><br><span class="line">子线程返回数据: name: , age: <span class="number">0</span>, id: <span class="number">0</span></span><br><span class="line">子线程资源被成功回收...</span><br></pre></td></tr></table></figure><p><strong>结果分析：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过打印的日志可以发现，在主线程中没有没有得到子线程返回的数据信息，具体原因是这样的：</span><br><span class="line"></span><br><span class="line">如果多个线程共用同一个虚拟地址空间，每个线程在栈区都有一块属于自己的内存，相当于栈区被这几个线程平分了，当线程退出，线程在栈区的内存也就被回收了，因此随着子线程的退出，写入到栈区的数据也就被释放了。</span><br><span class="line"></span><br><span class="line">因此在主线程中无法成功的将子线程中栈区的数据成功打印出来</span><br></pre></td></tr></table></figure><h5 id="4-2-3使用主线程栈"><a href="#4-2-3使用主线程栈" class="headerlink" title="4.2.3使用主线程栈"></a>4.2.3使用主线程栈</h5><p>虽然每个线程都有属于自己的栈区空间，但是位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的。由于很多情况下还需要在主线程中回收子线程资源，所以主线程一般都是最后退出，基于这个原因在下面的程序中将子线程返回的数据保存到了主线程的栈区内存中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码---指针函数---回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">p</span> =</span> (<span class="keyword">struct</span> Persion*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用主线程的栈内存</span></span><br><span class="line">            p-&gt;age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p-&gt;id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">// 主线程的栈内存传递给子线程</span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, p.name, p.age, p.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果，发现子线程中对主线程栈区更新的数据成功打印出来了。</p><p>因为即使子线程退出了，但是并不影响主线程栈区的数据</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312142231689.png" alt="image-20231214223148660"></p><h3 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5.线程分离"></a>5.线程分离</h3><p>在某些情况下，程序中的主线程有属于自己的业务处理流程，若让主线程负责子线程的资源回收，调用<code>pthread_join() </code>只要子线程不退出主线程就会一直阻塞，主线程的任务就不能被执行。</p><p>线程分离函数：<code>pthread_detach()</code>函数，调用这个函数之后指定的<strong>子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并且回收(为主线程减负)。</strong>线程分离之后在主线程中使用pthread_join()就无法回收到子线程的资源</p><p><strong>线程分离函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p><strong>实例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程执行任务的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程:i = %d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程：%ld\n&quot;</span>,pthread_self());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pthread_t</span> tid;      <span class="comment">//子线程的线程ID</span></span><br><span class="line">pthread_create(&amp;tid,<span class="literal">NULL</span>,callback,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;主线程：%ld\n&quot;</span>,pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程分离---在回调函数中执行子线程退出后，会有其他系统线程来负责回收子线程资源（不用主线程负责）</span></span><br><span class="line">pthread_detach(tid);</span><br><span class="line"><span class="comment">//主线程退出</span></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>编译运行结果</strong>：</p><p>虽然子线程进行分离之后，不要在主线程进行子线程的资源回收，但是当子线程还在运行的时候，主线程提前exit退出了，内存地址空间都不存在了，子线程也不会存在。</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312152156197.png" alt="image-20231215215651154"></p><h3 id="6-其他线程函数"><a href="#6-其他线程函数" class="headerlink" title="6.其他线程函数"></a>6.其他线程函数</h3><h4 id="6-1线程取消"><a href="#6-1线程取消" class="headerlink" title="6.1线程取消"></a>6.1线程取消</h4><p>其含义是：在某些特定情况下在一个线程中杀死另外一个线程，使用这个函数杀死一个线程分<strong>两步：</strong></p><ul><li>在线程 A 中调用线程取消函数 pthread_cancel，指定杀死线程 B，这时候线程 B 是死不了的</li><li>在<strong>线程 B 中进行一次系统调用</strong>（从用户区切换到内核区），否则线程 B 可以一直运行。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数是子线程的线程ID</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数：</strong>要杀死的线程的线程 ID</p></li><li><p>返回值：函数调用成功返回 0，调用失败返回非 0 错误号。</p></li></ul><p><strong>实例代码：</strong></p><p>示例代码中，主线程调用线程取消函数，只要在子线程中进行了系统调用，当子线程执行到这个位置就挂掉了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程处理函数--回调函数--指针函数（因为pthread_create()中回调函数的参数，是void *类型）</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">callback</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf()函数会调用系统函数，因此该函数会间接的系统调用（满足线程取消的情况）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程ID:%ld\n&quot;</span>,pthread_self());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child i:%ld\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建子线程</span></span><br><span class="line"><span class="type">pthread_t</span> tid;<span class="comment">//定义子线程ID--长整形</span></span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功，线程ID：%ld\n&quot;</span>,tid);</span><br><span class="line"><span class="comment">//2.主线程执行下边代码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是主线程，线程ID:%ld&quot;</span>,pthread_self());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//杀死子线程---若子线程中出现系统调用，子线程就结束</span></span><br><span class="line">pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程退出</span></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以发现，主线程任务执行后，调用pthread_cancel()函数，杀死子进程，在子进程的第一个<span class="keyword">for</span>循环，此时还不存在系统调用，但是当子线程中执行到<span class="built_in">printf</span>(<span class="string">&quot;子线程ID:%ld\n&quot;</span>,pthread_self());后此时<span class="built_in">printf</span>调用了系统函数，在子线程间接进行了系统调用，成功杀死子进程，子进程第二个<span class="keyword">for</span>打印<span class="built_in">printf</span>(<span class="string">&quot;child i:%ld\n&quot;</span>,i)就不再执行。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312152201267.png" alt="image-20231215220154221"></p><p><strong>系统调用的方式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>直接调用 Linux 系统函数</span><br><span class="line"><span class="number">2.</span>调用标准 C 库函数，为了实现某些功能，在 Linux 平台下标准 C 库函数会调用相关的系统函数</span><br></pre></td></tr></table></figure><h4 id="6-2线程ID比较"><a href="#6-2线程ID比较" class="headerlink" title="6.2线程ID比较"></a>6.2线程ID比较</h4><p>在Linux系统中线程ID本身就是一个无符号长整形，因此可以直接使用比较操作符比较两个线程ID，但是线程库是可以跨平台使用的，在某些平台上pthread_t可能不是一个单纯的整型，这种情况比较两个线程ID必须使用比较函数；</p><p><strong>比较函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数：</strong>t1 和 t2 是要比较的线程的线程 ID</li><li>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</li></ul><h3 id="7-线程同步"><a href="#7-线程同步" class="headerlink" title="7.线程同步"></a>7.线程同步</h3><p>假设有 4 个线程 A、B、C、D，当前一个线程 A 对内存中的共享资源进行访问的时候，其他线程 B, C, D 都不可以对这块内存进行操作，直到线程 A 对这块内存访问完毕为止，B，C，D 中的一个才能访问这块内存，剩余的两个需要继续阻塞等待，以此类推，直至所有的线程都对这块内存操作完毕。 线程对内存的这种访问方式就称之为线程同步，通过对概念的介绍，我们可以了解到所谓的<strong>同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的。</strong></p><h4 id="7-1为什么要线程同步"><a href="#7-1为什么要线程同步" class="headerlink" title="7.1为什么要线程同步"></a>7.1为什么要线程同步</h4><p>在研究线程同步之前，先来看一个两个线程交替数数（每个线程数 50 个数，交替数到 100）的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程A处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">funA_num</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = number;</span><br><span class="line">cur++;</span><br><span class="line">number = cur;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Thread A,id = %ld,number = %d\n&quot;</span>,pthread_self(),number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">funB_num</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = number;</span><br><span class="line">cur++;</span><br><span class="line">number = cur;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Thread B,id = %ld,number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line"><span class="comment">//休眠5s</span></span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建两个子线程</span></span><br><span class="line">pthread_create(&amp;p1,<span class="literal">NULL</span>,funA_num,<span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;p2, <span class="literal">NULL</span>, funB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞，资源回收</span></span><br><span class="line">pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码结果：</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312191932926.png" alt="image-20231219193211879"></p><p><strong>结果分析：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过对上面例子的测试，可以看出虽然每个线程内部循环了 <span class="number">50</span> 次每次数一个数，但是最终没有数到 <span class="number">100</span>(最后还是数到了<span class="number">100</span>)，通过输出的结果可以看到，有些数字被重复数了多次，其原因就是没有对线程进行同步处理，造成了数据的混乱。</span><br><span class="line">    </span><br><span class="line">在测试程序中两个线程共用全局变量 number 当线程变成运行态之后开始数数，从物理内存加载数据，让后将数据放到 CPU 进行运算，最后将结果更新到物理内存中。如果数数的两个线程都可以顺利完成这个流程，那么得到的结果肯定是正确的。</span><br><span class="line"></span><br><span class="line">如果线程 A 执行这个过程期间就失去了 CPU 时间片，线程 A 被挂起了最新的数据没能更新到物理内存。线程 B 变成运行态之后从物理内存读数据，很显然它没有拿到最新数据，只能基于旧的数据往后数，然后失去 CPU 时间片挂起。线程 A 得到 CPU 时间片变成运行态，第一件事儿就是将上次没更新到内存的数据更新到内存，但是这样会导致线程 B 已经更新到内存的数据被覆盖，活儿白干了，最终导致有些数据会被重复数很多次。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>两个线程在数数的时候需要分时复用CPU时间片，并且测试程序中嗲用sleep()导致线程的CPU时间片没用完就被<strong>挂起，这让CPU的上下文切换（保存当前状态，下一次运行时，需要加载保存的状态）更为频繁</strong>。更容易造成数据混乱的现象</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312191933219.png" alt="image-20231219193307167"></p><p>CPU 对应寄存器、一级缓存、二级缓存、三级缓存是独占的，用于存储处理的数据和线程的状态信息，数据被 CPU 处理完成需要再次被写入到物理内存中，物理内存数据也可以通过文件 IO 操作写入到磁盘中。</p></li></ul><h4 id="7-2同步方式"><a href="#7-2同步方式" class="headerlink" title="7.2同步方式"></a>7.2同步方式</h4><p>对于多个线程访问共享资源出现数据混乱的问题，需要进行线程同步。常用的线程同步方式有四种：<strong>互斥锁、读写锁、条件变量、信号量</strong>。所谓的<strong>共享资源</strong>就是多个线程共同访问的变量，这些变量通常为<strong>全局数据区变量或者堆区变量</strong>，这些变量对应的共享资源也被称之为<strong>临界资源</strong>。</p><ul><li><strong>临界资源：</strong>找全局变量</li></ul><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312191933056.png" alt="image-20231219193326014"></p><p>找到临界资源之后，再找和临界资源相关的上下文代码，这样就得到了一个代码块，这个代码块可以称之为临界区。确定好临界区（临界区越小越好）之后，就可以进行线程同步了，<strong>线程同步的大致处理思路是这样的：</strong></p><ul><li>在临界区代码的上边，添加加锁函数，对临界区加锁。<ul><li>哪个线程调用这句代码，就会把这把锁锁上，其他线程就只能阻塞在锁上了。</li></ul></li><li>在临界区代码的下边，添加解锁函数，对临界区解锁。<ul><li>出临界区的线程会将锁定的那把锁打开，其他抢到锁的线程就可以进入到临界区了。</li></ul></li><li>通过锁机制能<strong>保证临界区代码最多只能同时有一个线程访问</strong>，这样并行访问就变为串行访问了</li></ul><h3 id="8-互斥锁"><a href="#8-互斥锁" class="headerlink" title="8.互斥锁"></a>8.互斥锁</h3><h4 id="8-1互斥锁函数"><a href="#8-1互斥锁函数" class="headerlink" title="8.1互斥锁函数"></a>8.1互斥锁函数</h4><p>互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块，被锁定的这个代码块，所有的线程只能顺序执行 (不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要<strong>付出的代价就是执行效率的降低，因为默认临界区多个线程是可以并行处理的，现在只能串行处理</strong></p><hr><p>在Linux中互斥锁的类型为<code>pthread_mutex_t</code>，创建一个这种类型的变量就得到了一把互斥锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br></pre></td></tr></table></figure><ul><li>在创建的锁对象中保存了当前这把锁的状态信息：锁定还是打开，如果是锁定状态还记录了给这把锁加锁的线程信息（线程 ID）。<strong>一个互斥锁变量只能被一个线程锁定，被锁定之后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁</strong>，被阻塞的线程才能被解除阻塞。一般情况下，<strong>每一个共享资源对应一个把互斥锁，锁的个数和线程的个数无关。</strong></li></ul><p><strong>互斥锁函数操作原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化互斥锁</span></span><br><span class="line"><span class="comment">//restrict:是一个关键字，用于修饰指针，只有这个关键词修饰的指针可以访问指向的内存地址，其他指针，无法访问</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">//释放互斥锁资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数：</strong><ul><li>mutex : 互斥锁变量的地址</li><li>attr : 互斥锁属性，一般默认即可，这个参数指定为NULL</li></ul></li><li>返回值：<ul><li>如果函数调用成功会返回 0，调用失败会返回相应的<strong>错误号</strong></li></ul></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>这个函数被调用，首先会判断参数 mutex 互斥锁中的状态是不是锁定状态:</p><ul><li>没有被锁定，是打开的，这个线程可以加锁成功，这个<strong>这个锁中会记录是哪个线程加锁成功了</strong></li><li>如果被锁定了，其他线程加锁就失败了，这些线程都会阻塞在这把锁上</li><li>当这把锁被解开之后，这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数对互斥锁变量加锁还是有两种情况:</p><ul><li>如果这把锁没有被锁定是打开的，线程加锁成功</li><li>如果锁变量被锁住了，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对互斥锁解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>不是所有的线程都可以对互斥锁解锁，哪个线程加的锁，哪个线程才能解锁成功。</strong></li></ul><h4 id="8-2互斥锁的使用"><a href="#8-2互斥锁的使用" class="headerlink" title="8.2互斥锁的使用"></a>8.2互斥锁的使用</h4><p>将7.1代码进行修改，两个线程操作同一个<strong>全局变量</strong>，<code>number</code>，因此需要添加一把互斥锁，来控制两个线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一把互斥锁</span></span><br><span class="line"><span class="comment">//全局变量，多个线程共享</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程A处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">funA_num</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//若线程A加锁成功，线程A不阻塞</span></span><br><span class="line">    <span class="comment">//若线程B加锁成功，线程A阻塞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A,id = %ld,number = %d\n&quot;</span>,pthread_self(),number);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// return NULL;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">funB_num</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a加锁成功, b线程访问这把锁的时候是锁定的</span></span><br><span class="line">        <span class="comment">//线程B先阻塞, a线程解锁之后阻塞解除</span></span><br><span class="line">        <span class="comment">//线程B加锁成功了</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);<span class="comment">//10us--可以不加---使得线程休眠</span></span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B,id = %ld,number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// return NULL;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1,<span class="literal">NULL</span>,funA_num,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费互斥锁</span></span><br><span class="line">    <span class="comment">//线程销毁后，释放互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>线程A\B一起数数到了100，但是并非完全交替数数,因为多个线程抢占CPU是随机的是一个<strong>概率问题</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312191939491.png" alt="image-20231219193939447"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312191940441.png" alt="image-20231219194009400"></p><h4 id="8-3死锁"><a href="#8-3死锁" class="headerlink" title="8.3死锁"></a>8.3死锁</h4><p>当多个线程访问共享资源，需要加锁，如果锁使用不当，就会造成死锁这种现象。如果线程死锁造成的后果是:所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p><hr><p>造成死锁的场景有如下几种：</p><ul><li><p>加锁之后忘记解锁</p><ul><li><pre><code class="c">// 场景1void func()&#123;    for(int i=0; i&lt;6; ++i)    &#123;        // 当前线程A加锁成功, 当前循环完毕没有解锁, 在下一轮循环的时候自己被阻塞了        // 其余的线程也被阻塞        pthread_mutex_lock(&amp;mutex);        ....        .....        // 忘记解锁    &#125;&#125;// 场景2void func()&#123;    for(int i=0; i&lt;6; ++i)    &#123;        // 当前线程A加锁成功        // 其余的线程被阻塞        pthread_mutex_lock(&amp;mutex);        ....        .....        if(xxx)        &#123;            // 函数退出, 没有解锁（解锁函数无法被执行了）            return ;        &#125;                pthread_mutex_lock(&amp;mutex);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 重复加锁，造成死锁</span><br><span class="line"></span><br><span class="line">  * ```c</span><br><span class="line">    void func()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0; i&lt;6; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            // 当前线程A加锁成功</span><br><span class="line">            // 其余的线程阻塞</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">            // 锁被锁住了, A线程阻塞</span><br><span class="line">            pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        ....</span><br><span class="line">        .....</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 隐藏的比较深的情况</span><br><span class="line">    void funcA()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0; i&lt;6; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            // 当前线程A加锁成功</span><br><span class="line">            // 其余的线程阻塞</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        ....</span><br><span class="line">        .....</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void funcB()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0; i&lt;6; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            // 当前线程A加锁成功</span><br><span class="line">            // 其余的线程阻塞</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">            funcA();//在函数B中调用函数A 重复加锁</span><br><span class="line">        ....</span><br><span class="line">        .....</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>在程序中有多个共享资源，因此有很多把锁，随意加锁，导致相互被阻塞</p><p>场景描述:</p><p>1.有两个共享资源:X, Y，X对应锁A, Y对应锁B</p><p>​线程A访问资源X, 加锁A</p><p>​线程B访问资源Y, 加锁B</p><p>2.线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞</p><p>​线程A被锁B阻塞了, 无法打开A锁</p><p>​线程B被锁A阻塞了, 无法打开B锁</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312191945680.png" alt="image-20231219194515636"></p></li><li><p><strong>避免死锁</strong></p><p>避免多次锁定，多检查</p><p>对共享资源访问完毕之后，一定要解锁，或者在加锁的使用 <code>trylock</code></p><p>如果程序中有多把锁，可以控制对锁的访问顺序 (顺序访问共享资源，但在有些情况下是做不到的)，另外也可以在对其他互斥锁做加锁操作之前，先释放当前线程拥有的互斥锁。</p><p>项目程序中可以引入一些专门用于死锁检测的模块</p></li></ul><h3 id="9-读写锁"><a href="#9-读写锁" class="headerlink" title="9.读写锁"></a>9.读写锁</h3><p><strong>读写锁是互斥锁的升级版</strong>，在做<strong>读操作的时候可以提高程序的执行效率</strong>，如果所有的线程都是做读操作, 那么读是并行的，但是使用互斥锁，读操作也是串行的。</p><p><strong>使用读写锁</strong>   读：并行    写：串行</p><p><strong>读写锁是一把锁</strong>，锁的类型为 <code>pthread_rwlock_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">//创建一把读写锁</span></span><br></pre></td></tr></table></figure><p>读写锁可以做两件事情，既可以锁定<strong>读操作</strong>，可以锁定<strong>写操作</strong></p><hr><p>以下是<strong>读写锁中记录的信息</strong>：</p><ul><li>锁的状态：锁定 &#x2F; 打开</li><li>锁定的是什么操作：读操作 &#x2F; 写操作，<strong>使用读写锁锁定了读操作，需要先解锁才能去锁定写操作，反之亦然。</strong></li><li>哪个线程将这把锁锁上了</li></ul><hr><p>读写锁的使用方式也互斥锁的使用方式是完全相同的：<strong>找共享资源，确定临界区，在临界区的开始位置加锁（读锁 &#x2F; 写锁），临界区的结束位置解锁</strong>。</p><p><strong>读写锁的特点：</strong></p><ul><li>使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，<strong>读锁是共享的。</strong></li><li>使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，<strong>写锁是独占的（与互斥锁一样）。</strong></li><li>使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问者两个临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为<strong>写锁比读锁的优先级高。</strong></li></ul><hr><hr><p><strong>读写锁函数操作原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数</strong>：</p><p><code>rwlock</code>: 读写锁的地址，传出参数</p><p><code>attr</code>: 读写锁属性，一般使用默认属性，指定为 NULL</p></li><li><p>返回值：</p><p>如果函数调用成功返回 0，失败返回对应的错误号</p></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加读锁, 锁定的是读操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为<strong>读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞</strong>。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加写锁, 锁定的是写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；<strong>如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数的线程会被阻塞</strong>。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p><hr><p><strong>解锁：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h4 id="9-1读写锁的使用"><a href="#9-1读写锁的使用" class="headerlink" title="9.1读写锁的使用"></a>9.1读写锁的使用</h4><p>题目要求：8 个线程操作同一个全局变量，3 个线程不定时写同一全局资源，5 个线程不定时读同一全局资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义读写锁</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写的线程的处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//添加写锁</span></span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur ++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++写操作完毕, number : %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">// 添加sleep目的是要看到多个线程交替工作</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// return NULL;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程的处理函数</span></span><br><span class="line"><span class="comment">// 多个线程可以如果处理动作相同, 可以使用相同的处理函数</span></span><br><span class="line"><span class="comment">// 每个线程中的栈资源是独享</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//添加读锁</span></span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--全局变量number = %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// return NULL;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化读写锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3个写线程, 5个读的线程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">pthread_t</span> rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源---线程回收</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(wtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(rtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p>读操作可以并行。但是写操作只能串行，每次写操作造成<code>number</code>均会变化，实现线程同步</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312192004798.png" alt="image-20231219200451747"></p><h3 id="10-条件变量"><a href="#10-条件变量" class="headerlink" title="10.条件变量"></a>10.条件变量</h3><h4 id="10-1条件变量函数"><a href="#10-1条件变量函数" class="headerlink" title="10.1条件变量函数"></a>10.1条件变量函数</h4><p>严格意义上来说，<strong>条件变量的主要作用不是处理线程同步，而是进行线程的阻塞</strong>。如果在多线程程序中只使用条件变量无法实现线程的同步，必须要配合互斥锁来使用。虽然条件变量和互斥锁都能阻塞线程，但是二者的效果是不一样的，二者的区别如下：</p><ul><li>假设有 A-Z 26 个线程，这 26 个线程共同访问同一把互斥锁，如果线程 A 加锁成功，那么其余 B-Z 线程访问互斥锁都阻塞，所有的线程只能顺序访问临界区</li><li>条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱。</li></ul><hr><p>一般情况下条件变量用于处理生产者和消费者模型，并且和互斥锁配合使用。条件变量类型对应的类型为<code>pthread_cond_t</code>，这样就可以定义一个条件变量类型的变量了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;<span class="comment">//定义一个条件变量类型的变量</span></span><br></pre></td></tr></table></figure><p><strong>被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用</strong>。</p><hr><p><strong>条件变量操作原型如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>cond</code>: 条件变量的地址</li><li><code>attr</code>: 条件变量属性，一般使用默认属性，指定为 NULL</li></ul><hr><p><strong>线程阻塞函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><p>通过函数原型可以看出，该函数在阻塞线程的时候，需要一个互斥锁参数，这个互斥锁主要功能是进行线程同步，让线程顺序进入临界区，避免出现数共享资源的数据混乱。该函数会对这个互斥锁做以下几件事情：</p><ul><li>在阻塞线程时候，如果线程已经对互斥锁 <code>mutex </code>上锁，那么会将这把锁打开，这样做是为了避免死锁</li><li>当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个<code>mutex</code>互斥锁锁上，继续向下访问临界区</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后(超时设置), 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的前两个参数和 <code>pthread_cond_wait </code>函数是一样的，第三个参数表示线程阻塞的时长，但是需要额外注意一点：<code>struct timespec </code>这个结构体中记录的时间是从1971.1.1到某个时间点的时间，总长度使用秒&#x2F;纳秒表示。因此赋值方式相对要麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> mytim = time(<span class="literal">NULL</span>);<span class="comment">// 1970.1.1 0:0:0 到当前的总秒数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tmsp</span>;</span></span><br><span class="line">tmsp.tv_nsec = <span class="number">0</span>;</span><br><span class="line">tmsp.tv_sec = time(<span class="literal">NULL</span>) + <span class="number">100</span>;<span class="comment">// 线程阻塞100s</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>调用上面两个函数中的任意一个，都可以换线被 <code>pthread_cond_wait</code> 或者<code>pthread_cond_timedwait</code>阻塞的线程，区别就在于 <code>pthread_cond_signal </code>是唤醒至少一个被阻塞的线程（总个数不定），<code>pthread_cond_broadcast </code>是唤醒所有被阻塞的线程。</p><h4 id="10-2生产者和消费者"><a href="#10-2生产者和消费者" class="headerlink" title="10.2生产者和消费者"></a>10.2生产者和消费者</h4><p>生产者和消费者模型的组成：</p><ul><li><p><strong>生产者线程-&gt;若干个</strong></p><p>生产商品或者任务放入到任务队列中</p><p>任务队列满了就阻塞，不满的时候就工作</p><p>通过一个生产者的条件变量控制生产者线程阻塞和非阻塞</p></li><li><p><strong>消费者线程-&gt;若干个</strong></p><p>读任务队列，将任务或者数据取出</p><p>任务队列中有数据就消费，没有数据就阻塞</p><p>通过一个消费者的条件变量控制消费者线程阻塞和非阻塞</p></li><li><p>队列 -&gt; 存储任务 &#x2F; 数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存</p><p>可以是数组、链表，也可以使用 <code>stl </code>容器：<code>queue /stack/list/vector</code></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312192051244.png" alt="image-20231219205133201"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">场景描述：使用条件变量实现生产者和消费者模型，生产者有 <span class="number">5</span> 个，往链表头部添加节点，消费者也有 <span class="number">5</span> 个，删除链表头部的节点</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">// 后驱指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 定义互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建链表的头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建新的链表节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// 头节点指针指向新添加的节点</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, (pthread_self() % <span class="number">100</span>));</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line">        <span class="comment">// 生产了任务, 通知消费者消费</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 任务队列中已经没有节点可以进行消费了</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1.调用该函数使得消费者线程在此处进行阻塞</span></span><br><span class="line">            <span class="comment">// 2.消费者线程在59行添加互斥锁成功，但是线程阻塞在这行代码上面，锁还没有解开</span></span><br><span class="line">            <span class="comment">// 3.消费者所有线程在访问这把锁的时均会阻塞,生产者也会阻塞 ==&gt; 如果不使用pthread_cond_wait函数则会造成死锁</span></span><br><span class="line">            <span class="comment">// 4.pthread_cond_wait函数会自动将线程拥有的锁解开， ==&gt; 避免死锁</span></span><br><span class="line">            <span class="comment">// 5.消费者解开锁之后，生产者就可以继续加锁进行生产</span></span><br><span class="line">            <span class="comment">// 6.当任务队列又有节点可以进行消费时，消费者通过函数pthread_cond_broadcast解除消费者阻塞</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="comment">// 7.当消费者线程解除阻塞之后, 会自动将这把锁锁上</span></span><br><span class="line">            <span class="comment">// 8.这时候当前这个线程又重新拥有了这把互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出任务队列中的头节点进行消费</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, (pthread_self() % <span class="number">100</span>));</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源--线程回收</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 一直消费, 删除链表中的一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)   <span class="comment">// 这样写有bug</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么在第7行使用if 有bug:</span></span><br><span class="line"><span class="comment">    当任务队列为空, 所有的消费者线程都会被这个函数阻塞 pthread_cond_wait(&amp;cond, &amp;mutex);</span></span><br><span class="line"><span class="comment">    也就是阻塞在代码的第9行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当生产者生产了1个节点, 调用 pthread_cond_broadcast(&amp;cond); 唤醒了所有阻塞的线程</span></span><br><span class="line"><span class="comment">      - 有一个消费者线程通过 pthread_cond_wait()加锁成功, 其余没有加锁成功的线程继续阻塞</span></span><br><span class="line"><span class="comment">      - 加锁成功的线程向下运行, 并成功删除一个节点, 然后解锁</span></span><br><span class="line"><span class="comment">      - 没有加锁成功的线程解除阻塞继续抢这把锁, 若又一个子线程加锁成功</span></span><br><span class="line"><span class="comment">      - 但是这个任务链表中的节点已经为上一个消费者给删除了此时链表中又为NUll,因为if(head == NULL)只进行了一次判断，这个时候链表为NULL，但是已经不会重新回到上面进行判断 ，后边访问这个空的任务队列并对其进行节点删除的时候就会出现段错误</span></span><br><span class="line"><span class="comment">    解决方案:</span></span><br><span class="line"><span class="comment">      - 需要循环的对链表是否为空进行判断, 需要将if 该成 while</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>代码改进</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">// 后驱指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 定义互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建链表的头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建新的链表节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// 头节点指针指向新添加的节点</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, (pthread_self() % <span class="number">100</span>));</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line">        <span class="comment">// 生产了任务, 通知消费者消费</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 任务队列中已经没有节点可以进行消费了</span></span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1.调用该函数使得消费者线程在此处进行阻塞</span></span><br><span class="line">            <span class="comment">// 2.消费者线程在59行添加互斥锁成功，但是线程阻塞在这行代码上面，锁还没有解开</span></span><br><span class="line">            <span class="comment">// 3.消费者所有线程在访问这把锁的时均会阻塞,生产者也会阻塞 ==&gt; 如果不使用pthread_cond_wait函数则会造成死锁</span></span><br><span class="line">            <span class="comment">// 4.pthread_cond_wait函数会自动将线程拥有的锁解开， ==&gt; 避免死锁</span></span><br><span class="line">            <span class="comment">// 5.消费者解开锁之后，生产者就可以继续加锁进行生产</span></span><br><span class="line">            <span class="comment">// 6.当任务队列又有节点可以进行消费时，消费者通过函数pthread_cond_broadcast解除消费者阻塞</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="comment">// 7.当消费者线程解除阻塞之后, 会自动将这把锁锁上</span></span><br><span class="line">            <span class="comment">// 8.这时候当前这个线程又重新拥有了这把互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出任务队列中的头节点进行消费</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, (pthread_self() % <span class="number">100</span>));</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源--线程回收</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>若队伍队列的大小存在限制，则需要对生产者使用条件变量</strong></p><p>消费者与生产者需要使用不同的条件变量对各自阻塞的线程进行唤醒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> producer_cond;</span><br><span class="line"><span class="type">pthread_cond_t</span> consumer_cond;</span><br><span class="line"><span class="comment">//创建一个互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义生产者生产仓库的容量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  MAX 100</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//上互斥锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//当生产者生产商品大于仓库容量时</span></span><br><span class="line">        <span class="keyword">while</span> (count &gt;= MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//线程阻塞函数</span></span><br><span class="line">            <span class="comment">//条件变量阻塞生产者线程，使其不再生产</span></span><br><span class="line">            pthread_cond_wait(&amp;producer_cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newnode</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">//初始化节点</span></span><br><span class="line">        newnode-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        newnode-&gt;next = head;</span><br><span class="line">        head = newnode;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者，id:%ld , number:%d , count = %d\n&quot;</span>, (pthread_self() % <span class="number">100</span>), newnode-&gt;number, count);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//唤醒被阻塞的消费者线程</span></span><br><span class="line">        pthread_cond_broadcast(&amp;consumer_cond);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);<span class="comment">//休眠控制生产速度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//添加互斥锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此时链表中无节点---商品为空</span></span><br><span class="line">            <span class="comment">//条件变量线程阻塞</span></span><br><span class="line">            pthread_cond_wait(&amp;consumer_cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者，id:%ld , number:%d , count  = %d\n&quot;</span>, (pthread_self() % <span class="number">100</span>), node-&gt;number, count);</span><br><span class="line">        <span class="comment">//消费者count--,此时消费者继续消费，货物数量小于仓库总容量，唤醒阻塞的生产者线程</span></span><br><span class="line">        pthread_cond_broadcast(&amp;producer_cond);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;producer_cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;consumer_cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建生产者消费者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> t1[<span class="number">5</span>], t2[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//创建生产者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;t1[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;t2[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程资源回收</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(t1[i], <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(t2[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁资源释放</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;consumer_cond);</span><br><span class="line">    pthread_cond_destroy(&amp;producer_cond);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312192203740.png" alt="image-20231219220316694"></p><h3 id="11-信号量"><a href="#11-信号量" class="headerlink" title="11.信号量"></a>11.信号量</h3><h4 id="11-1信号量函数"><a href="#11-1信号量函数" class="headerlink" title="11.1信号量函数"></a>11.1信号量函数</h4><p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A，B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。</p><p><strong>信号量（信号灯）</strong>与互斥锁和条件变量的主要不同在于”灯”的概念，灯亮则意味着资源可用，灯灭则意味着不可用。信号量主要阻塞线程, 不能完全保证线程安全，<strong>如果要保证线程安全, 需要信号量和互斥锁一起使用。</strong></p><hr><p>信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为<code>sem_t</code>对应的头文件为<code>&lt;semaphore.h&gt;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br></pre></td></tr></table></figure><p><strong>信号量操作函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化信号量/信号灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可</span></span><br><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数：</strong></p><p><code>sem</code>：信号量变量地址</p><p><code>pshared</code>：</p><p>​<code>0</code>：线程同步</p><p>​<code>非0</code>：进程同步</p><p>​<code>value</code>：初始化当前信号量拥有的资源数（&gt;&#x3D;0），如果资源数为0，线程就会被阻塞了。</p></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>当线程调用这个函数，并且<code>sem</code>中的资源数<code>&gt;0</code>，线程不会阻塞，线程会占用<code>sem</code>中的一个资源，因此资源数-1，直到<code>sem</code>中的资源数减为<code>0</code>时，资源被耗尽，因此线程也就被阻塞了。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>当线程调用这个函数，并且<code>sem</code>中的资源数<code>&gt;0</code>，线程不会阻塞，线程会占用<code>sem</code>中的一个资源，因此资源数-1，直到<code>sem</code>中的资源数减为<code>0</code>时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用该函数线程获取sem中的一个资源，当资源数为0时，线程阻塞，在阻塞abs_timeout对应的时长之后，解除阻塞。</span></span><br><span class="line"><span class="comment">// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><p>该函数的参数<code>abs_timeout</code>和<code>pthread_cond_timedwait</code>的最后一个参数是一样的，使用方法不再过多赘述。当线程调用这个函数，并且<code>sem</code>中的资源数<code>&gt;0</code>，线程不会阻塞，线程会占用<code>sem</code>中的一个资源，因此资源数-1，直到<code>sem</code>中的资源数减为<code>0</code>时，资源被耗尽，线程被阻塞，当阻塞指定的时长之后，线程解除阻塞。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>调用该函数会将<code>sem</code>中的资源数<code>+1</code>，如果有线程在调用<code>sem_wait</code>、<code>sem_trywait</code>、<code>sem_timedwait</code>时因为<code>sem</code>中的资源数为<code>0</code>被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中</span></span><br><span class="line"><span class="comment">// sval是一个传出参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure><p>通过这个函数可以查看<code>sem</code>中现在拥有的资源个数，通过第二个参数<code>sval</code>将数据传出，也就是说第二个参数的作用和返回值是一样的。</p><hr><h4 id="11-2生产者与消费者"><a href="#11-2生产者与消费者" class="headerlink" title="11.2生产者与消费者"></a>11.2生产者与消费者</h4><p>由于生产者和消费者是两类线程，并且在还没有生成之前是不能进行消费的，在使用信号量处理这类问题的时候可以定义两个信号量，分别用于记录生产者和消费者线程拥有的总资源数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者线程 </span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量初始化</span></span><br><span class="line">sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);    <span class="comment">// 5个生产者可以同时生产</span></span><br><span class="line">sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 消费者线程没有资源, 因此不能消费</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="comment">// 在生产之前, 从信号量中取出一个资源</span></span><br><span class="line">sem_wait(&amp;psem);</span><br><span class="line"><span class="comment">// 生产者商品代码, 有商品了, 放到任务队列</span></span><br><span class="line">...... </span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 通知消费者消费，给消费者信号量添加资源，让消费者解除阻塞</span></span><br><span class="line">sem_post(&amp;csem);</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="comment">// 消费者需要等待生产, 默认启动之后应该阻塞</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line"><span class="comment">// 开始消费</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 消费完成, 通过生产者生产，给生产者信号量添加资源</span></span><br><span class="line">sem_post(&amp;psem);</span><br></pre></td></tr></table></figure><p>通过上面的代码可以知道，初始化信号量的时候没有消费者分配资源，消费者线程启动之后由于没有资源自然就被阻塞了，等生产者生产出产品之后，再给消费者分配资源，这样二者就可以配合着完成生产和消费流程了。</p><h4 id="11-3信号量的使用"><a href="#11-3信号量的使用" class="headerlink" title="11.3信号量的使用"></a>11.3信号量的使用</h4><p>如果生产者和消费者线程使用的信号量对应的<strong>总资源数为1</strong>，那么不管线程有多少个，可以工作的线程只有一个，其余线程由于拿不到资源，都被迫阻塞了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br></pre></td></tr></table></figure><h5 id="11-3-1总资源数为1"><a href="#11-3-1总资源数为1" class="headerlink" title="11.3.1总资源数为1"></a>11.3.1总资源数为1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号量头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用信号量</span></span><br><span class="line"><span class="comment">编写生产者和消费者模型</span></span><br><span class="line"><span class="comment">总资源数为1的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者的信号量</span></span><br><span class="line"><span class="type">sem_t</span> semp;</span><br><span class="line"><span class="comment">//消费者信号量</span></span><br><span class="line"><span class="type">sem_t</span> semc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测生产者是否有资源</span></span><br><span class="line">        sem_wait(&amp;semp);<span class="comment">//资源&gt;0就不会被阻塞---生产者线程会占用一个资源-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newnode</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">//初始化节点</span></span><br><span class="line">        newnode-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        newnode-&gt;next = head;</span><br><span class="line">        head = newnode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者，id:%ld , number:%d\n&quot;</span>, (pthread_self() % <span class="number">100</span>), newnode-&gt;number);</span><br><span class="line">        <span class="comment">//通知消费者消费---消费者资源+1</span></span><br><span class="line">        sem_post(&amp;semc);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);<span class="comment">//休眠控制生产速度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//消费者尝试消费，若有资源则消费者资源-1</span></span><br><span class="line">        sem_wait(&amp;semc);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者，id:%ld , number:%d\n&quot;</span>, (pthread_self() % <span class="number">100</span>), node-&gt;number);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="comment">//通知生产者生产</span></span><br><span class="line">        sem_post(&amp;semp);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//初始化信号变量</span></span><br><span class="line">    <span class="comment">//1.生产者</span></span><br><span class="line">    sem_init(&amp;semp, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//生产者总共的资源数为1---&gt;则可同时工作的线程为1个</span></span><br><span class="line">    <span class="comment">//2.消费者 -&gt; 资源初始化为0 消费则线程启动就阻塞</span></span><br><span class="line">    sem_init(&amp;semc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建生产者消费者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> t1[<span class="number">5</span>], t2[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//创建生产者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;t1[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;t2[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程资源回收</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(t1[i], <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(t2[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁资源释放</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="comment">//信号量的销毁</span></span><br><span class="line">    sem_destroy(&amp;semp);</span><br><span class="line">    sem_destroy(&amp;semc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过测试代码可以得到如下结论：如果生产者和消费者使用的信号量总资源数为1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</p><p>运行结果</p><p>可以看到生产者与消费者交替运行</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312192221267.png" alt="image-20231219222122218"></p><h5 id="11-3-2总资源数大于1"><a href="#11-3-2总资源数大于1" class="headerlink" title="11.3.2总资源数大于1"></a>11.3.2总资源数大于1</h5><p>如果生产者和消费者线程使用的信号量对应的总资源数为大于1，这种场景下出现的情况就比较多了：</p><ul><li>多个生产者线程同时生产</li><li>多个消费者同时消费</li><li>生产者线程和消费者线程同时生产和消费</li></ul><p>以上不管哪一种情况都可能会出现多个线程访问共享资源的情况，如果想防止共享资源出现数据混乱，那么就需要使用互斥锁进行线程同步，线程线性执行任务 ，处理代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br></pre></td></tr></table></figure><p>在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure><p><strong>这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁</strong>，下面来分析一种死锁的场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，初始化状态下消费者线程没有任务信号量资源，假设某一个消费者线程先运行，调用<code>pthread_mutex_lock(&amp;mutex);</code>对互斥锁加锁成功，然后调用<code>sem_wait(&amp;csem);</code>由于没有资源，因此被阻塞了。其余的消费者线程由于没有抢到互斥锁，因此被阻塞在互斥锁上。对应生产者线程第一步操作也是调用<code>pthread_mutex_lock(&amp;mutex);</code>，但是这时候互斥锁已经被消费者线程锁上了，所有生产者都被阻塞，到此为止，多余的线程都被阻塞了，程序产生了死锁。</p><p><strong>完整代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号量头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用信号量</span></span><br><span class="line"><span class="comment">编写生产者和消费者模型</span></span><br><span class="line"><span class="comment">总资源数为5的情况---&gt;需要线程同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者的信号量</span></span><br><span class="line"><span class="type">sem_t</span> semp;</span><br><span class="line"><span class="comment">//消费者信号量</span></span><br><span class="line"><span class="type">sem_t</span> semc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测生产者是否有资源---是否有空闲的生产者线程</span></span><br><span class="line">        sem_wait(&amp;semp);<span class="comment">//资源&gt;0就不会被阻塞---生产者线程会占用一个资源-1</span></span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//上锁和sem_wait（）两句代码顺序不能乱</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newnode</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">//初始化节点</span></span><br><span class="line">        newnode-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        newnode-&gt;next = head;</span><br><span class="line">        head = newnode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者，id:%ld , number:%d\n&quot;</span>, (pthread_self() % <span class="number">100</span>), newnode-&gt;number);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//通知消费者消费---消费者资源+1</span></span><br><span class="line">        sem_post(&amp;semc);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);<span class="comment">//休眠控制生产速度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者回调函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//消费者尝试消费，若有资源则消费者资源-1（任务队列中是否有多余的任务）</span></span><br><span class="line">        sem_wait(&amp;semc);</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者，id:%ld , number:%d\n&quot;</span>, (pthread_self() % <span class="number">100</span>), node-&gt;number);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//通知生产者生产</span></span><br><span class="line">        sem_post(&amp;semp);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//初始化信号变量</span></span><br><span class="line">    <span class="comment">//1.生产者</span></span><br><span class="line">    sem_init(&amp;semp, <span class="number">0</span>, <span class="number">5</span>);<span class="comment">//生产者总共的资源数为5---&gt;为了不造成数据的混乱还是需要线程同步---&gt;需要互斥锁的帮助（锁在临界区）</span></span><br><span class="line">    <span class="comment">//2.消费者 -&gt; 资源初始化为0 消费则线程启动就阻塞</span></span><br><span class="line">    sem_init(&amp;semc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建生产者消费者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> t1[<span class="number">5</span>], t2[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//创建生产者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;t1[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;t2[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程资源回收</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(t1[i], <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(t2[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁资源释放</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="comment">//信号量的销毁</span></span><br><span class="line">    sem_destroy(&amp;semp);</span><br><span class="line">    sem_destroy(&amp;semc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312192234524.png" alt="image-20231219223407481"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池C语言版本</title>
      <link href="/2023/12/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E7%BA%BF%E7%A8%8B%E6%B1%A0C%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/"/>
      <url>/2023/12/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E7%BA%BF%E7%A8%8B%E6%B1%A0C%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="线程池C语言版本"><a href="#线程池C语言版本" class="headerlink" title="线程池C语言版本"></a>线程池C语言版本</h2><p>教程文档：<a href="https://subingwen.cn/linux/threadpool/">爱编程的大丙</a></p><p>视频教程：<a href="https://www.bilibili.com/video/BV1jV411J795/?spm_id_from=333.999.0.0&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">爱编程的大丙</a></p><h3 id="一、线程池原理"><a href="#一、线程池原理" class="headerlink" title="一、线程池原理"></a>一、线程池原理</h3><p>线程池使得线程可以得到复用,在执行完一个任务之后，不进行销毁而是继续执行其他任务。</p><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><p>线程池的组成主要分为3个部分，这三部分配合工作就可以得到一个完整的线程池：</p><p>任务队列中的任务实际是回调函数，函数地址</p><ul><li><p>1.任务队列，存储需要处理的任务，由工作的线程来处理这些任务</p><p>通过线程池提供的<code>API</code>函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除</p><p>已处理的任务会被从任务队列中删除</p><p>线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程</p></li><li><p>2.工作的线程（任务队列任务的消费者） ，<code>N</code>个</p><p>线程池中维护了一定数量的工作线程, 他们的作用是是不停的读任务队列, 从里边取出任务并处理</p><p>工作的线程相当于是任务队列的消费者角色</p><p>如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量&#x2F;信号量阻塞)</p><p>如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作</p></li><li><p>3.管理者线程（不处理任务队列中的任务），<code>1</code>个</p><p>它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测</p><p>​当任务过多的时候, 可以适当的创建一些新的工作线程</p><p>​当任务过少的时候, 可以适当的销毁一些工作的线程</p></li></ul><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312202018223.png" alt="image-20231220201825184"></p><h3 id="二、任务队列"><a href="#二、任务队列" class="headerlink" title="二、任务队列"></a>二、任务队列</h3><p>任务结构体，成员有任务函数以及函数需要的参数</p><p>任务函数由有一个函数指针<code>function</code>指向,并且指向的函数返回值为<code>void *</code>，函数参数也为<code>void *</code></p><p><code>void *</code>，任何类型的指针都可以直接赋值给它，无需进行强制类型转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span>* arg); <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;Task;</span><br></pre></td></tr></table></figure><h3 id="三、线程池定义"><a href="#三、线程池定义" class="headerlink" title="三、线程池定义"></a>三、线程池定义</h3><p>线程池结构体包含几个部分：</p><ul><li><p>任务队列的定义</p><p>任务队列容量、当前队列中任务的个数，任务队列的首尾指针（在队尾加入任务，在队首取出任务）</p><p>当前队列中任务的个数，该变量若同时被多个线程操作则会导致数据混乱，因此需要加入互斥锁保证线程同步</p></li><li><p>管理者线程ID<code>pthread_t managerID</code></p><p>管理者线程ID变量的类型为<code>pthread_t</code>,在实例代码中，只创建了一个管理者线程，在线程池中的功能下：</p><p>（1）添加线程：当工作线程忙不来的时候，需要添加工作线程（但是每次添加的线程数需要对其进行相关约束，如：线程池中当前存活的线程数需要小于线程池中最大的线程数量）。</p><p>（2）销毁线程：当前的任务队列中的任务数量太少，不需要过多的工作线程时（节省资源），需要对工作的子线程进行销毁操作，可以定义一个变量为每次销毁的子线程数（实例代码中为<code>NUMBER</code>，在<code>threadpool.c</code>中被初始化，并且使用<code>extern</code>外部引用至<code>threadpool.h</code>中）。而销毁的方式可以选择诱导子线程自杀（可以分析得知，当任务队列为空时，这时会存在许多空闲的子线程，在工作线程调用的<code>worker</code>函数中会通过<code>pthread_cond_wait</code>函数将这些空闲的子线程进行阻塞，在生产者线程继续向任务队列中添加任务后，任务队列不为空时，生产者线程会通过<code>pthread_cond_signal</code>函数以及对应的条件变量将阻塞的工作线程唤醒，继续接活干。其次在管理者线程每次休眠之后，进行检查时，发现还有很多空闲的工作线程并且空闲的数量满足一定数量上的判断时，则会考虑在管理者线程对应的<code>manager</code>函数中通过<code>pthread_cond_signal</code>函数以及对应的条件变量将阻塞的工作线程唤醒，并且设置相应的销毁工作线程标志位<code>exitNum</code>对其赋值为每次销毁的子线程数量。在工作线程对于的<code>worker</code>函数中解除工作线程的阻塞之后，则会对线程池的<code>pool-&gt;exitNum</code>进行判断，若该值为真则会让空闲的工作线程自杀）。</p></li><li><p>工作线程ID<code>pthread_t *threadIDs</code></p><p>工作线程ID定义为<code>pthread_t</code>类型的一级指针，因为工作线程数量较多，在工作线程创建时，会使用<code>malloc</code>函数创建一段连续的堆空间，使用工作线程ID指针指向其地址空间。创建的工作线程ID一级指针会当作数组进行使用，用于存储创建的工作线程ID号（但是工作线程ID一级指针指向的堆空间在创建之初需要对其进行初始化均赋值为0，在之后的操作中对每段堆空间进行判断若其值不为0，则表示已经有工作线程对该段堆空间进行占用。在每次工作线程退出时，也需要该工作线程占用的堆空间进行赋值为0，表示该工作线程结束了对该段堆空间的占用，方便后续创建的工作线程对其进行使用）。</p></li><li><p>最小工作线程数量</p><p>线程池所容纳的最小工作线程数量（线程池还在工作时，存活的工作线程数量需要大于等于最小的工作线程数量）。</p></li><li><p>最大工作线程数量</p><p>线程池所容纳的最大工作线程数量（线程池还在工作时，存活的工作线程数量需要小于等于最大的工作线程数量）。</p></li><li><p>忙的工作线程数量</p><p>用于表示线程池中当前正在工作的工作线程数量，每当工作线程在任务队列中取出任务并且执行时，该变量进行<code>+1</code>操作。当任务执行完毕之后，则进行<code>-1</code>操作。该变量的操作非常频繁，并且需要注意的是，不能多个工作线程对该变量同时进行操作，在对该变量进行操作时，需要加入互斥锁（在线程池中对于这种会频繁操作的变量，特意定义了一把独有的互斥锁<code>pool-&gt;mutexBusy</code>）保证线程同步，避免数据混乱。</p></li><li><p>存活的工作线程的数量</p><p>用于表示线程池中当前存活的工作线程数量，当管理者线程需要对线程池中的线程进行添加或者销毁工作时，会对改变了进行操作，不能多个工作线程对该变量同时进行操作，在对该变量进行操作时，需要加入互斥锁（在实例代码中直接使用的是整个线程池的互斥锁）保证线程同步，避免数据混乱。</p></li><li><p>要销毁的工作线程个数</p><p>在管理者线程对应的manager函数中，首先，若需要管理者线程进行工作线程销毁时，则会对该变量进行操作，在操作该变量时，也需要添加互斥锁，保证线程同步（在该实例代码中虽然只有一个管理者线程，但是若存在多个管理者线程，则不能允许多个管理者线程对该变量同时进行操作，因此需要保证线程同步）。其次，因为本文的实例代码中，管理者线程销毁工作线程，是通过诱导工作线程自杀的方式，因此在工作线程对应的worker函数中也会对该变量进行操作，此时是当前自杀的工作子线程对该变量进行操作，也需要保证线程同步，添加互斥锁。</p></li><li><p>线程池的互斥锁<code>mutexPool</code></p><p>锁整个线程池，对线程池中的任务队列以及可能造成数据混乱的其他变量进行同步操作</p></li><li><p><code>busyNum</code>变量的互斥锁</p><p>当前忙工作线程的数量，该变量变化次数多，因此单独为其创建一把互斥锁</p></li><li><p>判断任务队列是否已满的条件变量<code>notFull</code></p><p>当生产者为任务队列添加任务导致队列满时，会使用<code>pthread_cond_wait</code>函数通过线程池的锁<code>pool-&gt;mutexPool</code>以及条件变量<code>pool-&gt;notFull</code>阻塞生产者线程。而在工作线程对应的<code>worker</code>函数中，当工作线程从任务队列中取出任务后，则会通过<code>pthread_cond_signal(&amp;pool-&gt;notFull)</code>唤醒阻塞的生产者线程继续为任务队列添加任务</p></li><li><p>销毁线程池标志位</p><p>若标志位<code>shutdown</code>为1，则表示对线程池进行销毁，若标志位为0，则表示不销毁。</p><p>销毁线程池，需要将管理者线程与工作线程均进行退出并且回收，因此在后文会创建线程退出函数<code>threadExit</code>（线程退出函数的逻辑后文会给出）</p><p>销毁线程池函数<code>threadPoolDestroy</code>，当<code>main.c</code>中主线程以及线程池中的线程完成任务后，会调用销毁线程池函数，函数体内，会将标志位<code>shutdown</code>赋值为<code>1</code>，并且唤醒所有阻塞的工作线程，进一步对销毁线程池标志位进行判断，若为真则执行线程退出函数（因为此时所有任务均完成，任务队列中已经没有其他任务，工作线程会被工作函数<code>worker</code>中的<code>pthread_cond_wait(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool)</code>阻塞）。而针对于管理者线程，在对应的管理者函数内，会对标志位<code>shutdown</code>进行判断，若该满足条件，管理者线程也会退出，并且在销毁线程池函数<code>threadPoolDestroy</code>体内会对管理者线程调用<code>pthread_join(pool-&gt;managerID,NULL)</code>函数进行管理者线程资源的阻塞回收。在完成上面的操作之后，则会将线程池创建的任务队列以及工作线程ID存储空间所开辟的堆空间进行释放，并且销毁所有的互斥锁以及条件变量。最后将线程池指针<code>pool</code>所指向的动态内存空间也进行释放。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Threadpool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    Task *taskQ;</span><br><span class="line">    <span class="type">int</span> queueCapacity;  <span class="comment">// 容量</span></span><br><span class="line">    <span class="type">int</span> queueSize;      <span class="comment">// 当前任务个数</span></span><br><span class="line">    <span class="type">int</span> queueFront;     <span class="comment">// 队头 -&gt; 取数据</span></span><br><span class="line">    <span class="type">int</span> queueRear;      <span class="comment">// 队尾 -&gt; 放数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> managerID;        <span class="comment">// 管理者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> *threadIDs;       <span class="comment">// 工作的线程ID--使用一级指针指向装有工作线程ID的数组</span></span><br><span class="line">    <span class="type">int</span> minNum;                 <span class="comment">// 最小工作线程数量</span></span><br><span class="line">    <span class="type">int</span> maxNum;                 <span class="comment">// 最大工作线程数量</span></span><br><span class="line">    <span class="type">int</span> busyNum;                <span class="comment">// 忙的工作线程的个数</span></span><br><span class="line">    <span class="type">int</span> liveNum;                <span class="comment">// 存活的工作线程的个数</span></span><br><span class="line">    <span class="type">int</span> exitNum;                <span class="comment">// 要销毁的工作线程个数---适当的销毁没有活干的工作线程</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool;  <span class="comment">// 锁整个的线程池---对整个任务队列做线程同步，避免造成数据混乱</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexBusy;  <span class="comment">// 锁busyNum变量---该变量变化次数更多，也需要避免数据混乱</span></span><br><span class="line">    <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notFull;     <span class="comment">// 任务队列是不是满了</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;    <span class="comment">// 任务队列是不是空了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shutdown;           <span class="comment">// 是不是要销毁线程池, 销毁为1, 不销毁为0</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="四、头文件声明"><a href="#四、头文件声明" class="headerlink" title="四、头文件声明"></a>四、头文件声明</h3><p><code>threadpool.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by zxz on 2023/12/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UNTITLED_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNTITLED_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在threadpool.c源文件进行定义与初始化，在头文件进行extern</span></span><br><span class="line"><span class="comment">// 若在头文件中进行初始化，当头文件被多个文件进行引用的时候，就会导致比变量被重复定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> NUMBER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span> *arg); <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">&#125;Task;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Threadpool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    Task *taskQ;</span><br><span class="line">    <span class="type">int</span> queueCapacity;  <span class="comment">// 容量</span></span><br><span class="line">    <span class="type">int</span> queueSize;      <span class="comment">// 当前任务个数</span></span><br><span class="line">    <span class="type">int</span> queueFront;     <span class="comment">// 队头 -&gt; 取数据</span></span><br><span class="line">    <span class="type">int</span> queueRear;      <span class="comment">// 队尾 -&gt; 放数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> managerID;        <span class="comment">// 管理者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> *threadIDs;       <span class="comment">// 工作的线程ID--使用一级指针指向装有工作线程ID的数组</span></span><br><span class="line">    <span class="type">int</span> minNum;                 <span class="comment">// 最小线程数量</span></span><br><span class="line">    <span class="type">int</span> maxNum;                 <span class="comment">// 最大线程数量</span></span><br><span class="line">    <span class="type">int</span> busyNum;                <span class="comment">// 忙的线程的个数</span></span><br><span class="line">    <span class="type">int</span> liveNum;                <span class="comment">// 存活的线程的个数</span></span><br><span class="line">    <span class="type">int</span> exitNum;                <span class="comment">// 要销毁的线程个数---适当的销毁没有活干的线程</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool;  <span class="comment">// 锁整个的线程池---对整个任务队列做线程同步，避免造成数据混乱</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexBusy;  <span class="comment">// 锁busyNum变量---该变量变化次数更多，也需要避免数据混乱</span></span><br><span class="line">    <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notFull;     <span class="comment">// 任务队列是不是满了</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;    <span class="comment">// 任务队列是不是空了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shutdown;           <span class="comment">// 是不是要销毁线程池, 销毁为1, 不销毁为0</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Threadpool</span> <span class="title">Thread_Pool</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池并初始化</span></span><br><span class="line">Thread_Pool *<span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min,<span class="type">int</span> max,<span class="type">int</span> queueSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁线程池</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(Thread_Pool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池添加任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(Thread_Pool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池中工作的线程个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolBusyNum</span><span class="params">(Thread_Pool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池中活着的线程的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolAliveNum</span><span class="params">(Thread_Pool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作的线程(消费者线程)任务函数</span></span><br><span class="line"><span class="keyword">_Noreturn</span> <span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者线程任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个线程退出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(Thread_Pool* pool)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//UNTITLED_THREADPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五、源文件定义"><a href="#五、源文件定义" class="headerlink" title="五、源文件定义"></a>五、源文件定义</h3><p><code>threadpool.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by zxz on 2023/12/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者线程--每次增加或者销毁的线程数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 创建线程池 ****/</span></span><br><span class="line">Thread_Pool *<span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min,<span class="type">int</span> max,<span class="type">int</span> queueSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread_Pool *pool;</span><br><span class="line">    pool = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*pool));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工作的线程---开辟连续的内存空间进行存储</span></span><br><span class="line">        pool-&gt;threadIDs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threadIDs == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadIDS fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对工作的线程ID进行初始化为0，若之后判断仍然为0，则说明该线程ID没有被占用</span></span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threadIDs,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*max);</span><br><span class="line">        <span class="comment">// 初始化相关变量</span></span><br><span class="line">        pool-&gt;minNum = min;</span><br><span class="line">        pool-&gt;maxNum = max;</span><br><span class="line">        pool-&gt;busyNum = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;liveNum = min; <span class="comment">// 和最小个数相等</span></span><br><span class="line">        pool-&gt;exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化互斥锁与条件变量</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutexPool, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_mutex_init(&amp;pool-&gt;mutexBusy, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notEmpty, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notFull, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mutex or condition init fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        pool-&gt;taskQ = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Task) * queueSize);</span><br><span class="line">        pool-&gt;queueCapacity = queueSize;</span><br><span class="line">        pool-&gt;queueSize = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueFront = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueRear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pool-&gt;shutdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        pthread_create(&amp;pool-&gt;managerID,<span class="literal">NULL</span>,manager,pool);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;min;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;pool-&gt;threadIDs[i],<span class="literal">NULL</span>,worker,pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>); <span class="comment">// while(0)不会一直循环，但是在代码块中可以使用break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若跳出了while(0),则出现了异常</span></span><br><span class="line">    <span class="comment">// 进行资源释放</span></span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;threadIDs) <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;taskQ) <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    <span class="keyword">if</span> (pool) <span class="built_in">free</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****工作的线程(消费者线程)任务函数*****/</span></span><br><span class="line"><span class="comment">// 在任务队列中取出任务并且进行消费</span></span><br><span class="line"><span class="comment">// 消费者消费产品之后需要唤醒阻塞的生产者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread_Pool *pool = (Thread_Pool *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">// 当前任务队列为空</span></span><br><span class="line">        <span class="keyword">while</span>(pool-&gt;queueSize == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 阻塞工作线程---此时任务等待生产者线程添加任务在继续</span></span><br><span class="line">            pthread_cond_wait(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解除阻塞(wait函数解除阻塞之后会先解锁后加锁)，诱导工作线程自杀</span></span><br><span class="line">            <span class="keyword">if</span>(pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pool-&gt;exitNum--;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;liveNum &gt; pool-&gt;minNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 活着的线程个数也需要-1 线程在wait函数中解除阻塞时，会自动加锁，因此此处不需要进行加锁操作</span></span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    <span class="comment">// 解锁</span></span><br><span class="line">                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    <span class="comment">// 终止调用线程---空闲的线程自己向下执行</span></span><br><span class="line">                    threadExit(pool);</span><br><span class="line">                    <span class="comment">// pthread_exit(NULL);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断线程池是否关闭</span></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="comment">// 线程退出</span></span><br><span class="line">            threadExit(pool);</span><br><span class="line">            <span class="comment">//pthread_exit(NULL);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工作线程进行消费</span></span><br><span class="line">        Task task;</span><br><span class="line">        <span class="comment">// 从头部取任务</span></span><br><span class="line">        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;</span><br><span class="line">        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;</span><br><span class="line">        <span class="comment">// 移动队列头节点---对于循环队列</span></span><br><span class="line">        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">        <span class="comment">// 任务总个数-1</span></span><br><span class="line">        pool-&gt;queueSize--;</span><br><span class="line">        <span class="comment">// 唤醒阻塞在 队列满的条件变量(pool-&gt;notFull)  上的线程，此时已经消费了一个任务，队列不满了</span></span><br><span class="line">        <span class="comment">// 可以继续添加任务了</span></span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notFull);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出告知系统当前线程开始执行任务</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld start working... \n&quot;</span>,pthread_self());</span><br><span class="line">        <span class="comment">// 对于忙线程个数进行+1</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        task.function(task.arg);</span><br><span class="line">        <span class="comment">// 若传递的参数是一块堆内存则需要对其进行释放</span></span><br><span class="line">        <span class="built_in">free</span>(task.arg);</span><br><span class="line">        task.arg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 输出告知系统当前线程已经执行完毕任务</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld end working... \n&quot;</span>,pthread_self());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务执行完之后，忙线程需要-1</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 管理者线程任务函数 *****/</span></span><br><span class="line"><span class="comment">// 用于创建线程与销毁多余空闲的线程</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread_Pool * pool = (Thread_Pool*)arg;</span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每隔3s检测一次</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出线程池中任务的数量和当前线程存活的数量</span></span><br><span class="line">        <span class="comment">// 需要加锁，避免数据混乱</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="type">int</span> queueSize = pool-&gt;queueSize;</span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出忙的线程数量</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***** 添加线程 ******/</span></span><br><span class="line">        <span class="comment">// 当工作线程忙不过来的时，需要继续添加线程</span></span><br><span class="line">        <span class="comment">// 任务的个数&gt;线程存活的个数  &amp;&amp; 存活的线程数 &lt; 最大线程数</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加锁 因为下面也操作了线程池的变量</span></span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;pool-&gt;maxNum &amp;&amp; counter &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 该线程ID没有被使用</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadIDs[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 创建新的线程</span></span><br><span class="line">                    pthread_create(&amp;pool-&gt;threadIDs[i],<span class="literal">NULL</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/***** 销毁线程 ******/</span></span><br><span class="line">        <span class="comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum *<span class="number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;liveNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 操作线程池中的变量需要进行加锁</span></span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;exitNum = NUMBER;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让空闲的工作线程自杀</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUMBER;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 若此时多余的线程是空闲的则说明此时的任务队列为空</span></span><br><span class="line">                <span class="comment">// 多余的线程此时阻塞在worker函数的pthread_cond_wait(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool)位置</span></span><br><span class="line">                <span class="comment">// 只需将其唤醒，使其在worker函数中向后执行并且自杀</span></span><br><span class="line">                pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Manager Thread,%ld exiting...............\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="comment">// 管理者线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**** 线程退出函数 ****/</span></span><br><span class="line"><span class="comment">// 存储退出线程id的数组位置需要进行清0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(Thread_Pool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;pool-&gt;maxNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到当前调用该函数的线程id的数组位置，对其进行归零</span></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            pool-&gt;threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;threadExit() called,%ld exiting...............\n&quot;</span>,tid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 退出的工作线程资源回收</span></span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 线程池添加任务 ****/</span></span><br><span class="line"><span class="comment">// 生产者生产产品之后需要唤醒阻塞的消费者</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(Thread_Pool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 也需要锁住--避免有线程同时在任务队列中添加任务又在任务队列中取任务</span></span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="comment">// 若任务队列满</span></span><br><span class="line">    <span class="keyword">while</span>(pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞生产者线程</span></span><br><span class="line">        pthread_cond_wait(&amp;pool-&gt;notFull,&amp;pool-&gt;mutexPool);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程池关闭</span></span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程池没有关闭 则继续添加任务 添加到队尾</span></span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].function = func;</span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;</span><br><span class="line">    <span class="comment">// 队尾进行后移</span></span><br><span class="line">    pool-&gt;queueRear =(pool-&gt;queueRear + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">    <span class="comment">// 任务队列中的任务个数+1</span></span><br><span class="line">    pool-&gt;queueSize++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒阻塞在 队列为空pool-&gt;notEmpty 条件变量上的线程 有活干了</span></span><br><span class="line">    pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**** 获取线程池中工作的线程个数 ****/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolBusyNum</span><span class="params">(Thread_Pool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 获取线程池中活着的线程的个数 ******/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolAliveNum</span><span class="params">(Thread_Pool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="type">int</span> liveNum = pool-&gt;liveNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> liveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 销毁线程池 *******/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(Thread_Pool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pool线程池指向的是一块非有效的地址</span></span><br><span class="line">    <span class="keyword">if</span>(pool == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    pool-&gt;shutdown = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 唤醒存活的消费者线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;pool-&gt;liveNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞回收管理者线程---等工作线程退出之后在对管理者线程进行资源回收</span></span><br><span class="line">    pthread_join(pool-&gt;managerID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放堆内存</span></span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;taskQ)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量与互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);</span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notEmpty);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notFull);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-线程池创建函数"><a href="#1-线程池创建函数" class="headerlink" title="1.线程池创建函数"></a>1.线程池创建函数</h4><ul><li><p>参数</p><p>线程池工作时最少工作线程数量<code>min</code></p><p>线程池工作时最少多工作线程数量<code>max</code></p><p>任务队列的容量<code>queueSize</code>，于后文提到的任务队列中当前任务数<code>pool-&gt;queueSize</code>不一样</p></li><li><p>返回值</p><p>为<code>struct Threadpool</code>类型的指针，指向线程池</p></li><li><p>业务逻辑</p><p>将所有创建过程均可以放置在一个<code>do whle(0)</code>的循环中，该循环只进行一次，使用这种语法的好处时，若创建步骤失败，则可以使用<code>break</code> 中断创建，并且在函数最后对之前创建成功所占用的内存空间进行释放。</p><p>（1）工作线程ID的存储：开辟连续内存的堆空间，对工作线程的ID进行存储，其空间大小为<code>sizeof(pthread_t) * max</code>，创建之后对每一个线程ID存储位置赋值为<code>0</code></p><p>（2）初始化互斥锁与条件变量：若每一次初始化函数返回的值不为0，则使用<code>break</code>中断</p><p>（3）任务队列的创建：开辟动态内存创建<code>queueSize</code>数量的任务存储空间，并且对任务队列相关的变量进行初始化</p><p>（4）管理者线程与工作线程的创建：在实例代码中仅创建一个管理者线程，并且工作线程在开始时，仅创建最少的工作线程数量。</p><p>（5）创建失败则回收资源：上述步骤中，若创建失败，则回收资源。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Thread_Pool *<span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min,<span class="type">int</span> max,<span class="type">int</span> queueSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread_Pool *pool;</span><br><span class="line">    pool = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*pool));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工作的线程---开辟连续的内存空间进行存储ID</span></span><br><span class="line">        pool-&gt;threadIDs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threadIDs == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadIDS fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对工作的线程ID进行初始化为0，若之后判断仍然为0，则说明该线程ID没有被占用</span></span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threadIDs,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*max);</span><br><span class="line">        <span class="comment">// 初始化相关变量</span></span><br><span class="line">        pool-&gt;minNum = min;</span><br><span class="line">        pool-&gt;maxNum = max;</span><br><span class="line">        pool-&gt;busyNum = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;liveNum = min; <span class="comment">// 和最小个数相等</span></span><br><span class="line">        pool-&gt;exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化互斥锁与条件变量</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutexPool, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_mutex_init(&amp;pool-&gt;mutexBusy, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notEmpty, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notFull, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mutex or condition init fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        pool-&gt;taskQ = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Task) * queueSize);</span><br><span class="line">        pool-&gt;queueCapacity = queueSize;</span><br><span class="line">        pool-&gt;queueSize = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueFront = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueRear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pool-&gt;shutdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        pthread_create(&amp;pool-&gt;managerID,<span class="literal">NULL</span>,manager,pool);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;min;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;pool-&gt;threadIDs[i],<span class="literal">NULL</span>,worker,pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>); <span class="comment">// while(0)不会一直循环，但是在代码块中可以使用break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若跳出了while(0),则出现了异常</span></span><br><span class="line">    <span class="comment">// 进行资源释放</span></span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;threadIDs) <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;taskQ) <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    <span class="keyword">if</span> (pool) <span class="built_in">free</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-工作线程的任务函数"><a href="#2-工作线程的任务函数" class="headerlink" title="2.工作线程的任务函数"></a>2.工作线程的任务函数</h4><p><code>worker</code>函数</p><ul><li><p>参数：</p><p><code>void *</code>类型，在本实例代码中，传入的参数为指向线程池的指针，<code>Thread_Pool *pool</code></p></li><li><p>返回值：</p><p><code>void *</code>类型</p></li><li><p>业务逻辑</p><p>任务函数，需要一直运行，因此在<code>while(1)</code>的循环中进行操作</p><p>每一个工作线程均会执行一个任务函数，为了保持线程同步，因此在执行任务函数时，需要将线程池进行加锁操作。</p><p>（1）判断任务队列是否为空以及当前是否执行线程销毁：若任务队列为空，则需要阻塞工作线程，等待生产者线程为任务队列中添加任务之后在继续操作。</p><p>（2）工作线程诱导自杀：工作线程解除阻塞之后，若有空闲的工作线程存在，则需要对要销毁的工作线程个数进行判断，若需要销毁的工作线程个数<code>pool-&gt;exitNum</code>大于<code>0</code>，则先对调用该函数的工作线程执行解锁操作（<code>pthread_cond_wait</code>解除阻塞之后，得到<code>CPU</code>时间片的工作线程会先解锁后加锁），最后经过相关的条件判断执行该工作线程的自杀操作，该工作调用线程主动调用线程退出函数</p><p>（3）判断线程池是否关闭销毁：工作线程解除阻塞之后，需要对销毁线程池标志位进行判断，若为真，则先对该工作线程进行解锁操作，在执行线程退出函数</p><p>（4）工作线程正常执行任务：若（2）（3）的判断均为否，则从任务队列的头部取出任务，在执行。期间需要移动队列头节点，指向下一个任务。并且对任务队列中当前任务总数<code>queueSize</code>进行<code>-1</code>。若此前任务队列为满时，则唤醒阻塞的生产者线程，继续为任务队列中添加任务。</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312251445366.png" alt="image-20231225144527629"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****工作的线程(消费者线程)任务函数*****/</span></span><br><span class="line"><span class="comment">// 在任务队列中取出任务并且进行消费</span></span><br><span class="line"><span class="comment">// 消费者消费产品之后需要唤醒阻塞的生产者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread_Pool *pool = (Thread_Pool *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">// 当前任务队列为空</span></span><br><span class="line">        <span class="keyword">while</span>(pool-&gt;queueSize == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 阻塞工作线程---此时工作线程等待生产者线程添加任务在继续</span></span><br><span class="line">            pthread_cond_wait(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解除阻塞(wait函数解除阻塞之后会先解锁后加锁)，诱导工作线程自杀</span></span><br><span class="line">            <span class="keyword">if</span>(pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pool-&gt;exitNum--;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;liveNum &gt; pool-&gt;minNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 活着的线程个数也需要-1 线程在wait函数中解除阻塞时，会自动加锁，因此此处不需要进行加锁操作</span></span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    <span class="comment">// 解锁</span></span><br><span class="line">                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    <span class="comment">// 终止调用线程---空闲的线程自己向下执行</span></span><br><span class="line">                    threadExit(pool);</span><br><span class="line">                    <span class="comment">// pthread_exit(NULL);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断线程池是否关闭（销毁）</span></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="comment">// 线程退出</span></span><br><span class="line">            threadExit(pool);</span><br><span class="line">            <span class="comment">//pthread_exit(NULL);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工作线程进行消费</span></span><br><span class="line">        Task task;</span><br><span class="line">        <span class="comment">// 从头部取任务</span></span><br><span class="line">        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;</span><br><span class="line">        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;</span><br><span class="line">        <span class="comment">// 移动队列头节点---对于循环队列</span></span><br><span class="line">        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">        <span class="comment">// 任务总个数-1</span></span><br><span class="line">        pool-&gt;queueSize--;</span><br><span class="line">        <span class="comment">// 唤醒阻塞在 队列满的条件变量(pool-&gt;notFull)  上的线程，此时已经消费了一个任务，队列不满了</span></span><br><span class="line">        <span class="comment">// 可以继续添加任务了</span></span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notFull);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出告知系统当前线程开始执行任务</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld start working... \n&quot;</span>,pthread_self());</span><br><span class="line">        <span class="comment">// 对于忙线程个数进行+1</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        task.function(task.arg);</span><br><span class="line">        <span class="comment">// 若传递的参数是一块堆内存则需要对其进行释放</span></span><br><span class="line">        <span class="built_in">free</span>(task.arg);</span><br><span class="line">        task.arg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 输出告知系统当前线程已经执行完毕任务</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld end working... \n&quot;</span>,pthread_self());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务执行完之后，忙线程需要-1</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-管理者线程任务函数"><a href="#3-管理者线程任务函数" class="headerlink" title="3.管理者线程任务函数"></a>3.管理者线程任务函数</h4><p><code>manager</code>函数</p><ul><li><p>参数：</p><p><code>void *</code>类型，在本实例代码中，传入的参数为指向线程池的指针，<code>Thread_Pool *pool</code></p></li><li><p>返回值：</p><p><code>void *</code>类型</p></li><li><p>业务逻辑:</p><p>在<code>while</code>循环中判断线程销毁的标志位是否为真</p><p>每隔3s检测一次</p><p>（1）添加工作线程：当工作线程忙不过来时，则需要继续添加工作线程，减轻系统任务压力</p><p>（2）销毁工作线程：当任务数量比较少，此时有较多空闲的工作线程，并且其数量满足一定条件关系时，则需要进行工作线程的销毁工作，在实例代码中进行工作线程的销毁思路比较巧妙。通过唤醒阻塞在<code>worker</code>函数中等待任务队列中继续添加任务的工作线程诱导其自杀。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** 管理者线程任务函数 *****/</span></span><br><span class="line"><span class="comment">// 用于创建线程与销毁多余空闲的线程</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread_Pool * pool = (Thread_Pool*)arg;</span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每隔3s检测一次</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出线程池中任务的数量和当前线程存活的数量</span></span><br><span class="line">        <span class="comment">// 需要加锁，避免数据混乱</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="type">int</span> queueSize = pool-&gt;queueSize;</span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出忙的线程数量</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***** 添加线程 ******/</span></span><br><span class="line">        <span class="comment">// 当工作线程忙不过来的时，需要继续添加线程</span></span><br><span class="line">        <span class="comment">// 任务的个数&gt;线程存活的个数  &amp;&amp; 存活的线程数 &lt; 最大线程数</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加锁 因为下面也操作了线程池的变量</span></span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;pool-&gt;maxNum &amp;&amp; counter &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 该线程ID没有被使用</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadIDs[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 创建新的线程</span></span><br><span class="line">                    pthread_create(&amp;pool-&gt;threadIDs[i],<span class="literal">NULL</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/***** 销毁线程 ******/</span></span><br><span class="line">        <span class="comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum *<span class="number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;liveNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 操作线程池中的变量需要进行加锁</span></span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;exitNum = NUMBER;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让空闲的工作线程自杀</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUMBER;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 若此时多余的线程是空闲的则说明此时的任务队列为空</span></span><br><span class="line">                <span class="comment">// 多余的线程此时阻塞在worker函数的pthread_cond_wait(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool)位置</span></span><br><span class="line">                <span class="comment">// 只需将其唤醒，使其在worker函数中向后执行并且自杀</span></span><br><span class="line">                pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Manager Thread,%ld exiting...............\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="comment">// 管理者线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-线程退出函数"><a href="#4-线程退出函数" class="headerlink" title="4.线程退出函数"></a>4.线程退出函数</h4><p><code>threadExit</code>函数</p><ul><li><p>参数：</p><p><code>void *</code>类型，在本实例代码中，传入的参数为指向线程池的指针，<code>Thread_Pool *pool</code></p></li><li><p>返回值：</p><p><code>void </code>类型</p></li><li><p>业务逻辑:</p><p>该线程退出函数针对的是，线程池中工作的子线程</p><p>在执行调用该函数的工作线程退出操作时，需要先对存储该工作线程ID的数组位置清除占用（重新赋值为0）</p><p>之后执行<code>pthread</code>库中的<code>pthread_exit(NULL)</code>退出该线程，并且对该线程进行资源回收，调用<code>pthread_join(tid,NULL)</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** 线程退出函数 ****/</span></span><br><span class="line"><span class="comment">// 存储退出线程id的数组位置需要进行清0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(Thread_Pool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;pool-&gt;maxNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到当前调用该函数的线程id的数组位置，对其进行归零</span></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            pool-&gt;threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;threadExit() called,%ld exiting...............\n&quot;</span>,tid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 退出的工作线程资源回收</span></span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-线程池添加任务函数"><a href="#5-线程池添加任务函数" class="headerlink" title="5.线程池添加任务函数"></a>5.线程池添加任务函数</h4><p><code>threadPoolAdd</code>函数</p><ul><li><p>参数：</p><p><code>void *</code>类型，在本实例代码中，传入的参数为指向线程池的指针，<code>Thread_Pool *pool</code></p><p>任务函数的地址，在形参中使用<code>void(*func)(void*)</code>类型的函数指针去指向</p><p>任务函数的参数<code>void* arg</code>类型</p></li><li><p>返回值：</p><p><code>void </code>类型</p></li><li><p>业务逻辑:</p><p>为线程池的任务队列中添加任务</p><p>在执行添加任务期间，需要添加互斥锁，不能多个线程同时添加任务又取出任务</p><p>（1）任务队列已满：需要对生产者线程进行阻塞，当消费者（工作线程）取出任务后可对生产者线程进行唤醒</p><p>（2）线程池销毁标志位为真：解开互斥锁，返回</p><p>（3）添加任务操作：循环队列队尾进行入队操作，添加完任务之后可以唤醒阻塞的工作线程继续工作</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** 线程池添加任务 ****/</span></span><br><span class="line"><span class="comment">// 生产者生产产品之后需要唤醒阻塞的消费者</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(Thread_Pool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 也需要锁住--避免有线程同时在任务队列中添加任务又在任务队列中取任务</span></span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="comment">// 若任务队列满</span></span><br><span class="line">    <span class="keyword">while</span>(pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞生产者线程</span></span><br><span class="line">        pthread_cond_wait(&amp;pool-&gt;notFull,&amp;pool-&gt;mutexPool);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程池关闭</span></span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程池没有关闭 则继续添加任务 添加到队尾</span></span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].function = func;</span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;</span><br><span class="line">    <span class="comment">// 队尾进行后移</span></span><br><span class="line">    pool-&gt;queueRear =(pool-&gt;queueRear + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">    <span class="comment">// 任务队列中的任务个数+1</span></span><br><span class="line">    pool-&gt;queueSize++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒阻塞在 队列为空pool-&gt;notEmpty 条件变量上的线程 有活干了</span></span><br><span class="line">    pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-销毁线程池函数"><a href="#6-销毁线程池函数" class="headerlink" title="6.销毁线程池函数"></a>6.销毁线程池函数</h4><p><code>threadPoolDestroy</code>函数</p><ul><li><p>参数：</p><p><code>void *</code>类型，在本实例代码中，传入的参数为指向线程池的指针，<code>Thread_Pool *pool</code></p></li><li><p>返回值：</p><p><code>void </code>类型</p></li><li><p>业务逻辑:</p><p>设置销毁线程池标志位<code>pool-&gt;shutdown</code>为真，赋值为1</p><p>（1）循环唤醒存活的消费者（工作线程）：在<code>worker</code>函数中<code>pool-&gt;shutdown &gt; 0</code>判断为真，则会执行代码块中的<code>threadExit(pool)</code>线程退出函数</p><p>（2）阻塞回收管理者线程：在<code>manager</code>函数中<code>pool-&gt;shutdown &gt; 0</code>判断为真，则会跳出循环执行<code>pthread</code>库中的线程退出函数<code>pthread_exit(NULL)</code>，在<code>threadPoolDestroy</code>函数中使用<code>pthread_join(pool-&gt;managerID,NULL)</code>函数对管理者线程进行阻塞回收</p><p>（3）释放内存：释放任务队列以及存储工作线程ID以及线程池的堆内存。</p><p>（4）销毁变量：销毁条件变量以及互斥锁变量</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(Thread_Pool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pool线程池指向的是一块非有效的地址</span></span><br><span class="line">    <span class="keyword">if</span>(pool == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    pool-&gt;shutdown = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 唤醒存活的消费者线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;pool-&gt;liveNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞回收管理者线程---等工作线程退出之后在对管理者线程进行资源回收</span></span><br><span class="line">    pthread_join(pool-&gt;managerID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放堆内存</span></span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;taskQ)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量与互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);</span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notEmpty);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notFull);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、测试代码"><a href="#六、测试代码" class="headerlink" title="六、测试代码"></a>六、测试代码</h3><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = *((<span class="type">int</span>*)arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld is working, number = %d\n&quot;</span>,pthread_self(), num);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建线程池 最少3个线程 最多10个线程 任务队列任务数容量100</span></span><br><span class="line">    Thread_Pool *pool = threadPoolCreate(<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加100个任务向任务队列中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *num = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *num = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 向线程池的任务队列中添加任务</span></span><br><span class="line">        threadPoolAdd(pool,taskFunc,num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程休眠---保证工作线程进行工作</span></span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁线程池</span></span><br><span class="line">    threadPoolDestroy(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.20</span>)</span><br><span class="line">project(untitled C)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"># 寻找线程库</span><br><span class="line">find_package(Threads REQUIRED)</span><br><span class="line"></span><br><span class="line">add_executable(untitled main.c threadpool.c threadpool.h)</span><br><span class="line"></span><br><span class="line"># 链接线程库</span><br><span class="line">target_link_libraries(untitled $&#123;CMAKE_THREAD_LIBS_INIT&#125;)</span><br></pre></td></tr></table></figure><h3 id="七、运行结果"><a href="#七、运行结果" class="headerlink" title="七、运行结果"></a>七、运行结果</h3><p>工作的10个消费者线程以及管理者线程均成功退出</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202312251507251.png" alt="image-20231225150734202"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵导数-drcan</title>
      <link href="/2023/12/15/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BCDr_can/"/>
      <url>/2023/12/15/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BCDr_can/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="矩阵导数"><a href="#矩阵导数" class="headerlink" title="矩阵导数"></a>矩阵导数</h2><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231215100332.png" alt="image-20231215100325738"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231215100540.png" alt="image-20231215100540687"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231215100348.png" alt="image-20231215100348548"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231215100357.png" alt="image-20231215100357447"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231215100409.png" alt="image-20231215100409256"></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优控制-动态规划-drcan-4</title>
      <link href="/2023/12/06/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6-LQR%E8%BD%A8%E8%BF%B9%E8%BF%BD%E8%B8%AA-Drcan-4/"/>
      <url>/2023/12/06/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6-LQR%E8%BD%A8%E8%BF%B9%E8%BF%BD%E8%B8%AA-Drcan-4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="最优控制-LQR轨迹追踪-Drcan-4"><a href="#最优控制-LQR轨迹追踪-Drcan-4" class="headerlink" title="最优控制-LQR轨迹追踪-Drcan-4"></a>最优控制-LQR轨迹追踪-Drcan-4</h2><h3 id="一、目标误差控制"><a href="#一、目标误差控制" class="headerlink" title="一、目标误差控制"></a>一、目标误差控制</h3><h4 id="1-建模"><a href="#1-建模" class="headerlink" title="1.建模"></a>1.建模</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204215846.png" alt="image-20231204215846670"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204215855.png" alt="image-20231204215855697"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204215901.png" alt="image-20231204215901814"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204215907.png" alt="image-20231204215907148"></p><h4 id="2-编程实现"><a href="#2-编程实现" class="headerlink" title="2.编程实现"></a>2.编程实现</h4><p><code>LQR_Test_tracking_E_offset_MSD.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 将轨迹追踪问题转换为 LQR问题</span></span><br><span class="line"><span class="comment">%% 程序初始化，清空工作空间，缓存</span></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统参数</span></span><br><span class="line">m_sys = <span class="number">1</span>;</span><br><span class="line"><span class="comment">% 定义阻尼系数</span></span><br><span class="line">b_sys = <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">% 定义弹簧弹性系数</span></span><br><span class="line">k_sys = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%% 系统定义 %%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 构建系统矩阵 A ,nxn</span></span><br><span class="line">A = [<span class="number">0</span> <span class="number">1</span> ;-k_sys/m_sys -b_sys/m_sys];</span><br><span class="line"><span class="comment">% 计算A矩阵维度</span></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 构建输入矩阵B ，nxp</span></span><br><span class="line">B = [<span class="number">0</span>;<span class="number">1</span>/m_sys];</span><br><span class="line"><span class="comment">% 计算输入矩阵维度</span></span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统离散 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 离散时间步长</span></span><br><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">% 连续系统转离散系统</span></span><br><span class="line"><span class="comment">% ss 函数用于创建状态空间模型,一般需要四个矩阵 A系统 B输入 C输出 D直通;   C矩阵需要和A矩阵的列数一致</span></span><br><span class="line">C = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">size</span>(A,<span class="number">2</span>));</span><br><span class="line">D = <span class="number">0</span>;</span><br><span class="line">sys = ss(A,B,C,D);</span><br><span class="line"><span class="comment">% c2d 函数用于将连续时间系统的状态空间模型、传递函数或零极点增益模型转换为离散时间模型</span></span><br><span class="line">sys_d = c2d(sys,Ts);</span><br><span class="line"><span class="comment">% 提取离散系统A矩阵</span></span><br><span class="line">A = sys_d.a;</span><br><span class="line"><span class="comment">% 提取离散系统B矩阵</span></span><br><span class="line">B = sys_d.b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 权重设计 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 设计系统状态权重矩阵Q, 维度 nxn</span></span><br><span class="line">Q = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统终值权重矩阵S，维度 nxn</span></span><br><span class="line">S = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统输入权重矩阵S，维度 pxp</span></span><br><span class="line">R = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统参考值 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 系统目标状态参考值</span></span><br><span class="line">xd = [<span class="number">1</span>;<span class="number">0</span>];</span><br><span class="line"><span class="comment">% 构建目标转移矩阵</span></span><br><span class="line">AD = <span class="built_in">eye</span>(n);  <span class="comment">% 状态向量为n维</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统初始化 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 初始化系统状态</span></span><br><span class="line">x0 = [<span class="number">1</span>;<span class="number">0</span>];</span><br><span class="line"><span class="comment">% 初始化状态赋值</span></span><br><span class="line">x = x0;</span><br><span class="line"><span class="comment">% 构建初始化增广矩阵</span></span><br><span class="line">[xa] = [x;xd]; </span><br><span class="line"><span class="comment">% 系统输入初始化</span></span><br><span class="line">u = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统运行步数</span></span><br><span class="line">k_steps = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 定义x_history零矩阵,用于存储系统状态结果,维度 n x k_step </span></span><br><span class="line">x_history = <span class="built_in">zeros</span>(n,k_steps); <span class="comment">% 状态变量维度为 nx1的</span></span><br><span class="line"><span class="comment">% 定义u_history零矩阵,用于存储系统输入结果,维度 p x k_step</span></span><br><span class="line">u_history = <span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 构建增广矩阵Ca</span></span><br><span class="line">Ca = [<span class="built_in">eye</span>(n) -<span class="built_in">eye</span>(n)];</span><br><span class="line"><span class="comment">% 构建增广矩阵Aa</span></span><br><span class="line">Aa = [A <span class="built_in">zeros</span>(n);<span class="built_in">zeros</span>(n) AD];</span><br><span class="line"><span class="comment">% 构建增广矩阵Ba</span></span><br><span class="line">Ba = [B;<span class="built_in">zeros</span>(n,<span class="number">1</span>)];</span><br><span class="line"><span class="comment">% 构建增广矩阵Sa</span></span><br><span class="line">Sa = transpose(Ca) * S * Ca;</span><br><span class="line"><span class="comment">% 构建增广矩阵Qa</span></span><br><span class="line">Qa = transpose(Ca) * Q * Ca;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 调用F1_LQR_Gain()函数 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">[F] = F1_LQR_Gain(Aa,Ba,Qa,R,Sa);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 仿真开始 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 仿真开始，建立for循环</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line">    <span class="comment">% 计算系统输入--所以每次提取 F_N 矩阵中的 (k-1)*p+1:k*p 行中的矩阵块 作为每一次的反馈增益</span></span><br><span class="line">    u = - F * xa;</span><br><span class="line">    <span class="comment">% 系统输入带入系统方程,计算系统响应--将得到的u作用到原系统中</span></span><br><span class="line">    x = A * x + B * u;</span><br><span class="line">    <span class="comment">% 更新增广矩阵xa</span></span><br><span class="line">    xa = [x;xd];</span><br><span class="line">    <span class="comment">% 保存系统状态到预先定义矩阵的相应位置</span></span><br><span class="line">    x_history(:,k+<span class="number">1</span>) = x;</span><br><span class="line">    <span class="comment">% 保存系统输入到预先定义矩阵的相应位置</span></span><br><span class="line">    u_history(:,k+<span class="number">1</span>) = u;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 结果 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% figure(1,&#x27;position&#x27;,[150 150 500 500]);</span></span><br><span class="line"><span class="comment">% 状态变量结果图</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="comment">% 系统状态x1结果图,质量块位移</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0</span>:<span class="built_in">length</span>(x_history)<span class="number">-1</span>,x_history(<span class="number">1</span>,:));</span><br><span class="line"><span class="comment">% 系统状态x2结果图,质量块位移</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0</span>:<span class="built_in">length</span>(x_history)<span class="number">-1</span>,x_history(<span class="number">2</span>,:),<span class="string">&#x27;--&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>  = <span class="number">1</span>:p</span><br><span class="line">    stairs(u_history(<span class="built_in">i</span>,:));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;u&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中</p><p><code>F1_LQR_Gain.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 将LQR控制封装为函数，最后迭代得到常数矩阵</span></span><br><span class="line"><span class="comment">%% 输入：系统矩阵 A，B； 权重矩阵 Q R S</span></span><br><span class="line"><span class="comment">%% 输出：反馈增益矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[F]</span> = <span class="title">F1_LQR_Gain</span><span class="params">(A,B,Q,R,S)</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算系统矩阵维度 n</span></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>); <span class="comment">% 行</span></span><br><span class="line"><span class="comment">% 计算输入矩阵维度 p</span></span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>); <span class="comment">% 列</span></span><br><span class="line"><span class="comment">% 系统终值代价权重矩阵,定义为P0  </span></span><br><span class="line">P0 = S;</span><br><span class="line"><span class="comment">% 定义最大迭代次数,用于限制程序运行时间</span></span><br><span class="line">max_iter= <span class="number">200</span>;</span><br><span class="line"><span class="comment">% 初始化矩阵P为0矩阵,后续用于存放计算得到的一系列矩阵P[k]</span></span><br><span class="line">P = <span class="built_in">zeros</span>(n,n*max_iter);</span><br><span class="line"><span class="comment">% 初始化矩阵P的第一个位置为P0</span></span><br><span class="line">P(:,<span class="number">1</span>:n) = P0;</span><br><span class="line"><span class="comment">% 定义 P[k-1]的初值为P0，即当k=1时</span></span><br><span class="line">P_k_min_1 = P0;</span><br><span class="line"><span class="comment">% 定义系统稳态误差阈值,用于判断系统是否到达稳态</span></span><br><span class="line">tol = <span class="number">1e-3</span>;</span><br><span class="line"><span class="comment">% 初始化系统误差为无穷</span></span><br><span class="line">diff  = Inf;</span><br><span class="line"><span class="comment">% 初始化系统反馈增益为无穷</span></span><br><span class="line">F_N_min_k = Inf;</span><br><span class="line"><span class="comment">% 初始化系统迭代步</span></span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 判断系统是否达到稳态,即相邻步的增益差是否小于预设阈值,如果达到稳态跳出while循环</span></span><br><span class="line"><span class="keyword">while</span> diff &gt; tol</span><br><span class="line">    <span class="comment">% 将系统增益F[N-k]赋值给Fpre[N-k],此步骤用于判断系统是否达到稳态</span></span><br><span class="line">    F_N_min_k_pre = F_N_min_k;</span><br><span class="line">    <span class="comment">% 计算F[N-k]</span></span><br><span class="line">    F_N_min_k = inv(R+B&#x27;*P_k_min_1*B)*B&#x27;*P_k_min_1*A;</span><br><span class="line">    <span class="comment">% 计算P[k]</span></span><br><span class="line">    P_k = (A-B*F_N_min_k)&#x27;*P_k_min_1*(A-B*F_N_min_k) + (F_N_min_k)&#x27;*R*(F_N_min_k) + Q;</span><br><span class="line">    <span class="comment">% 将P[k]矩阵存入P矩阵相应位置</span></span><br><span class="line">    P(:,n*k-n+<span class="number">1</span>:n*k) = P_k;</span><br><span class="line">    <span class="comment">% 更新P[k-1],用于下一次迭代</span></span><br><span class="line">    P_k_min_1 = P_k;</span><br><span class="line">    <span class="comment">% 计算系统相邻步增益差值</span></span><br><span class="line">    diff = <span class="built_in">abs</span>(<span class="built_in">max</span>(F_N_min_k - F_N_min_k_pre));  <span class="comment">% 最后迭代得到一个常矩阵，则增益误差就会很小，稳定</span></span><br><span class="line">    <span class="comment">% 迭代步加1</span></span><br><span class="line">    k = k+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">% 如果程序超过预设最大迭代步,则报错</span></span><br><span class="line">    <span class="keyword">if</span> k &gt; max_iter</span><br><span class="line">        error(<span class="string">&quot;Maximum Number of Iterations Exceeded&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出系统迭代步</span></span><br><span class="line">fprintf(<span class="string">&#x27;No. of Interation is %d \n&#x27;</span>,k);</span><br><span class="line"><span class="comment">% 模块输出：系统增益F</span></span><br><span class="line">F = F_N_min_k;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>运行结果</p><p><strong>系统在保证能耗小的情况下存在稳态误差，无法在满足性能指标足够好的情况下，同时保证目标的精确控制</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204220016.png" alt="image-20231204220016090"></p><h3 id="二、稳态非零参考值控制"><a href="#二、稳态非零参考值控制" class="headerlink" title="二、稳态非零参考值控制"></a>二、稳态非零参考值控制</h3><p><strong>在(一)中，存在一个问题（Q1），性能指标函数中与权重矩阵R有关的是系统的直接输入 u[k],若权重矩阵R过大的时候，u[k]则会躺平，甚至趋于0，无法在保证性能指标足够好的情况下，同时又对目标进行精确的跟踪</strong></p><p>为了解决这个问题，引出如下的控制方法：</p><h4 id="1-建模-1"><a href="#1-建模-1" class="headerlink" title="1.建模"></a>1.建模</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206104158.png" alt="image-20231206104151574"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206104211.png"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206104219.png" alt="image-20231206104219856"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206104228.png" alt="image-20231206104228515"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206104253.png" alt="image-20231206104253378"></p><h4 id="2-编程实现-1"><a href="#2-编程实现-1" class="headerlink" title="2.编程实现"></a>2.编程实现</h4><p><code>LQR_Test_tracking_SS_U_MSD.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 将轨迹追踪问题转换为 LQR问题</span></span><br><span class="line"><span class="comment">%% 程序初始化，清空工作空间，缓存</span></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统参数</span></span><br><span class="line">m_sys = <span class="number">1</span>;</span><br><span class="line"><span class="comment">% 定义阻尼系数</span></span><br><span class="line">b_sys = <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">% 定义弹簧弹性系数</span></span><br><span class="line">k_sys = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%% 系统定义 %%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 构建系统矩阵 A ,nxn</span></span><br><span class="line">A = [<span class="number">0</span> <span class="number">1</span> ;-k_sys/m_sys -b_sys/m_sys];</span><br><span class="line"><span class="comment">% 计算A矩阵维度</span></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 构建输入矩阵B ，nxp</span></span><br><span class="line">B = [<span class="number">0</span>;<span class="number">1</span>/m_sys];</span><br><span class="line"><span class="comment">% 计算输入矩阵维度</span></span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统离散 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 离散时间步长</span></span><br><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">% 连续系统转离散系统</span></span><br><span class="line"><span class="comment">% ss 函数用于创建状态空间模型,一般需要四个矩阵 A系统 B输入 C输出 D直通;   C矩阵需要和A矩阵的列数一致</span></span><br><span class="line">C = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">size</span>(A,<span class="number">2</span>));</span><br><span class="line">D = <span class="number">0</span>;</span><br><span class="line">sys = ss(A,B,C,D);</span><br><span class="line"><span class="comment">% c2d 函数用于将连续时间系统的状态空间模型、传递函数或零极点增益模型转换为离散时间模型</span></span><br><span class="line">sys_d = c2d(sys,Ts);</span><br><span class="line"><span class="comment">% 提取离散系统A矩阵</span></span><br><span class="line">A = sys_d.a;</span><br><span class="line"><span class="comment">% 提取离散系统B矩阵</span></span><br><span class="line">B = sys_d.b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 权重设计 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 设计系统状态权重矩阵Q, 维度 nxn</span></span><br><span class="line">Q = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统终值权重矩阵S，维度 nxn</span></span><br><span class="line">S = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统输入权重矩阵S，维度 pxp</span></span><br><span class="line">R = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统参考值 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 系统目标状态参考值</span></span><br><span class="line">xd = [<span class="number">1</span>;<span class="number">0</span>];</span><br><span class="line"><span class="comment">% 构建目标转移矩阵</span></span><br><span class="line">AD = <span class="built_in">eye</span>(n);  <span class="comment">% 状态向量为n维</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统初始化 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 初始化系统状态</span></span><br><span class="line">x0 = [<span class="number">0</span>;<span class="number">0</span>];</span><br><span class="line"><span class="comment">% 初始化状态赋值</span></span><br><span class="line">x = x0;</span><br><span class="line"><span class="comment">% 构建初始化增广矩阵</span></span><br><span class="line">[xa] = [x;xd]; </span><br><span class="line"><span class="comment">% 系统输入初始化</span></span><br><span class="line">u0 = <span class="number">1</span>;</span><br><span class="line">u = u0;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统运行步数</span></span><br><span class="line">k_steps = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 定义x_history零矩阵,用于存储系统状态结果,维度 n x k_step </span></span><br><span class="line">x_history = <span class="built_in">zeros</span>(n,k_steps); <span class="comment">% 状态变量维度为 nx1的</span></span><br><span class="line"><span class="comment">% 将系统状态初始值赋值到x_history矩阵第一个位置</span></span><br><span class="line">x_history(:,<span class="number">1</span>) = x;</span><br><span class="line"><span class="comment">% 定义u_history零矩阵,用于存储系统输入结果,维度 p x k_step</span></span><br><span class="line">u_history = <span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"><span class="comment">% 将系统初始输入保存在第一个位置</span></span><br><span class="line">u_history(:,<span class="number">1</span>) = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用模块[F2],计算系统增广矩阵Aa,Ba,Qa,Sa,R以及目标输入ud</span></span><br><span class="line">[Aa,Ba,Qa,Sa,R,ud] = F2_InputAugmentMatrix_SS_U(A,B,Q,R,S,xd);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 调用F1_LQR_Gain()函数 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">[F] = F1_LQR_Gain(Aa,Ba,Qa,R,Sa);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 仿真开始 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 仿真开始，建立for循环</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line">    <span class="comment">% 计算系统输入</span></span><br><span class="line">    u = -F * xa + ud;</span><br><span class="line">    <span class="comment">% 系统输入带入系统方程,计算系统响应--将得到的u作用到原系统中</span></span><br><span class="line">    x = A * x + B * u;</span><br><span class="line">    <span class="comment">% 更新增广矩阵xa</span></span><br><span class="line">    xa = [x;xd];</span><br><span class="line">    <span class="comment">% 保存系统状态到预先定义矩阵的相应位置</span></span><br><span class="line">    x_history(:,k+<span class="number">1</span>) = x;</span><br><span class="line">    <span class="comment">% 保存系统输入到预先定义矩阵的相应位置</span></span><br><span class="line">    u_history(:,k+<span class="number">1</span>) = u;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 结果 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 通过 figure 函数的参数来自定义窗口的属性，例如窗口大小、位置、标题等。position表示位置 后面的数组表示窗口大小</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;position&#x27;</span>,[<span class="number">150</span> <span class="number">150</span> <span class="number">1000</span> <span class="number">1000</span>]);</span><br><span class="line"><span class="comment">% 状态变量结果图</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="comment">% 系统状态x1结果图,质量块位移</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0</span>:<span class="built_in">length</span>(x_history)<span class="number">-1</span>,x_history(<span class="number">1</span>,:));</span><br><span class="line"><span class="comment">% 系统状态x2结果图,质量块位移</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0</span>:<span class="built_in">length</span>(x_history)<span class="number">-1</span>,x_history(<span class="number">2</span>,:),<span class="string">&#x27;--&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>  = <span class="number">1</span>:p</span><br><span class="line">    stairs(u_history(<span class="built_in">i</span>,:));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;u&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中</p><p><code>F2_InputAugmentMatrix_SS_U.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">%% 输入: 系统矩阵 A,B 权重矩阵:Q,R,S;  稳态目标状态: xd</span></span><br><span class="line"><span class="comment">%% 输出: 增广矩阵 Aa,Ba,Sa,Qa.  权重矩阵 R ，稳态控制输入 ud</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[Aa,Ba,Qa,Sa,R,ud]</span> = <span class="title">F2_InputAugmentMatrix_SS_U</span><span class="params">(A,B,Q,R,S,xd)</span>;</span></span><br><span class="line">    <span class="comment">% 计算系统矩阵维度,n</span></span><br><span class="line">    n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">% 计算输入矩阵维度</span></span><br><span class="line">    p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">% 构建增广矩阵Ca</span></span><br><span class="line">    Ca = [<span class="built_in">eye</span>(n) -<span class="built_in">eye</span>(n)];</span><br><span class="line">    <span class="comment">% 构建增广矩阵Aa</span></span><br><span class="line">    Aa = [A <span class="built_in">eye</span>(n)-A;<span class="built_in">zeros</span>(n) <span class="built_in">eye</span>(n)];</span><br><span class="line">    <span class="comment">% 构建增广矩阵Ba</span></span><br><span class="line">    Ba = [B;<span class="built_in">zeros</span>(n,p)];</span><br><span class="line">    <span class="comment">% 构建增广矩阵Sa</span></span><br><span class="line">    Sa = transpose(Ca) * S * Ca;</span><br><span class="line">    <span class="comment">% 构建增广矩阵Qa</span></span><br><span class="line">    Qa = transpose(Ca) * Q * Ca;</span><br><span class="line">    <span class="comment">% 设计权重矩阵R。此处R不变化</span></span><br><span class="line">    R = R;</span><br><span class="line">    <span class="comment">% 计算稳态控制输入ud</span></span><br><span class="line">    <span class="comment">% mldivide 函数(求解线性方程组)，通常通过反斜杠 \ 表示，是用于解决线性方程组的一种非常有效的方法。它被用于计算线性方程组 Ax = B 的解，其中 A 是一个矩阵，x 是一个未知向量，而 B 是一个已知向量或矩阵</span></span><br><span class="line">    ud = mldivide(B,(<span class="built_in">eye</span>(n) - A)*xd);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="（1）运行结果"><a href="#（1）运行结果" class="headerlink" title="（1）运行结果"></a>（1）运行结果</h5><p><strong>对于测试1</strong>，R&#x3D;0.1,对于输入的功耗关注比重不大，因此系统超调较小</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206105216.png" alt="image-20231206105216822"></p><p><strong>对于测试2</strong>，R&#x3D;1,对于输入的功耗关注比重较大，因此系统超调较大，典型的欠阻尼系统</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206105317.png" alt="image-20231206105317664"></p><h3 id="三、输入增量控制"><a href="#三、输入增量控制" class="headerlink" title="三、输入增量控制"></a>三、输入增量控制</h3><p><strong>在(二、稳态非零参考值控制)中，目标状态为一个常量定值Xd,但是若Xd非定值呢？如何解决</strong></p><h4 id="1-建模-2"><a href="#1-建模-2" class="headerlink" title="1.建模"></a>1.建模</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206162630.png" alt="image-20231206162629971"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206162658.png" alt="image-20231206162658016"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206162706.png" alt="image-20231206162706765"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206162713.png" alt="image-20231206162713324"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206162720.png" alt="image-20231206162720531"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206162727.png" alt="image-20231206162727433"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206162735.png" alt="image-20231206162735728"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206162743.png" alt="image-20231206162743488"></p><h4 id="2-编程实现-2"><a href="#2-编程实现-2" class="headerlink" title="2.编程实现"></a>2.编程实现</h4><p><code>F3_InputAugmentMatrix_Delta_U.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">%% 输入: 系统矩阵 A,B 权重矩阵:Q,R,S;  目标转移矩阵:AD</span></span><br><span class="line"><span class="comment">%% 输出: 增广矩阵 Aa,Ba,Sa,Qa.  权重矩阵 R </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[Aa,Ba,Qa,Sa,R]</span> = <span class="title">F3_InputAugmentMatrix_Delta_U</span><span class="params">(A,B,Q,R,S,AD)</span>;</span></span><br><span class="line">    <span class="comment">% 计算系统矩阵维度,n</span></span><br><span class="line">    n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">% 计算输入矩阵维度</span></span><br><span class="line">    p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">% 构建增广矩阵Ca</span></span><br><span class="line">    Ca = [<span class="built_in">eye</span>(n) -<span class="built_in">eye</span>(n) <span class="built_in">zeros</span>(n,p)];</span><br><span class="line">    <span class="comment">% 构建增广矩阵Aa</span></span><br><span class="line">    Aa = [A <span class="built_in">zeros</span>(n) B;<span class="built_in">zeros</span>(n) AD <span class="built_in">zeros</span>(n,p); <span class="built_in">zeros</span>(p,n) <span class="built_in">zeros</span>(p,n) <span class="built_in">eye</span>(p,p)];</span><br><span class="line">    <span class="comment">% 构建增广矩阵Ba</span></span><br><span class="line">    Ba = [B;<span class="built_in">zeros</span>(n,p);<span class="built_in">eye</span>(p)];</span><br><span class="line">    <span class="comment">% 构建增广矩阵Sa</span></span><br><span class="line">    Sa = transpose(Ca) * S * Ca;</span><br><span class="line">    <span class="comment">% 构建增广矩阵Qa</span></span><br><span class="line">    Qa = transpose(Ca) * Q * Ca;</span><br><span class="line">    <span class="comment">% 设计的权重矩阵R，不发生改变此处</span></span><br><span class="line">    R = R;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="（1）目标状态xd仍为常量"><a href="#（1）目标状态xd仍为常量" class="headerlink" title="（1）目标状态xd仍为常量"></a>（1）目标状态xd仍为常量</h5><p><code>LQR_Test_tracking_Delta_U_MSD_1.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 将轨迹追踪问题转换为 LQR问题</span></span><br><span class="line"><span class="comment">%% 程序初始化，清空工作空间，缓存</span></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统参数</span></span><br><span class="line">m_sys = <span class="number">1</span>;</span><br><span class="line"><span class="comment">% 定义阻尼系数</span></span><br><span class="line">b_sys = <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">% 定义弹簧弹性系数</span></span><br><span class="line">k_sys = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%% 系统定义 %%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 构建系统矩阵 A ,nxn</span></span><br><span class="line">A = [<span class="number">0</span> <span class="number">1</span> ;-k_sys/m_sys -b_sys/m_sys];</span><br><span class="line"><span class="comment">% 计算A矩阵维度</span></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 构建输入矩阵B ，nxp</span></span><br><span class="line">B = [<span class="number">0</span>;<span class="number">1</span>/m_sys];</span><br><span class="line"><span class="comment">% 计算输入矩阵维度</span></span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统离散 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 离散时间步长</span></span><br><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">% 连续系统转离散系统</span></span><br><span class="line"><span class="comment">% ss 函数用于创建状态空间模型,一般需要四个矩阵 A系统 B输入 C输出 D直通;   C矩阵需要和A矩阵的列数一致</span></span><br><span class="line">C = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">size</span>(A,<span class="number">2</span>));</span><br><span class="line">D = <span class="number">0</span>;</span><br><span class="line">sys = ss(A,B,C,D);</span><br><span class="line"><span class="comment">% c2d 函数用于将连续时间系统的状态空间模型、传递函数或零极点增益模型转换为离散时间模型</span></span><br><span class="line">sys_d = c2d(sys,Ts);</span><br><span class="line"><span class="comment">% 提取离散系统A矩阵</span></span><br><span class="line">A = sys_d.a;</span><br><span class="line"><span class="comment">% 提取离散系统B矩阵</span></span><br><span class="line">B = sys_d.b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 权重设计 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 设计系统状态权重矩阵Q, 维度 nxn</span></span><br><span class="line">Q = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统终值权重矩阵S，维度 nxn</span></span><br><span class="line">S = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统输入权重矩阵S，维度 pxp</span></span><br><span class="line">R = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统参考值 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 常数目标状态</span></span><br><span class="line"><span class="comment">% 系统目标状态参考值</span></span><br><span class="line">xd = [<span class="number">1</span>;<span class="number">0</span>];</span><br><span class="line"><span class="comment">% 构建目标转移矩阵</span></span><br><span class="line">AD = <span class="built_in">eye</span>(n);  <span class="comment">% 状态向量为n维</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统初始化 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 初始化系统状态</span></span><br><span class="line">x0 = [<span class="number">0</span>;<span class="number">0</span>];</span><br><span class="line"><span class="comment">% 初始化状态赋值</span></span><br><span class="line">x = x0;</span><br><span class="line"><span class="comment">% 系统输入初始化</span></span><br><span class="line">u0 = <span class="number">0</span>;</span><br><span class="line">u = u0;</span><br><span class="line"><span class="comment">% 构建初始化增广矩阵</span></span><br><span class="line">[xa] = [x;xd;u]; </span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统运行步数</span></span><br><span class="line">k_steps = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 定义x_history零矩阵,用于存储系统状态结果,维度 n x k_step </span></span><br><span class="line">x_history = <span class="built_in">zeros</span>(n,k_steps); <span class="comment">% 状态变量维度为 nx1的</span></span><br><span class="line"><span class="comment">% 将系统状态初始值赋值到x_history矩阵第一个位置</span></span><br><span class="line">x_history(:,<span class="number">1</span>) = x;</span><br><span class="line"><span class="comment">% 定义u_history零矩阵,用于存储系统输入结果,维度 p x k_step</span></span><br><span class="line">u_history = <span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"><span class="comment">% 将系统初始输入保存在第一个位置</span></span><br><span class="line">u_history(:,<span class="number">1</span>) = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用模块[F3],计算系统增广矩阵Aa,Ba,Qa,Sa,R</span></span><br><span class="line">[Aa,Ba,Qa,Sa,R] = F3_InputAugmentMatrix_Delta_U(A,B,Q,R,S,AD);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 调用F1_LQR_Gain()函数 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 计算系统反馈增益</span></span><br><span class="line">[F] = F1_LQR_Gain(Aa,Ba,Qa,R,Sa);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 仿真开始 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 仿真开始，建立for循环</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line">    <span class="comment">% 计算系统输入增量</span></span><br><span class="line">    Delta_u = -F * xa;</span><br><span class="line">    <span class="comment">% 计算系统输入</span></span><br><span class="line">    u = Delta_u + u;</span><br><span class="line">    <span class="comment">% 系统输入带入系统方程,计算系统响应--将得到的u作用到原系统中</span></span><br><span class="line">    x = A * x + B * u;</span><br><span class="line">    <span class="comment">% 更新系统增广状态</span></span><br><span class="line">    xd = AD * xd;</span><br><span class="line">    xa = [x;xd;u]; <span class="comment">% x xd 均是k+1时刻的值 而 u是k时刻的值</span></span><br><span class="line">    <span class="comment">% 保存系统状态到预先定义矩阵的相应位置</span></span><br><span class="line">    x_history(:,k+<span class="number">1</span>) = x;</span><br><span class="line">    <span class="comment">% 保存系统输入到预先定义矩阵的相应位置</span></span><br><span class="line">    u_history(:,k) = u;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 结果 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 通过 figure 函数的参数来自定义窗口的属性，例如窗口大小、位置、标题等。position表示位置 后面的数组表示窗口大小</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;position&#x27;</span>,[<span class="number">150</span> <span class="number">150</span> <span class="number">1000</span> <span class="number">1000</span>]);</span><br><span class="line"><span class="comment">% 状态变量结果图</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="comment">% 系统状态x1结果图,质量块位移</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0</span>:<span class="built_in">length</span>(x_history)<span class="number">-1</span>,x_history(<span class="number">1</span>,:));</span><br><span class="line"><span class="comment">% 系统状态x2结果图,质量块位移</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0</span>:<span class="built_in">length</span>(x_history)<span class="number">-1</span>,x_history(<span class="number">2</span>,:),<span class="string">&#x27;--&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>  = <span class="number">1</span>:p</span><br><span class="line">    stairs(u_history(<span class="built_in">i</span>,:));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;u&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><strong>对于测试1</strong>，R &#x3D; 0.1时，输入u[k]的变化幅度较大</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206163309.png" alt="image-20231206163309803"></p><p><strong>对于测试2</strong>，R &#x3D;1时，输入u[k]的变化幅度较小</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206163344.png" alt="image-20231206163344033"></p><h5 id="（2）若目标状态非常数参考值，系统状态非匀速变化"><a href="#（2）若目标状态非常数参考值，系统状态非匀速变化" class="headerlink" title="（2）若目标状态非常数参考值，系统状态非匀速变化"></a>（2）若目标状态非常数参考值，系统状态非匀速变化</h5><p><code>LQR_Test_tracking_Delta_U_MSD_2.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 将轨迹追踪问题转换为 LQR问题</span></span><br><span class="line"><span class="comment">%% 程序初始化，清空工作空间，缓存</span></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统参数</span></span><br><span class="line">m_sys = <span class="number">1</span>;</span><br><span class="line"><span class="comment">% 定义阻尼系数</span></span><br><span class="line">b_sys = <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">% 定义弹簧弹性系数</span></span><br><span class="line">k_sys = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%% 系统定义 %%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 构建系统矩阵 A ,nxn</span></span><br><span class="line">A = [<span class="number">0</span> <span class="number">1</span> ;-k_sys/m_sys -b_sys/m_sys];</span><br><span class="line"><span class="comment">% 计算A矩阵维度</span></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 构建输入矩阵B ，nxp</span></span><br><span class="line">B = [<span class="number">0</span>;<span class="number">1</span>/m_sys];</span><br><span class="line"><span class="comment">% 计算输入矩阵维度</span></span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统离散 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 离散时间步长</span></span><br><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">% 连续系统转离散系统</span></span><br><span class="line"><span class="comment">% ss 函数用于创建状态空间模型,一般需要四个矩阵 A系统 B输入 C输出 D直通;   C矩阵需要和A矩阵的列数一致</span></span><br><span class="line">C = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">size</span>(A,<span class="number">2</span>));</span><br><span class="line">D = <span class="number">0</span>;</span><br><span class="line">sys = ss(A,B,C,D);</span><br><span class="line"><span class="comment">% c2d 函数用于将连续时间系统的状态空间模型、传递函数或零极点增益模型转换为离散时间模型</span></span><br><span class="line">sys_d = c2d(sys,Ts);</span><br><span class="line"><span class="comment">% 提取离散系统A矩阵</span></span><br><span class="line">A = sys_d.a;</span><br><span class="line"><span class="comment">% 提取离散系统B矩阵</span></span><br><span class="line">B = sys_d.b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 权重设计 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 设计系统状态权重矩阵Q, 维度 nxn</span></span><br><span class="line">Q = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统终值权重矩阵S，维度 nxn</span></span><br><span class="line">S = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统输入权重矩阵S，维度 pxp</span></span><br><span class="line">R = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统参考值 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 非常数 目标状态</span></span><br><span class="line">xd = [<span class="number">0</span>;<span class="number">0.2</span>];</span><br><span class="line"><span class="comment">% 构建目标转移矩阵</span></span><br><span class="line">AD = c2d(ss([<span class="number">0</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span>],[<span class="number">0</span>;<span class="number">0</span>],[<span class="number">0</span> <span class="number">0</span>],[<span class="number">0</span>]),<span class="number">0.1</span>).a;  <span class="comment">% 状态向量为n维</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 系统初始化 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 初始化系统状态</span></span><br><span class="line">x0 = [<span class="number">0</span>;<span class="number">0</span>];</span><br><span class="line"><span class="comment">% 初始化状态赋值</span></span><br><span class="line">x = x0;</span><br><span class="line"><span class="comment">% 系统输入初始化</span></span><br><span class="line">u0 = <span class="number">0</span>;</span><br><span class="line">u = u0;</span><br><span class="line"><span class="comment">% 构建初始化增广矩阵</span></span><br><span class="line">[xa] = [x;xd;u]; </span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统运行步数</span></span><br><span class="line">k_steps = <span class="number">200</span>;</span><br><span class="line"><span class="comment">% 定义x_history零矩阵,用于存储系统状态结果,维度 n x k_step </span></span><br><span class="line">x_history = <span class="built_in">zeros</span>(n,k_steps); <span class="comment">% 状态变量维度为 nx1的</span></span><br><span class="line"><span class="comment">% 将系统状态初始值赋值到x_history矩阵第一个位置</span></span><br><span class="line">x_history(:,<span class="number">1</span>) = x;</span><br><span class="line"><span class="comment">% 定义u_history零矩阵,用于存储系统输入结果,维度 p x k_step</span></span><br><span class="line">u_history = <span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"><span class="comment">% 将系统初始输入保存在第一个位置</span></span><br><span class="line">u_history(:,<span class="number">1</span>) = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用模块[F3],计算系统增广矩阵Aa,Ba,Qa,Sa,R</span></span><br><span class="line">[Aa,Ba,Qa,Sa,R] = F3_InputAugmentMatrix_Delta_U(A,B,Q,R,S,AD);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 调用F1_LQR_Gain()函数 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 计算系统反馈增益</span></span><br><span class="line">[F] = F1_LQR_Gain(Aa,Ba,Qa,R,Sa);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 仿真开始 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 仿真开始，建立for循环</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line">    <span class="comment">% 系统目标状态不再是常数，if else 语句定义不同阶段的系统目标状态</span></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">50</span>)</span><br><span class="line">        xd = [xd(<span class="number">1</span>);<span class="number">-0.2</span>];</span><br><span class="line">    <span class="keyword">elseif</span>(k==<span class="number">100</span>)</span><br><span class="line">        xd = [xd(<span class="number">1</span>);<span class="number">0.2</span>];</span><br><span class="line">    <span class="keyword">elseif</span>(k==<span class="number">150</span>)</span><br><span class="line">        xd = [xd(<span class="number">1</span>);<span class="number">-0.2</span>];</span><br><span class="line">    <span class="keyword">elseif</span>(k==<span class="number">200</span>)</span><br><span class="line">        xd = [xd(<span class="number">1</span>);<span class="number">0.2</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 计算系统输入增量</span></span><br><span class="line">    Delta_u = -F * xa;</span><br><span class="line">    <span class="comment">% 计算系统输入</span></span><br><span class="line">    u = Delta_u + u;</span><br><span class="line">    <span class="comment">% 系统输入带入系统方程,计算系统响应--将得到的u作用到原系统中</span></span><br><span class="line">    x = A * x + B * u;</span><br><span class="line">    <span class="comment">% 更新系统增广状态</span></span><br><span class="line">    xd = AD * xd;</span><br><span class="line">    xa = [x;xd;u]; <span class="comment">% x xd 均是k+1时刻的值 而 u是k时刻的值</span></span><br><span class="line">    <span class="comment">% 保存系统状态到预先定义矩阵的相应位置</span></span><br><span class="line">    x_history(:,k+<span class="number">1</span>) = x;</span><br><span class="line">    <span class="comment">% 保存系统输入到预先定义矩阵的相应位置</span></span><br><span class="line">    u_history(:,k) = u;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% %%%%%%%%%%%%%%%%%%%%%% 结果 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 通过 figure 函数的参数来自定义窗口的属性，例如窗口大小、位置、标题等。position表示位置 后面的数组表示窗口大小</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;position&#x27;</span>,[<span class="number">150</span> <span class="number">150</span> <span class="number">1000</span> <span class="number">1000</span>]);</span><br><span class="line"><span class="comment">% 状态变量结果图</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="comment">% 系统状态x1结果图,质量块位移</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0</span>:<span class="built_in">length</span>(x_history)<span class="number">-1</span>,x_history(<span class="number">1</span>,:));</span><br><span class="line"><span class="comment">% 系统状态x2结果图,质量块位移</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0</span>:<span class="built_in">length</span>(x_history)<span class="number">-1</span>,x_history(<span class="number">2</span>,:),<span class="string">&#x27;--&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>  = <span class="number">1</span>:p</span><br><span class="line">    stairs(u_history(<span class="built_in">i</span>,:));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;u&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行结果</p><p><strong>可以看到x2在0.2  -0.2  0.2  -0.2 之间变化  控制输入也在变化使得系统对状态轨迹进行跟踪</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231206172201.png" alt="image-20231206172201918"></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优控制-动态规划-drcan-3</title>
      <link href="/2023/12/06/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6-LQR-drcan-3/"/>
      <url>/2023/12/06/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6-LQR-drcan-3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="最优控制-LQR-drcan-3"><a href="#最优控制-LQR-drcan-3" class="headerlink" title="最优控制-LQR-drcan-3"></a>最优控制-LQR-drcan-3</h2><h3 id="一、理论知识"><a href="#一、理论知识" class="headerlink" title="一、理论知识"></a>一、理论知识</h3><p><a href="https://www.bilibili.com/video/BV1dm4y177tA/?spm_id_from=333.788">视频教程链接：drcan老师</a></p><p><strong>LQR的全称是线性二次型调节器（Linear Quadratic Regulator）</strong><br>Linear线性，指的是LQR需要一个线性模型，这个模型通常用一组动态方程和输出方程描述系统。如果一个系统满足线性定理，那么它所遵循的动态可以表示为线性方程。其中，“线性”一词指的是，当每个输入变量与某个参数按比例变化时，输出变量也会相应按比例变化</p><p>Quadratic二次，是指二次代价函数的意思。在LQR控制的过程中，通过设计一个二次型的代价函数来描述控制系统的性能指标，并通过最小化该二次型代价函数来实现系统的优化调节。</p><p><strong>LQR不是一种控制器？</strong><br>PID（比例-积分-微分）控制器是一种经典的反馈控制器，它本身就是一种控制器。而LQR（线性二次型调节）是进行最优控制设计的一种方法，在其中，我们需要使用数学工具帮助我们计算出一个<strong>反馈矩阵</strong>来实现最优的状态反馈控制</p><p><a href="https://zhuanlan.zhihu.com/p/623843252">龙胆也老师知乎</a></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204191730.png" alt="image-20231204191730374"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204191742.png" alt="image-20231204191742390"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204191753.png" alt="image-20231204191753402"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204191759.png" alt="image-20231204191759465"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204191810.png" alt="image-20231204191810897"></p><h3 id="二、编程实现"><a href="#二、编程实现" class="headerlink" title="二、编程实现"></a>二、编程实现</h3><h4 id="1-Code-1–迭代方法"><a href="#1-Code-1–迭代方法" class="headerlink" title="1.Code 1–迭代方法"></a>1.Code 1–迭代方法</h4><p><strong>通过对模型进行建模，得到反馈增益矩阵，编程实现控制过程</strong></p><p><code>LQR_Gain.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 通过迭代的方法实现LQR控制---当迭代次数非常大的时候，得到的系统反馈增益矩阵会趋于常数矩阵</span></span><br><span class="line"><span class="comment">%% 程序初始化，清空工作空间，缓存</span></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 系统定义 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统矩阵A</span></span><br><span class="line">A = [<span class="number">0</span> <span class="number">1</span>;<span class="number">-1</span> <span class="number">-0.5</span>];</span><br><span class="line"><span class="comment">% 计算系统矩阵A 的维度(1--&gt;获得行数)</span></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 定义输入矩阵B</span></span><br><span class="line">B = [<span class="number">0</span>;<span class="number">1</span>];</span><br><span class="line"><span class="comment">% 计算输入矩阵B 的维度（2--&gt;获得列数）</span></span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 系统离散 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%% 离散时间步长</span></span><br><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">%% 连续系统转离散系统</span></span><br><span class="line"><span class="comment">% ss 函数用于创建状态空间模型,一般需要四个矩阵 A系统 B输入 C输出 D直通;   C矩阵需要和A矩阵的列数一致</span></span><br><span class="line">C = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">size</span>(A,<span class="number">2</span>));</span><br><span class="line">D = <span class="number">0</span>;</span><br><span class="line">sys = ss(A,B,C,D);</span><br><span class="line"><span class="comment">% c2d 函数用于将连续时间系统的状态空间模型、传递函数或零极点增益模型转换为离散时间模型</span></span><br><span class="line">sys_d = c2d(sys,Ts);</span><br><span class="line"><span class="comment">%% 提取离散系统A矩阵</span></span><br><span class="line">A = sys_d.a;</span><br><span class="line"><span class="comment">%% 提取离散系统B矩阵</span></span><br><span class="line">B = sys_d.b;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 系统初始化 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 状态初始化</span></span><br><span class="line">x0 = [<span class="number">1</span>;<span class="number">0</span>];</span><br><span class="line">x = x0;</span><br><span class="line"><span class="comment">% 输入初始化</span></span><br><span class="line">u0 = <span class="number">0</span>;</span><br><span class="line">u = u0;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统运行步数</span></span><br><span class="line">k_steps = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 定义x_history零矩阵,用于存储系统状态结果,维度 n x k_step </span></span><br><span class="line">x_history = <span class="built_in">zeros</span>(n,k_steps); <span class="comment">% 状态变量维度为 nx1的</span></span><br><span class="line"><span class="comment">% 将系统状态初始值赋值到x_history矩阵第一个位置</span></span><br><span class="line">x_history(:,<span class="number">1</span>) = x;</span><br><span class="line"><span class="comment">% 定义u_history零矩阵,用于存储系统输入结果,维度 p x k_step</span></span><br><span class="line">u_history = <span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"><span class="comment">% 将系统输入初始值赋值到u_history矩阵第一个位置</span></span><br><span class="line">u_history(:,<span class="number">1</span>) = u;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 权重设计 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 设计系统状态权重矩阵Q, 维度 nxn</span></span><br><span class="line">Q = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统终值权重矩阵S，维度 nxn</span></span><br><span class="line">S = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统输入权重矩阵S，维度 pxp</span></span><br><span class="line">R = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义末端时刻</span></span><br><span class="line">N = k_steps;</span><br><span class="line">P_k = S;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 计算最优反馈增益</span></span><br><span class="line"><span class="comment">% 计算是从k=1--&gt;k=n顺着计算---但是使用F[N-k]是是逆着使用（使用逆向分级解析求解---J(N-1--&gt;N)代价中的F[N-1]最先求得）</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:N</span><br><span class="line">    <span class="comment">% 计算F[N-k]---F的维度是 pxn 的</span></span><br><span class="line">    F = inv(R+B&#x27;*P_k*B)*B&#x27;*P_k*A;</span><br><span class="line">    <span class="comment">% 计算P[k]</span></span><br><span class="line">    P_k = (A-B*F)&#x27;*P_k*(A-B*F) + (F)&#x27;*R*(F) + Q;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span></span><br><span class="line">        F_N = F;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        F_N = [F;F_N];   <span class="comment">% 将每次求解得到的F[N-k]逆着存储为一个矩阵,后面就可以顺着使用 &#x27;;&#x27; 表示矩阵中新增加一行</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 仿真开始，建立for循环</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line">    <span class="comment">% 计算系统输入--所以每次提取 F_N 矩阵中的 (k-1)*p+1:k*p 行中的矩阵块 作为每一次的反馈增益</span></span><br><span class="line">    u = -F_N((k<span class="number">-1</span>)*p+<span class="number">1</span>:k*p,:)* x;</span><br><span class="line">    <span class="comment">% 系统输入带入系统方程,计算系统响应</span></span><br><span class="line">    x = A * x + B * u;</span><br><span class="line">    <span class="comment">% 保存系统状态到预先定义矩阵的相应位置</span></span><br><span class="line">    x_history(:,k+<span class="number">1</span>) = x;</span><br><span class="line">    <span class="comment">% 保存系统输入到预先定义矩阵的相应位置</span></span><br><span class="line">    u_history(:,k+<span class="number">1</span>) = u;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 结果 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%% 结果视图：系统状态vs.运行步数</span></span><br><span class="line"><span class="comment">% subplot 函数用于在单个图窗中创建多个子图。这允许你在同一窗口中并排显示多个不同的图表</span></span><br><span class="line"><span class="comment">% subplot(m, n, p)---- m 和 n 分别指定了子图网格的行数和列数 ---- p 指定了当前激活的子图的位置。</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)  <span class="comment">% 单个图窗显示2*1个子图 该图为第1个子图</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>  = <span class="number">1</span>:n</span><br><span class="line">    <span class="built_in">plot</span>(x_history(<span class="built_in">i</span>,:));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% legend 函数用于向图表添加图例，以帮助识别图表中的各个数据系列</span></span><br><span class="line"><span class="comment">% num2str 函数用于将数字转换为字符串  --- &#x27;x %d&#x27; 格式化字符串</span></span><br><span class="line"><span class="built_in">legend</span>(num2str((<span class="number">1</span>:n)&#x27;,<span class="string">&#x27;x %d&#x27;</span>));</span><br><span class="line"><span class="comment">% xlim 函数用于设置或查询当前坐标轴的 x 轴的界限。这个函数非常有用，当你需要调整坐标轴的显示范围或者了解当前的显示范围时</span></span><br><span class="line"><span class="comment">% 你可以直接指定 x 轴的最小值和最大值来设置界限 --- xlim([xmin xmax])</span></span><br><span class="line">xlim([<span class="number">1</span>,k_steps]);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结果视图：系统输入vs.运行步数</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">% 单个图窗显示2*1个子图 该图为第2个子图</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>  = <span class="number">1</span>:p</span><br><span class="line">    stairs(u_history(<span class="built_in">i</span>,:));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>(num2str((<span class="number">1</span>:p)&#x27;,<span class="string">&#x27;u %d&#x27;</span>));</span><br><span class="line">xlim([<span class="number">1</span>,k_steps]);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>模型的目标状态为0，最后使得系统从初始状态趋于0状态</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204192408.png" alt="image-20231204192408227"></p><h4 id="2-Code-2–LQR封装函数"><a href="#2-Code-2–LQR封装函数" class="headerlink" title="2.Code 2–LQR封装函数"></a>2.Code 2–LQR封装函数</h4><p><strong><code>F1_LQR_Gain().m</code></strong></p><p>迭代次数非常大的时候，可以得到LQR实现过程中的反馈增益矩阵，会趋近一个常数矩阵，将LQR控制方法封装为一个函数，得到最后的常数矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 将LQR控制封装为函数，最后迭代得到常数矩阵</span></span><br><span class="line"><span class="comment">%% 输入：系统矩阵 A，B； 权重矩阵 Q R S</span></span><br><span class="line"><span class="comment">%% 输出：反馈增益矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[F]</span> = <span class="title">F1_LQR_Gain</span><span class="params">(A,B,Q,R,S)</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算系统矩阵维度 n</span></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>); <span class="comment">% 行</span></span><br><span class="line"><span class="comment">% 计算输入矩阵维度 p</span></span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>); <span class="comment">% 列</span></span><br><span class="line"><span class="comment">% 系统终值代价权重矩阵,定义为P0  </span></span><br><span class="line">P0 = S;</span><br><span class="line"><span class="comment">% 定义最大迭代次数,用于限制程序运行时间</span></span><br><span class="line">max_iter= <span class="number">200</span>;</span><br><span class="line"><span class="comment">% 初始化矩阵P为0矩阵,后续用于存放计算得到的一系列矩阵P[k]</span></span><br><span class="line">P = <span class="built_in">zeros</span>(n,n*max_iter);</span><br><span class="line"><span class="comment">% 初始化矩阵P的第一个位置为P0</span></span><br><span class="line">P(:,<span class="number">1</span>:n) = P0;</span><br><span class="line"><span class="comment">% 定义 P[k-1]的初值为P0，即当k=1时</span></span><br><span class="line">P_k_min_1 = P0;</span><br><span class="line"><span class="comment">% 定义系统稳态误差阈值,用于判断系统是否到达稳态</span></span><br><span class="line">tol = <span class="number">1e-3</span>;</span><br><span class="line"><span class="comment">% 初始化系统误差为无穷</span></span><br><span class="line">diff  = Inf;</span><br><span class="line"><span class="comment">% 初始化系统反馈增益为无穷</span></span><br><span class="line">F_N_min_k = Inf;</span><br><span class="line"><span class="comment">% 初始化系统迭代步</span></span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 判断系统是否达到稳态,即相邻步的增益差是否小于预设阈值,如果达到稳态跳出while循环</span></span><br><span class="line"><span class="keyword">while</span> diff &gt; tol</span><br><span class="line">    <span class="comment">% 将系统增益F[N-k]赋值给Fpre[N-k],此步骤用于判断系统是否达到稳态</span></span><br><span class="line">    F_N_min_k_pre = F_N_min_k;</span><br><span class="line">    <span class="comment">% 计算F[N-k]</span></span><br><span class="line">    F_N_min_k = inv(R+B&#x27;*P_k_min_1*B)*B&#x27;*P_k_min_1*A;</span><br><span class="line">    <span class="comment">% 计算P[k]</span></span><br><span class="line">    P_k = (A-B*F_N_min_k)&#x27;*P_k_min_1*(A-B*F_N_min_k) + (F_N_min_k)&#x27;*R*(F_N_min_k) + Q;</span><br><span class="line">    <span class="comment">% 将P[k]矩阵存入P矩阵相应位置</span></span><br><span class="line">    P(:,n*k-n+<span class="number">1</span>:n*k) = P_k;</span><br><span class="line">    <span class="comment">% 更新P[k-1],用于下一次迭代</span></span><br><span class="line">    P_k_min_1 = P_k;</span><br><span class="line">    <span class="comment">% 计算系统相邻步增益差值</span></span><br><span class="line">    diff = <span class="built_in">abs</span>(<span class="built_in">max</span>(F_N_min_k - F_N_min_k_pre));  <span class="comment">% 最后迭代得到一个常矩阵，则增益误差就会很小，稳定</span></span><br><span class="line">    <span class="comment">% 迭代步加1</span></span><br><span class="line">    k = k+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">% 如果程序超过预设最大迭代步,则报错</span></span><br><span class="line">    <span class="keyword">if</span> k &gt; max_iter</span><br><span class="line">        error(<span class="string">&quot;Maximum Number of Iterations Exceeded&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出系统迭代步</span></span><br><span class="line">fprintf(<span class="string">&#x27;No. of Interation is %d \n&#x27;</span>,k);</span><br><span class="line"><span class="comment">% 模块输出：系统增益F</span></span><br><span class="line">F = F_N_min_k;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="3-Code-3-–-函数测试（单个输入）"><a href="#3-Code-3-–-函数测试（单个输入）" class="headerlink" title="3.Code 3 – 函数测试（单个输入）"></a>3.Code 3 – 函数测试（单个输入）</h4><p><code>LQR_Test_Function.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 测试反馈增益矩阵函数--单输入</span></span><br><span class="line"><span class="comment">%% 程序初始化，清空工作空间，缓存</span></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 系统定义 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统矩阵A</span></span><br><span class="line">A = [<span class="number">0</span> <span class="number">1</span>;<span class="number">-1</span> <span class="number">-0.5</span>];</span><br><span class="line"><span class="comment">% 计算系统矩阵A 的维度(1--&gt;获得行数)</span></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 定义输入矩阵B</span></span><br><span class="line">B = [<span class="number">0</span>;<span class="number">1</span>];</span><br><span class="line"><span class="comment">% 计算输入矩阵B 的维度（2--&gt;获得列数）</span></span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 系统离散 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%% 离散时间步长</span></span><br><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">%% 连续系统转离散系统</span></span><br><span class="line"><span class="comment">% ss 函数用于创建状态空间模型,一般需要四个矩阵 A系统 B输入 C输出 D直通;   C矩阵需要和A矩阵的列数一致</span></span><br><span class="line">C = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">size</span>(A,<span class="number">2</span>));</span><br><span class="line">D = <span class="number">0</span>;</span><br><span class="line">sys = ss(A,B,C,D);</span><br><span class="line"><span class="comment">% c2d 函数用于将连续时间系统的状态空间模型、传递函数或零极点增益模型转换为离散时间模型</span></span><br><span class="line">sys_d = c2d(sys,Ts);</span><br><span class="line"><span class="comment">%% 提取离散系统A矩阵</span></span><br><span class="line">A = sys_d.a;</span><br><span class="line"><span class="comment">%% 提取离散系统B矩阵</span></span><br><span class="line">B = sys_d.b;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 系统初始化 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 状态初始化</span></span><br><span class="line">x0 = [<span class="number">1</span>;<span class="number">0</span>];</span><br><span class="line">x = x0;</span><br><span class="line"><span class="comment">% 输入初始化</span></span><br><span class="line">u0 = <span class="number">0</span>;</span><br><span class="line">u = u0;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统运行步数</span></span><br><span class="line">k_steps = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 定义x_history零矩阵,用于存储系统状态结果,维度 n x k_step </span></span><br><span class="line">x_history = <span class="built_in">zeros</span>(n,k_steps); <span class="comment">% 状态变量维度为 nx1的</span></span><br><span class="line"><span class="comment">% 将系统状态初始值赋值到x_history矩阵第一个位置</span></span><br><span class="line">x_history(:,<span class="number">1</span>) = x;</span><br><span class="line"><span class="comment">% 定义u_history零矩阵,用于存储系统输入结果,维度 p x k_step</span></span><br><span class="line">u_history = <span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"><span class="comment">% 将系统输入初始值赋值到u_history矩阵第一个位置</span></span><br><span class="line">u_history(:,<span class="number">1</span>) = u;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 权重设计 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 设计系统状态权重矩阵Q, 维度 nxn</span></span><br><span class="line">Q = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统终值权重矩阵S，维度 nxn</span></span><br><span class="line">S = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统输入权重矩阵S，维度 pxp</span></span><br><span class="line">R = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义末端时刻</span></span><br><span class="line">N = k_steps;</span><br><span class="line">P_k = S;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 计算最优反馈增益</span></span><br><span class="line"><span class="comment">% 调用函数得到常数反馈增益矩阵</span></span><br><span class="line">[F] = F1_LQR_Gain(A,B,Q,R,S);</span><br><span class="line"><span class="comment">% 仿真开始，建立for循环</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line">    <span class="comment">% 计算系统输入--所以每次提取 F_N 矩阵中的 (k-1)*p+1:k*p 行中的矩阵块 作为每一次的反馈增益</span></span><br><span class="line">    u = - F * x;</span><br><span class="line">    <span class="comment">% 系统输入带入系统方程,计算系统响应</span></span><br><span class="line">    x = A * x + B * u;</span><br><span class="line">    <span class="comment">% 保存系统状态到预先定义矩阵的相应位置</span></span><br><span class="line">    x_history(:,k+<span class="number">1</span>) = x;</span><br><span class="line">    <span class="comment">% 保存系统输入到预先定义矩阵的相应位置</span></span><br><span class="line">    u_history(:,k+<span class="number">1</span>) = u;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 结果 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%% 结果视图：系统状态vs.运行步数</span></span><br><span class="line"><span class="comment">% subplot 函数用于在单个图窗中创建多个子图。这允许你在同一窗口中并排显示多个不同的图表</span></span><br><span class="line"><span class="comment">% subplot(m, n, p)---- m 和 n 分别指定了子图网格的行数和列数 ---- p 指定了当前激活的子图的位置。</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)  <span class="comment">% 单个图窗显示2*1个子图 该图为第1个子图</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>  = <span class="number">1</span>:n</span><br><span class="line">    <span class="built_in">plot</span>(x_history(<span class="built_in">i</span>,:));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% legend 函数用于向图表添加图例，以帮助识别图表中的各个数据系列</span></span><br><span class="line"><span class="comment">% num2str 函数用于将数字转换为字符串  --- &#x27;x %d&#x27; 格式化字符串</span></span><br><span class="line"><span class="built_in">legend</span>(num2str((<span class="number">1</span>:n)&#x27;,<span class="string">&#x27;x %d&#x27;</span>));</span><br><span class="line"><span class="comment">% xlim 函数用于设置或查询当前坐标轴的 x 轴的界限。这个函数非常有用，当你需要调整坐标轴的显示范围或者了解当前的显示范围时</span></span><br><span class="line"><span class="comment">% 你可以直接指定 x 轴的最小值和最大值来设置界限 --- xlim([xmin xmax])</span></span><br><span class="line">xlim([<span class="number">1</span>,k_steps]);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结果视图：系统输入vs.运行步数</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">% 单个图窗显示2*1个子图 该图为第2个子图</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>  = <span class="number">1</span>:p</span><br><span class="line">    stairs(u_history(<span class="built_in">i</span>,:));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>(num2str((<span class="number">1</span>:p)&#x27;,<span class="string">&#x27;u %d&#x27;</span>));</span><br><span class="line">xlim([<span class="number">1</span>,k_steps]);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204192846.png" alt="image-20231204192846600"></p><h4 id="4-Code-4-–-函数测试（多个输入）"><a href="#4-Code-4-–-函数测试（多个输入）" class="headerlink" title="4.Code 4 – 函数测试（多个输入）"></a>4.Code 4 – 函数测试（多个输入）</h4><p><code>LQR_Test_Function_M_Input.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 测试反馈增益矩阵函数--多输入</span></span><br><span class="line"><span class="comment">%% 程序初始化，清空工作空间，缓存</span></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 系统定义 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统矩阵A</span></span><br><span class="line">A = [<span class="number">0</span> <span class="number">1</span>;<span class="number">-1</span> <span class="number">-0.5</span>];</span><br><span class="line"><span class="comment">% 计算系统矩阵A 的维度(1--&gt;获得行数)</span></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 定义输入矩阵B</span></span><br><span class="line">B = [<span class="number">0</span> <span class="number">0.2</span>;<span class="number">-0.1</span> <span class="number">0.5</span>];</span><br><span class="line"><span class="comment">% 计算输入矩阵B 的维度（2--&gt;获得列数）</span></span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 系统离散 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%% 离散时间步长</span></span><br><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">%% 连续系统转离散系统</span></span><br><span class="line"><span class="comment">% ss 函数用于创建状态空间模型,一般需要四个矩阵 A系统 B输入 C输出 D直通;   C矩阵需要和A矩阵的列数一致</span></span><br><span class="line">C = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">size</span>(A,<span class="number">2</span>));</span><br><span class="line">D = <span class="number">0</span>;</span><br><span class="line">sys = ss(A,B,C,D);</span><br><span class="line"><span class="comment">% c2d 函数用于将连续时间系统的状态空间模型、传递函数或零极点增益模型转换为离散时间模型</span></span><br><span class="line">sys_d = c2d(sys,Ts);</span><br><span class="line"><span class="comment">%% 提取离散系统A矩阵</span></span><br><span class="line">A = sys_d.a;</span><br><span class="line"><span class="comment">%% 提取离散系统B矩阵</span></span><br><span class="line">B = sys_d.b;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 系统初始化 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 状态初始化</span></span><br><span class="line">x0 = [<span class="number">1</span>;<span class="number">0</span>];</span><br><span class="line">x = x0;</span><br><span class="line"><span class="comment">% 输入初始化</span></span><br><span class="line">u0 = <span class="number">0</span>;</span><br><span class="line">u = u0;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 定义系统运行步数</span></span><br><span class="line">k_steps = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 定义x_history零矩阵,用于存储系统状态结果,维度 n x k_step </span></span><br><span class="line">x_history = <span class="built_in">zeros</span>(n,k_steps); <span class="comment">% 状态变量维度为 nx1的</span></span><br><span class="line"><span class="comment">% 将系统状态初始值赋值到x_history矩阵第一个位置</span></span><br><span class="line">x_history(:,<span class="number">1</span>) = x;</span><br><span class="line"><span class="comment">% 定义u_history零矩阵,用于存储系统输入结果,维度 p x k_step</span></span><br><span class="line">u_history = <span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"><span class="comment">% 将系统输入初始值赋值到u_history矩阵第一个位置</span></span><br><span class="line">u_history(:,<span class="number">1</span>) = u;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 权重设计 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 设计系统状态权重矩阵Q, 维度 nxn</span></span><br><span class="line">Q = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统终值权重矩阵S，维度 nxn</span></span><br><span class="line">S = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 设计系统输入权重矩阵S，维度 pxp</span></span><br><span class="line">R = [<span class="number">0.1</span> <span class="number">0</span>;<span class="number">0</span>,<span class="number">0.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义末端时刻</span></span><br><span class="line">N = k_steps;</span><br><span class="line">P_k = S;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 计算最优反馈增益</span></span><br><span class="line"><span class="comment">% 调用函数得到常数反馈增益矩阵</span></span><br><span class="line">[F] = F1_LQR_Gain(A,B,Q,R,S);</span><br><span class="line"><span class="comment">% 仿真开始，建立for循环</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line">    <span class="comment">% 计算系统输入--所以每次提取 F_N 矩阵中的 (k-1)*p+1:k*p 行中的矩阵块 作为每一次的反馈增益</span></span><br><span class="line">    u = - F * x;</span><br><span class="line">    <span class="comment">% 系统输入带入系统方程,计算系统响应</span></span><br><span class="line">    x = A * x + B * u;</span><br><span class="line">    <span class="comment">% 保存系统状态到预先定义矩阵的相应位置</span></span><br><span class="line">    x_history(:,k+<span class="number">1</span>) = x;</span><br><span class="line">    <span class="comment">% 保存系统输入到预先定义矩阵的相应位置</span></span><br><span class="line">    u_history(:,k+<span class="number">1</span>) = u;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% 结果 %%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%% 结果视图：系统状态vs.运行步数</span></span><br><span class="line"><span class="comment">% subplot 函数用于在单个图窗中创建多个子图。这允许你在同一窗口中并排显示多个不同的图表</span></span><br><span class="line"><span class="comment">% subplot(m, n, p)---- m 和 n 分别指定了子图网格的行数和列数 ---- p 指定了当前激活的子图的位置。</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)  <span class="comment">% 单个图窗显示2*1个子图 该图为第1个子图</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>  = <span class="number">1</span>:n</span><br><span class="line">    <span class="built_in">plot</span>(x_history(<span class="built_in">i</span>,:));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% legend 函数用于向图表添加图例，以帮助识别图表中的各个数据系列</span></span><br><span class="line"><span class="comment">% num2str 函数用于将数字转换为字符串  --- &#x27;x %d&#x27; 格式化字符串</span></span><br><span class="line"><span class="built_in">legend</span>(num2str((<span class="number">1</span>:n)&#x27;,<span class="string">&#x27;x %d&#x27;</span>));</span><br><span class="line"><span class="comment">% xlim 函数用于设置或查询当前坐标轴的 x 轴的界限。这个函数非常有用，当你需要调整坐标轴的显示范围或者了解当前的显示范围时</span></span><br><span class="line"><span class="comment">% 你可以直接指定 x 轴的最小值和最大值来设置界限 --- xlim([xmin xmax])</span></span><br><span class="line">xlim([<span class="number">1</span>,k_steps]);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结果视图：系统输入vs.运行步数</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">% 单个图窗显示2*1个子图 该图为第2个子图</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>  = <span class="number">1</span>:p</span><br><span class="line">    stairs(u_history(<span class="built_in">i</span>,:));</span><br><span class="line">    <span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>(num2str((<span class="number">1</span>:p)&#x27;,<span class="string">&#x27;u %d&#x27;</span>));</span><br><span class="line">xlim([<span class="number">1</span>,k_steps]);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204192943.png" alt="image-20231204192943154"></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优控制-动态规划-drcan-2</title>
      <link href="/2023/12/06/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-drcan-2/"/>
      <url>/2023/12/06/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-drcan-2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="最优控制-动态规划-drcan-2"><a href="#最优控制-动态规划-drcan-2" class="headerlink" title="最优控制-动态规划-drcan-2"></a>最优控制-动态规划-drcan-2</h2><p><a href="https://www.bilibili.com/video/BV1Ed4y1w7tR/?spm_id_from=333.788">视频教程–drcan老师</a></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204190525.png" alt="image-20231204190525728"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204190531.png" alt="image-20231204190531823"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204190538.png" alt="image-20231204190538308"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204190555.png" alt="image-20231204190555308"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204190601.png" alt="image-20231204190600957"></p><p><strong>采用逆向分级的方法编写代码，进行求解</strong></p><p><code>Dynamic_program_1.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">clc;clear all;close all;</span><br><span class="line"><span class="comment">% 初始状态</span></span><br><span class="line">h_init = <span class="number">0</span>;</span><br><span class="line">v_init = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 目标状态</span></span><br><span class="line">h_final = <span class="number">10</span>;</span><br><span class="line">v_final = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 约束条件 速度--加速度</span></span><br><span class="line">h_min = <span class="number">0</span>;</span><br><span class="line">h_max = <span class="number">10</span>;</span><br><span class="line">N_h = <span class="number">5</span>; <span class="comment">% 按照2米一个间隔，将10m分为5个间隔</span></span><br><span class="line">v_min = <span class="number">0</span>;</span><br><span class="line">v_max = <span class="number">3</span>;</span><br><span class="line">N_v = <span class="number">3</span>; <span class="comment">% 将速度分为 0-1-2-3，三个间隔</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建状态数组</span></span><br><span class="line">Hd = h_min:(h_max - h_min)/N_h:h_max;  <span class="comment">% 高度 0-2-4-6-8-10</span></span><br><span class="line">Vd = v_min:(v_max-v_min)/N_v:v_max;    <span class="comment">% 速度 0-1-2-3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义输入的约束(加速度)</span></span><br><span class="line">u_min = <span class="number">-3</span>;u_max = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 建立代价矩阵</span></span><br><span class="line">J_costtogo = <span class="built_in">zeros</span>(N_h+<span class="number">1</span>,N_v+<span class="number">1</span>); </span><br><span class="line"><span class="comment">% 创建加速度输入矩阵</span></span><br><span class="line">Input_acc = <span class="built_in">zeros</span>(N_h+<span class="number">1</span>,N_v+<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">% 从10m到8m</span></span><br><span class="line">v_avg = <span class="number">0.5</span> * (v_final + Vd); <span class="comment">% 平均速度</span></span><br><span class="line">T_delta = (h_max - h_min)./(N_h*v_avg); <span class="comment">% 时间</span></span><br><span class="line">acc = (<span class="number">0</span>-Vd)./T_delta; <span class="comment">% 加速度</span></span><br><span class="line">J_temp = T_delta;  <span class="comment">% 临时代价，还需要考虑系统的约束</span></span><br><span class="line">[acc_x,acc_y] = <span class="built_in">find</span>(acc &lt; u_min | acc &gt; u_max); <span class="comment">% 找到加速度超过约束的</span></span><br><span class="line">Ind_lin_acc  = <span class="built_in">sub2ind</span>(<span class="built_in">size</span>(acc),acc_x,acc_y); <span class="comment">% 找到矩阵acc对应位置的索引号</span></span><br><span class="line">J_temp(Ind_lin_acc) = <span class="built_in">inf</span>; <span class="comment">% 加速度超过约束的，代价变为无穷</span></span><br><span class="line">J_costtogo(<span class="number">2</span>,:) = J_temp; <span class="comment">% 将代价进行存储</span></span><br><span class="line">Input_acc(<span class="number">2</span>,:) = acc;     <span class="comment">% 将加速度进行存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 从8m到2m</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">3</span>:<span class="number">1</span>:N_h</span><br><span class="line">[Vd_x,Vd_y] = <span class="built_in">meshgrid</span>(Vd,Vd);</span><br><span class="line">v_avg = <span class="number">0.5</span> * (Vd_x + Vd_y); <span class="comment">% 从8m至6m有16中选择组合，需要计算16种选择各自的平均速度</span></span><br><span class="line">T_delta = (h_max - h_min)./(N_h * v_avg);</span><br><span class="line">acc = (Vd_y - Vd_x) ./ T_delta;</span><br><span class="line">J_temp = T_delta;</span><br><span class="line">[acc_x,acc_y] = <span class="built_in">find</span>(acc &lt; u_min | acc &gt; u_max); <span class="comment">% 找到加速度超过约束的</span></span><br><span class="line">Ind_lin_acc  = <span class="built_in">sub2ind</span>(<span class="built_in">size</span>(acc),acc_x,acc_y); <span class="comment">% 找到矩阵acc对应位置的索引号</span></span><br><span class="line">J_temp(Ind_lin_acc) = <span class="built_in">inf</span>;  <span class="comment">% 加速度超过约束的，代价变为无穷</span></span><br><span class="line"><span class="comment">% 重要的一步</span></span><br><span class="line">J_temp = J_temp + <span class="built_in">meshgrid</span>(J_costtogo(k<span class="number">-1</span>,:))&#x27;; <span class="comment">% 将上一步的代价添加上</span></span><br><span class="line">[J_costtogo(k,:),l] = <span class="built_in">min</span>(J_temp);  <span class="comment">% 得到最小的J_temp存储到下一行代价矩阵</span></span><br><span class="line">Ind_lin_acc = <span class="built_in">sub2ind</span>(<span class="built_in">size</span>(J_temp),l,<span class="number">1</span>:<span class="built_in">length</span>(l));</span><br><span class="line">Input_acc(k,:) = acc(Ind_lin_acc);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 从2m至0m</span></span><br><span class="line">v_avg = <span class="number">0.5</span> * (Vd+v_init); <span class="comment">% 平均速度</span></span><br><span class="line">T_delta = (h_max - h_min)./(N_h*v_avg); <span class="comment">% 时间</span></span><br><span class="line">acc = (Vd - v_init)./T_delta; <span class="comment">% 加速度</span></span><br><span class="line">J_temp = T_delta;  <span class="comment">% 临时代价，还需要考虑系统的约束</span></span><br><span class="line">[acc_x,acc_y] = <span class="built_in">find</span>(acc &lt; u_min | acc &gt; u_max); <span class="comment">% 找到加速度超过约束的</span></span><br><span class="line">Ind_lin_acc  = <span class="built_in">sub2ind</span>(<span class="built_in">size</span>(acc),acc_x,acc_y); <span class="comment">% 找到矩阵acc对应位置的索引号</span></span><br><span class="line">J_temp(Ind_lin_acc) = <span class="built_in">inf</span>; <span class="comment">% 加速度超过约束的，代价变为无穷</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 重要的一步</span></span><br><span class="line">J_temp = J_temp + J_costtogo(N_h,:);</span><br><span class="line">[J_costtogo(N_h+<span class="number">1</span>,<span class="number">1</span>),l] = <span class="built_in">min</span>(J_temp)</span><br><span class="line">Ind_lin_acc = <span class="built_in">sub2ind</span>(<span class="built_in">size</span>(J_temp),l);</span><br><span class="line">Input_acc(N_h+<span class="number">1</span>,l) = acc(Ind_lin_acc)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">J_costtogo =</span><br><span class="line"></span><br><span class="line">         <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span></span><br><span class="line">       Inf    <span class="number">4.0000</span>    <span class="number">2.0000</span>    <span class="number">1.3333</span></span><br><span class="line">    <span class="number">4.0000</span>    <span class="number">2.3333</span>    <span class="number">2.1333</span>    <span class="number">2.0000</span></span><br><span class="line">    <span class="number">4.1333</span>    <span class="number">3.0000</span>    <span class="number">2.8000</span>    <span class="number">2.6667</span></span><br><span class="line">    <span class="number">4.8000</span>    <span class="number">3.6667</span>    <span class="number">3.4667</span>    <span class="number">3.3333</span></span><br><span class="line">    <span class="number">5.4667</span>         <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l =</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input_acc =</span><br><span class="line"></span><br><span class="line">         <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span></span><br><span class="line">         <span class="number">0</span>   <span class="number">-0.2500</span>   <span class="number">-1.0000</span>   <span class="number">-2.2500</span></span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">2.0000</span>    <span class="number">1.2500</span>         <span class="number">0</span></span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">2.0000</span>    <span class="number">1.2500</span>         <span class="number">0</span></span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">2.0000</span>    <span class="number">1.2500</span>         <span class="number">0</span></span><br><span class="line">         <span class="number">0</span>         <span class="number">0</span>    <span class="number">1.0000</span>         <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优控制与性能指标-drcan-1</title>
      <link href="/2023/12/06/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-drcan-1/"/>
      <url>/2023/12/06/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-drcan-1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="最优控制与性能指标-drcan-1"><a href="#最优控制与性能指标-drcan-1" class="headerlink" title="最优控制与性能指标-drcan-1"></a>最优控制与性能指标-drcan-1</h2><p><a href="https://www.bilibili.com/video/BV1TV4y1u7TR/?spm_id_from=333.788&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程-drcan老师</a></p><p><strong>最优控制的实质:找到容许控制律，使得系统从初始状态转移到目标状态，并且某些性能指标达到极值。</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204185750.png" alt="image-20231204185743769"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204185907.png" alt="image-20231204185906970"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204185930.png" alt="image-20231204185930206"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204190011.png" alt="image-20231204190011612"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20231204190027.png" alt="image-20231204190027310"></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensor数据转换为稀疏矩阵</title>
      <link href="/2023/09/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch/Tensor%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"/>
      <url>/2023/09/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch/Tensor%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Tensor数据转换为稀疏矩阵"><a href="#Tensor数据转换为稀疏矩阵" class="headerlink" title="Tensor数据转换为稀疏矩阵"></a>Tensor数据转换为稀疏矩阵</h2><h3 id="一、稀疏矩阵"><a href="#一、稀疏矩阵" class="headerlink" title="一、稀疏矩阵"></a>一、稀疏矩阵</h3><p><a href="https://blog.csdn.net/weixin_51122816/article/details/117999250">原文链接</a></p><p>常用的稀疏矩阵存储格式有COO，<a href="https://so.csdn.net/so/search?q=CSR&spm=1001.2101.3001.7020">CSR</a>&#x2F;CSC，LIL</p><h4 id="1-COO"><a href="#1-COO" class="headerlink" title="1.COO"></a>1.COO</h4><p>COO(Coordinate format )是最为简单的格式，以三元组的形式存储稀疏矩阵。记录矩阵中非零元素的数值和所在的行序号和列序号。形式为（行号，列号，数值）。这种存储方式的主要优点是灵活、简单。但是缺点是不可以直接进行矩阵的相关运算</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/image-20230909002327571.png" alt="image-20230909002327571"></p><h4 id="2-CSR-x2F-CSC"><a href="#2-CSR-x2F-CSC" class="headerlink" title="2.CSR&#x2F;CSC"></a>2.CSR&#x2F;CSC</h4><p>CSR（Compressed <a href="https://so.csdn.net/so/search?q=Sparse&spm=1001.2101.3001.7020">Sparse</a> Row）格式实现了用于存储二维张量的 CSR 格式。尽管不支持 N 维张量，但与 COO 格式相比的主要优势是更好地利用存储和更快的计算操作。目前尚不存在 CUDA 支持</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/image-20230909002457546.png" alt="image-20230909002457546"></p><h4 id="3-LIL"><a href="#3-LIL" class="headerlink" title="3.LIL"></a>3.LIL</h4><p>LIL (List-of-List) 每行存储一个列表，每个条目包含列索引和值。通常，这些条目按列索引进行排序，以便更快地查找</p><h4 id="4-稀疏矩阵的处理"><a href="#4-稀疏矩阵的处理" class="headerlink" title="4.稀疏矩阵的处理"></a>4.稀疏矩阵的处理</h4><p>Pytorch中，处理稀疏矩阵的有效工具torch.sparse。Torch 支持 COO(rdinate) 格式的稀疏张量，可以有效地存储和处理大多数元素为零的张量</p><h3 id="二、Tensor数据转换为稀疏矩阵"><a href="#二、Tensor数据转换为稀疏矩阵" class="headerlink" title="二、Tensor数据转换为稀疏矩阵"></a>二、Tensor数据转换为稀疏矩阵</h3><h4 id="1-torch-spares-coo-tenso"><a href="#1-torch-spares-coo-tenso" class="headerlink" title="1.torch.spares_coo_tenso"></a>1.torch.spares_coo_tenso</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.spares_coo_tensor(indices, values, siez=None,*, dtype=None, requires_grad=False)-&gt;Tensor</span><br></pre></td></tr></table></figure><p>参数:</p><ul><li><code>indices</code>: 一个2D张量，其中每一列都代表一个非零元素的坐标。</li><li><code>values</code>: 一个1D张量，其中每个值都是与<code>indices</code>对应坐标中的非零元素对应的值。</li><li><code>size</code>: (可选) 一个表示稀疏张量大小的元组</li></ul><p>假设一个2D的tensor数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>非零元素的坐标(indices)和对应的值(values)为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indices = [[<span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">           [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">           [<span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">values = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>可以使用<code>torch.sparse_coo_tensor</code>来创建这个稀疏张量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">indices = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                        [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">values = torch.tensor([<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">size = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">sparse_tensor = torch.sparse_coo_tensor(indices, values, size)</span><br></pre></td></tr></table></figure><h4 id="2-将一个2D的Tensor数据变为COO稀疏张量"><a href="#2-将一个2D的Tensor数据变为COO稀疏张量" class="headerlink" title="2.将一个2D的Tensor数据变为COO稀疏张量"></a>2.将一个2D的Tensor数据变为COO稀疏张量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line"># 示例张量</span><br><span class="line">tensor = torch.tensor([[<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"># 寻找非零元素的索引</span><br><span class="line">non_zero_indices = torch.nonzero(tensor).t()</span><br><span class="line">print(non_zero_indices[<span class="number">0</span>])  <span class="meta"># tensor([0, 0, 1, 2])</span></span><br><span class="line">print(non_zero_indices[<span class="number">1</span>])  <span class="meta"># tensor([1, 2, 2, 0])</span></span><br><span class="line"></span><br><span class="line">print(tensor.dim())  # <span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 获取非零元素的值</span><br><span class="line">values = tensor[tuple(non_zero_indices[i] <span class="keyword">for</span> i in range(tensor.dim()))]</span><br><span class="line"></span><br><span class="line">print(values)  <span class="meta"># tensor([2, 1, 3, 4])</span></span><br><span class="line"></span><br><span class="line">print(tensor.size())  <span class="meta"># torch.Size([3, 3])</span></span><br><span class="line"></span><br><span class="line"># 创建稀疏张量</span><br><span class="line">sparse_tensor = torch.sparse_coo_tensor(non_zero_indices, values, tensor.size())</span><br><span class="line"></span><br><span class="line">print(sparse_tensor)</span><br></pre></td></tr></table></figure><p>最后得到的稀疏矩阵</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor(indices=tensor([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                       [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>]]),</span><br><span class="line">       values=tensor([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]),</span><br><span class="line">       size=(<span class="number">3</span>, <span class="number">3</span>), nnz=<span class="number">4</span>, layout=torch.sparse_coo)</span><br></pre></td></tr></table></figure><h4 id="3-将一个3Dtensor数据转换为COO稀疏张量"><a href="#3-将一个3Dtensor数据转换为COO稀疏张量" class="headerlink" title="3.将一个3Dtensor数据转换为COO稀疏张量"></a>3.将一个3Dtensor数据转换为COO稀疏张量</h4><p>仍然可以使用<code>torch.sparse_coo_tensor</code>函数将其转换为稀疏表示。与2D张量相似，你需要确定非零元素的位置和它们的值。对于3D张量，每个非零元素的坐标将由三个值表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line"># 示例<span class="number">3</span>D张量</span><br><span class="line">tensor = torch.tensor([</span><br><span class="line">    [[<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>]],</span><br><span class="line">    [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>]]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">print(tensor.dim()) # <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 寻找非零元素的索引</span><br><span class="line">non_zero_indices = torch.nonzero(tensor).t()</span><br><span class="line">print(non_zero_indices[<span class="number">0</span>])  <span class="meta"># tensor([0, 0, 0, 1, 1])</span></span><br><span class="line">print(non_zero_indices[<span class="number">1</span>])  <span class="meta"># tensor([0, 1, 2, 1, 2])</span></span><br><span class="line">print(non_zero_indices[<span class="number">2</span>])  <span class="meta"># tensor([1, 2, 0, 1, 2])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取非零元素的值</span><br><span class="line">values = tensor[tuple(non_zero_indices[i] <span class="keyword">for</span> i in range(tensor.dim()))]</span><br><span class="line"></span><br><span class="line"># 创建稀疏张量</span><br><span class="line">sparse_tensor = torch.sparse_coo_tensor(non_zero_indices, values, tensor.size())</span><br><span class="line"></span><br><span class="line">print(sparse_tensor)</span><br></pre></td></tr></table></figure><h4 id="4-将一个未知维度的张量数据转换为COO稀疏张量，并且存储到硬盘"><a href="#4-将一个未知维度的张量数据转换为COO稀疏张量，并且存储到硬盘" class="headerlink" title="4.将一个未知维度的张量数据转换为COO稀疏张量，并且存储到硬盘"></a>4.将一个未知维度的张量数据转换为COO稀疏张量，并且存储到硬盘</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">将tensor 数据转换为COO 稀疏张量函数    </span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">def <span class="title function_">tensor_to_sparse</span><span class="params">(dense_tensor)</span>:</span><br><span class="line">    size = dense_tensor.size()</span><br><span class="line">    # 寻找非零元素的索引</span><br><span class="line">    non_zero_indices = torch.nonzero(dense_tensor).t()</span><br><span class="line">    # 获取非零元素的值</span><br><span class="line">    values = dense_tensor[tuple(non_zero_indices[i] <span class="keyword">for</span> i in range(dense_tensor.dim()))]</span><br><span class="line">    # 创建稀疏张量</span><br><span class="line">    sparse_tensor = torch.sparse_coo_tensor(non_zero_indices, values, size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sparse_tensor,size</span><br><span class="line">      </span><br><span class="line"># 随机产生一个<span class="number">4</span>D张量数据</span><br><span class="line">dense_tensor = torch.randn((<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">print(dense_tensor)</span><br><span class="line">print(dense_tensor.dim())   # <span class="number">4</span></span><br><span class="line"></span><br><span class="line">sparse_tensor,size = tensor_to_sparse(dense_tensor)</span><br><span class="line">print(sparse_tensor)</span><br><span class="line">print(size)    <span class="meta"># torch.Size([2, 3, 3, 3])</span></span><br><span class="line">        </span><br><span class="line"># 保存稀疏张量到硬盘</span><br><span class="line">torch.save(sparse_tensor, <span class="string">&quot;spare_tensor.npz&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="5-读取硬盘上存储的COO稀疏张量，并且转换为原来的tensor数据-dense-tensor"><a href="#5-读取硬盘上存储的COO稀疏张量，并且转换为原来的tensor数据-dense-tensor" class="headerlink" title="5.读取硬盘上存储的COO稀疏张量，并且转换为原来的tensor数据(dense_tensor)"></a>5.读取硬盘上存储的COO稀疏张量，并且转换为原来的tensor数据(dense_tensor)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 从硬盘上加载稀疏张量</span><br><span class="line">loaded_sparse_tensor = torch.load(<span class="string">&quot;spare_tensor.npz&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">COO 稀疏张量转换为密集张量    </span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">def sparse_to_tensor(loaded_sparse_tensor):</span><br><span class="line"># 将稀疏张量复原为原始的密集张量</span><br><span class="line">dense_tensor = loaded_sparse_tensor.to_dense()</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">return</span> dense_tensor</span><br><span class="line"> </span><br><span class="line"># 调用函数</span><br><span class="line">sparse_to_tensor(loaded_sparse_tensor)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-使用scipy包完成上述操作"><a href="#5-使用scipy包完成上述操作" class="headerlink" title="5.使用scipy包完成上述操作"></a>5.使用scipy包完成上述操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import scipy.sparse</span><br><span class="line">import torch</span><br><span class="line">import scipy.sparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="title function_">tensor_to_sparse</span><span class="params">(dense_tensor)</span>:</span><br><span class="line">    # 将dense_tensor转化为2D</span><br><span class="line">    shape = dense_tensor.shape</span><br><span class="line">    tensor_2d = dense_tensor.view(<span class="number">-1</span>, shape[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    # 将<span class="number">2</span>D tensor转化为numpy <span class="built_in">array</span></span><br><span class="line">    array_2d = tensor_2d.numpy()</span><br><span class="line"></span><br><span class="line">    # 从numpy <span class="built_in">array</span>创建sparse matrix</span><br><span class="line">    sparse_matrix = scipy.sparse.coo_matrix(array_2d)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sparse_matrix,shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sparse_to_tensor(sparse_matrix, original_shape):</span><br><span class="line">    # 从稀疏矩阵转换为<span class="number">2</span>D <span class="built_in">array</span></span><br><span class="line">    array_2d = sparse_matrix.toarray()</span><br><span class="line"></span><br><span class="line">    # 将<span class="number">2</span>D <span class="built_in">array</span>转换为original_shape_array</span><br><span class="line">    original_shape_array = array_2d.reshape(original_shape)</span><br><span class="line"></span><br><span class="line">    # 将<span class="number">3</span>D <span class="built_in">array</span>转换为<span class="number">3</span>D tensor</span><br><span class="line">    dense_tensor = torch.from_numpy(original_shape_array)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dense_tensor</span><br><span class="line"></span><br><span class="line"># 随机产生一个dense_tensor</span><br><span class="line">dense_tensor = torch.randn((<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 转化为sparse matrix</span><br><span class="line">sparse_matrix,original_shape = tensor_to_sparse(dense_tensor)</span><br><span class="line">print(original_shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 将sparse matrix保存到硬盘上</span><br><span class="line">scipy.sparse.save_npz(<span class="string">&#x27;sparse_matrix.npz&#x27;</span>, sparse_matrix)</span><br><span class="line"></span><br><span class="line"># 使用scipy.sparse.load_npz从硬盘加载保存的稀疏张量</span><br><span class="line">loaded_sparse_matrix = scipy.sparse.load_npz(<span class="string">&#x27;sparse_matrix.npz&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 稀疏张量复原为原来的tensor数据</span><br><span class="line">restored_tensor = sparse_to_tensor(loaded_sparse_matrix, original_shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(restored_tensor)</span><br><span class="line"></span><br><span class="line"># 判断restored_tensor与原来的tensor数据是否一致</span><br><span class="line">print(dense_tensor==restored_tensor)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境编程-多进程（10）</title>
      <link href="/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%EF%BC%8810%EF%BC%89/"/>
      <url>/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%EF%BC%8810%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="UNIX环境编程-多进程（10）"><a href="#UNIX环境编程-多进程（10）" class="headerlink" title="UNIX环境编程-多进程（10）"></a>UNIX环境编程-多进程（10）</h2><h3 id="一、进程标识符pid"><a href="#一、进程标识符pid" class="headerlink" title="一、进程标识符pid"></a>一、进程标识符pid</h3><p>在操作系统中，<strong>每个进程都有一个唯一的标识符，这个标识符就是进程ID，也被称为PID（Process ID）。进程ID是一个正整数，用于唯一标识一个正在运行的进程。操作系统内核使用这个标识符来跟踪各种进程状态信息</strong></p><p>一些与进程ID相关的常见概念：</p><ul><li><strong>PID 0</strong>: 在Unix&#x2F;Linux系统中，PID为0的进程是调度进程，也被称为交换进程，它是系统的一部分，存在于内存中，但大部分时间处于休眠状态。</li><li><strong>PID 1</strong>: 在Unix&#x2F;Linux系统中，<strong>PID为1的进程通常是<code>init</code>进程</strong>，是在系统启动后由内核自动启动的。**所有的其他进程都是由这个进程直接或间接派生出来的(是所有进程的祖先（非父进程）进程)**。</li><li><strong>Parent PID (PPID)</strong>: 是创建新进程的父进程的PID。这是Unix&#x2F;Linux系统中的一个重要概念，因为进程间的关系通常以父子继承的方式展现。</li></ul><p>在编程中，有几个与PID相关的函数：</p><ul><li><code>getpid()</code>: 返回当前进程的PID。</li><li><code>getppid()</code>: 返回父进程的PID。</li><li><code>fork()</code>: 创建新的进程。新进程是调用进程的副本，被称为子进程。子进程从父进程继承数据，但是有自己的<code>PID</code></li></ul><p>进程标识符类型为<code>pid_t</code>类型，类型为有符号的整数，<strong>在每一个机器上面<code>pid_t</code>具体占多少位是未知的，可以将其转换为<code>long long </code>类型的数据进行输出</strong></p><p>在UNIX和Linux系统中，进程标识符（PID）的数据类型通常为 <code>pid_t</code>，这是POSIX标准定义的数据类型。在C和C++程序设计中，我们通常使用 <code>pid_t</code> 类型来存储进程ID。</p><p><code>pid_t</code> 的具体实现因操作系统和硬件平台的不同而不同。但通常，<code>pid_t</code> 在大多数系统中都是<strong>一个有符号整数</strong>。然而，你不能假设 <code>pid_t</code> 就是某种特定的整数类型，比如 <code>int</code>，因为这种假设在某些系统上可能不成立。</p><p>所以，当你在编程时处理进程ID时，应始终使用 <code>pid_t</code> 数据类型，而不是直接使用 <code>int</code> 或其他整数类型。这是因为使用 <code>pid_t</code> 可以确保你的程序能在所有符合POSIX标准的系统上正确运行</p><h4 id="1-ps命令"><a href="#1-ps命令" class="headerlink" title="1.ps命令"></a>1.ps命令</h4><p><code>ps</code> 是一个非常有用的命令，用于查看当前系统中正在运行的进程信息</p><p>一些基本的 <code>ps</code> 命令的使用例子：</p><ul><li><code>ps</code>: 如果不带任何参数地运行 <code>ps</code>，它将显示与当前终端关联的进程。</li><li><code>ps -A</code> 或 <code>ps -e</code>: 显示所有进程。</li><li><code>ps -u [用户名]</code>: 显示指定用户的所有进程。</li><li><code>ps -f</code>: 以全格式输出，显示更多信息，包括父进程的PID（PPID），进程的PID，进程启动时的命令行等。</li><li><code>ps -aux</code> 或 <code>ps aux</code>: 这是最常用的选项之一。这里的参数可以分解为 <code>-a</code>（显示所有用户的所有进程）、<code>-u</code>（以用户为主的格式显示进程）和<code>-x</code>（显示没有控制终端的进程）。这将列出所有进程的详细快照</li></ul><h4 id="2-getpid与getppid"><a href="#2-getpid与getppid" class="headerlink" title="2.getpid与getppid"></a>2.getpid与getppid</h4><h5 id="（1）getpid"><a href="#（1）getpid" class="headerlink" title="（1）getpid"></a>（1）getpid</h5><p><code>getpid()</code>函数用于获取当前进程的进程ID（Process ID）。进程ID是一个非负整数，它在操作系统中唯一标识一个正在运行的进程。每个进程都有一个唯一的进程ID，且进程ID在进程的整个生命周期内保持不变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li><code>getpid()</code>函数返回当前进程的进程ID（PID）</li></ul><h5 id="（2）getppid"><a href="#（2）getppid" class="headerlink" title="（2）getppid"></a>（2）getppid</h5><p><code>getppid()</code>函数用于获取当前进程的父进程的进程ID（Parent Process ID）。父进程ID是一个非负整数，用于唯一标识当前进程的父进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li><code>getppid()</code>函数返回当前进程的父进程的进程ID（PID）</li></ul><h3 id="二、进程的产生"><a href="#二、进程的产生" class="headerlink" title="二、进程的产生"></a>二、进程的产生</h3><h4 id="1-fork"><a href="#1-fork" class="headerlink" title="1.fork()"></a>1.fork()</h4><p><code>fork()</code>函数是一个在<code>Unix-like</code>操作系统中创建新进程的系统调用。<strong>它通过复制（一模一样执行的位置都一样）调用进程（父进程）来创建一个新的进程（子进程）</strong>。<strong>父进程和子进程之间的区别在于返回值不同：在父进程中，<code>fork()</code>函数返回子进程的进程<code>ID（PID）</code>，而在子进程中，它返回0。执行一次返回两次</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li>在父进程中，<code>fork()</code>函数返回子进程的进程ID（PID）。该PID是一个正整数，代表新创建的子进程。</li><li>在子进程中，<code>fork()</code>函数返回0，表示它是子进程</li><li>返回值小于0,表示失败</li></ul><h6 id="重点：fork后父子进程的区别与联系"><a href="#重点：fork后父子进程的区别与联系" class="headerlink" title="重点：fork后父子进程的区别与联系"></a><strong>重点：fork后父子进程的区别与联系</strong></h6><ul><li>fork的返回值不一样</li><li>父子进程的<code>PID</code>不一样,<code>ppid(父进程的pid)</code>也不相同</li><li>未决信号和文件锁不继承，资源利用量清0</li><li><strong>创建方式</strong>：父进程通过系统调用（例如在Unix-like系统中的<code>fork()</code>函数）创建子进程。<strong>创建后，子进程是父进程的复制品（父进程干什么，子进程干什么），它继承了父进程的代码，数据，堆，栈，环境变量，打开的文件描述符等</strong>。但是，父进程和子进程有各自独立的地址空间，它们之间的任何变量和状态的改变并不会影响到对方</li><li><strong>运行状态</strong>：父进程和子进程可以独立运行，各自拥有自己的程序计数器，它们可以并行或者并发的执行。<strong>操作系统会对父进程和子进程进行调度，根据优先级和策略来决定哪个进程先运行</strong>，运行多久</li><li><strong>进程间通信</strong>：虽然父进程和子进程有各自独立的地址空间，但是它们可以通过特定的机制进行通信，例如管道（pipe）、消息队列、共享内存、信号（signal）等</li><li><strong>进程生命周期</strong>：通常情况下，当子进程结束后，父进程需要通过调用<code>wait()</code>或者<code>waitpid()</code>函数来获取子进程的退出状态（资源回收），这个过程被称为“收尸”。如果父进程没有做这个操作，那么子进程就会成为“僵尸进程”。如果父进程先于子进程结束，那么子进程的父进程会变成init进程，由init进程来负责“收尸”工作</li><li><strong>子进程的用途</strong>：子进程通常被用来执行其他的程序。这是通过<code>exec()</code>系列函数来实现的。<code>exec()</code>函数会替换当前进程的映像（包括代码和数据），然后运行新的程序。这是Unix&#x2F;Linux系统中常见的“fork-exec”模式</li><li><strong>资源限制</strong>：子进程继承了父进程的资源限制，比如CPU时间限制，文件大小限制等</li></ul><p><strong>程序示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始复制，一式两份</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败小于0</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;getpid()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程中==0</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程中 返回子进程的PID号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>,getpid());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>make之后运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ ./<span class="number">1</span></span><br><span class="line">[<span class="number">13423</span>]:Begin!</span><br><span class="line">[<span class="number">13423</span>]:Parent is working!</span><br><span class="line">[<span class="number">13423</span>]:End!</span><br><span class="line">[<span class="number">13424</span>]:Child is working!</span><br><span class="line">[<span class="number">13424</span>]:End!</span><br></pre></td></tr></table></figure><p>上述执行结果，是父进程先运行，但是实际上，<strong>父子进程的运行顺序是由调度器的调度策略决定</strong>。<strong>此外可以发现fork之后</strong>，父进程打印了<code>[13423]:Parent is working!与[13423]:End!</code>子进程进行了同样的操作打印了<code>[13424]:Child is working!与[13424]:End!</code></p><h6 id="重点：在fork之前需要刷新所有的流"><a href="#重点：在fork之前需要刷新所有的流" class="headerlink" title="重点：在fork之前需要刷新所有的流"></a>重点：在<code>fork</code>之前需要刷新所有的流</h6><p>程序示例:<code>1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始复制，一式两份</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败小于0</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;getpid()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程中==0</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程中 返回子进程的PID号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>,getpid());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>make之后将代码重定向到文件中,在当前目录下创建一个<code>out</code>文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="number">1</span> &gt; ./out   <span class="comment">// 将可执行文件的输出，重定向到./out文件中，而不打印到终端中</span></span><br></pre></td></tr></table></figure><p>查看out下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ cat ./out </span><br><span class="line">[<span class="number">13911</span>]:Begin!</span><br><span class="line">[<span class="number">13911</span>]:Parent is working!</span><br><span class="line">[<span class="number">13911</span>]:End!</span><br><span class="line">[<span class="number">13911</span>]:Begin!</span><br><span class="line">[<span class="number">13912</span>]:Child is working!</span><br><span class="line">[<span class="number">13912</span>]:End!</span><br></pre></td></tr></table></figure><p>发现，程序执行结果相较于之前的直接在终端中输出，存在不同，父进程将<code>begin</code>打印了两次，执行出现了错误，理论上，<code>begin</code>只能打印一次，由fork之前的父进程打印。但是为什么存在这样的问题呢？</p><p><strong>原因</strong>：</p><ul><li>在终端中输出为行缓冲，而在文件中为全缓冲。在行缓冲的遇到begin后的<code>\n</code>换行符，缓冲区就会刷新，但是全缓冲则直到缓冲区满才会被动刷新</li></ul><p><strong>解决</strong>：</p><ul><li>需要在<code>fork</code>之前，主动进行所有流的刷新<code>fflush(NULL)</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line">    fflush(<span class="literal">NULL</span>);  <span class="comment">/*尤为重要！！！！*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 开始复制，一式两份</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败小于0</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;getpid()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程中==0</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程中 返回子进程的PID号 pid 为其他正整数时</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>,getpid());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ make <span class="number">1</span></span><br><span class="line">cc     <span class="number">1.</span>c   -o <span class="number">1</span></span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ ./<span class="number">1</span> &gt; ./out </span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ cat ./out </span><br><span class="line">[<span class="number">14218</span>]:Begin!</span><br><span class="line">[<span class="number">14218</span>]:Parent is working!</span><br><span class="line">[<span class="number">14218</span>]:End!</span><br><span class="line">[<span class="number">14219</span>]:Child is working!</span><br><span class="line">[<span class="number">14219</span>]:End!</span><br></pre></td></tr></table></figure><h6 id="fork写时拷贝机制"><a href="#fork写时拷贝机制" class="headerlink" title="fork写时拷贝机制"></a>fork写时拷贝机制</h6><p>fork目前已经融合了vfork的优势,<code>fork()</code> 函数在创建新的子进程时采用的是 “Copy-on-Write” 也就是写时复制机制。这意味着当 <code>fork()</code> 函数被调用时，<strong>子进程并不会立即复制父进程的所有内存空间（指针均指向父进程所使用的内存空间），而是等到有需要写入内存时才进行复制</strong></p><p>在写时复制机制中，当子进程被创建时，父进程的所有内存页都会被标记为只读，并且父子进程都会共享这些内存页。<strong>当父进程或子进程尝试写入这些共享页时，操作系统就会拦截这个操作，复制这个内存页，然后把复制出的页标记为可写，之后再进行写操作</strong></p><p><strong>优势</strong>: 使用写时复制机制的好处是，如果子进程并未修改父进程的数据，那么就没有必要复制内存，这样就大大节省了内存使用和提高了程序执行效率。同时，由于内存页在需要修改时才复制，所以 <code>fork()</code> 调用的时间成本也大大降低</p><p>然而，这种机制也有一些局限性。例如，如果父进程和子进程都需要修改同一内存页中的数据，那么这个页还是需要被复制一份，这样就减小了写时复制的优势。所以，如果预期子进程会大量修改内存，那么 <code>fork()</code> 可能并不是最好的选择，因为它可能会产生许多的内存复制操作</p><p>这就是 <code>fork()</code> 中的写时复制机制。它使得 <code>fork()</code> 能更有效率地在父子进程之间共享数据，同时也提高了创建新进程的效率</p><h6 id="行缓冲与全缓冲的区别"><a href="#行缓冲与全缓冲的区别" class="headerlink" title="行缓冲与全缓冲的区别"></a>行缓冲与全缓冲的区别</h6><p>行缓冲（Line Buffering）和全缓冲（Fully Buffering）是两种标准I&#x2F;O（stdio）库中的缓冲模式，用于控制数据在输入输出过程中的缓冲行为。</p><p>行缓冲：</p><ul><li>在行缓冲模式下，标准I&#x2F;O库会将数据缓冲到一个特定大小的缓冲区（通常是一行数据的大小），然后在遇到换行符 <code>\n</code> 时，才会将缓冲区的数据一次性输出（对于输出）或读取（对于输入）。</li><li>当程序输出换行符时，或者缓冲区已满时，数据会被立即输出或读取。否则，数据会一直留在缓冲区中，直到满足刷新缓冲的条件。</li><li>典型的行缓冲的例子是终端设备（比如控制台），因为用户通常希望在输入或输出一行完整数据后才进行实际的显示或处理。</li></ul><p>全缓冲：</p><ul><li>在全缓冲模式下，标准I&#x2F;O库会将数据缓冲到一个较大的缓冲区（通常几 KB 到几十 KB），直到缓冲区被填满或者显式地要求刷新缓冲区时，才会将数据一次性输出（对于输出）或读取（对于输入）。</li><li>当程序显示调用 <code>fflush()</code> 函数刷新缓冲区时，或者缓冲区已满时，数据会被输出或读取。否则，数据会一直留在缓冲区中。</li><li>全缓冲适用于文件设备等，因为在这种情况下，通常需要一次性读取或输出大量数据，而不需要频繁地进行 I&#x2F;O 操作。</li></ul><p>缓冲模式的选择取决于使用的设备或文件，以及对于实时性和性能的需求。对于交互式输入输出，通常会使用行缓冲以便及时显示数据。而对于大文件的读写，使用全缓冲可以提高性能，因为较少的系统调用可以减少开销。</p><p>C语言中，使用标准I&#x2F;O库提供的函数（如 <code>printf</code>、<code>scanf</code>、<code>fopen</code> 等）进行输入输出时，默认情况下，通常是行缓冲模式，但是也可以通过调用 <code>setvbuf</code> 函数来手动设置缓冲模式</p><h4 id="2-进程实例"><a href="#2-进程实例" class="headerlink" title="2.进程实例"></a>2.进程实例</h4><h5 id="（1）使用单个进程的策略"><a href="#（1）使用单个进程的策略" class="headerlink" title="（1）使用单个进程的策略"></a>（1）使用单个进程的策略</h5><p>编写一个程序<code>2.c</code>，计算一个范围内的所有质数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT 30000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT 30200</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j,mark;</span><br><span class="line"><span class="keyword">for</span>(i = LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">&#123;</span><br><span class="line">mark = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i%j == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 则i不为质数,mark设置为0</span></span><br><span class="line">mark = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mark)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d is a primer\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ time ./<span class="number">2</span></span><br><span class="line"><span class="number">30011</span> is a primer</span><br><span class="line"><span class="number">30013</span> is a primer</span><br><span class="line"><span class="number">30029</span> is a primer</span><br><span class="line"><span class="number">30047</span> is a primer</span><br><span class="line"><span class="number">30059</span> is a primer</span><br><span class="line"><span class="number">30071</span> is a primer</span><br><span class="line"><span class="number">30089</span> is a primer</span><br><span class="line"><span class="number">30091</span> is a primer</span><br><span class="line"><span class="number">30097</span> is a primer</span><br><span class="line"><span class="number">30103</span> is a primer</span><br><span class="line"><span class="number">30109</span> is a primer</span><br><span class="line"><span class="number">30113</span> is a primer</span><br><span class="line"><span class="number">30119</span> is a primer</span><br><span class="line"><span class="number">30133</span> is a primer</span><br><span class="line"><span class="number">30137</span> is a primer</span><br><span class="line"><span class="number">30139</span> is a primer</span><br><span class="line"><span class="number">30161</span> is a primer</span><br><span class="line"><span class="number">30169</span> is a primer</span><br><span class="line"><span class="number">30181</span> is a primer</span><br><span class="line"><span class="number">30187</span> is a primer</span><br><span class="line"><span class="number">30197</span> is a primer</span><br><span class="line"></span><br><span class="line">real<span class="number">0</span>m0<span class="number">.004</span>s</span><br><span class="line">user<span class="number">0</span>m0<span class="number">.004</span>s</span><br><span class="line">sys<span class="number">0</span>m0<span class="number">.000</span>s</span><br></pre></td></tr></table></figure><p>最后打印的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real<span class="number">0</span>m0<span class="number">.004</span>s</span><br><span class="line">user<span class="number">0</span>m0<span class="number">.004</span>s</span><br><span class="line">sys<span class="number">0</span>m0<span class="number">.000</span>s</span><br></pre></td></tr></table></figure><p>是使用了&#96;&#96;$ time [可执行文件]&#96; 命令可以为测量执行指定可执行文件的时间，输出三个时间数据为：实际时间（real）、用户态CPU时间（user）和内核态CPU时间（sys）</p><ul><li>实际时间（real）：表示从<strong>命令开始执行到命令结束的实际流逝时间</strong>，包括所有的I&#x2F;O等待时间和其他进程执行时间。这个时间是最直观的执行时间，也是我们最常关注的时间</li><li>用户态CPU时间（user）：表示 CPU 在用户态运行可执行文件的时间。当进程执行自己的代码时，它处于用户态</li><li>内核态CPU时间（sys）：表示 CPU 在内核态运行可执行文件的时间。当进程执行系统调用或者受到中断时，它处于内核态</li></ul><p>一般情况下，用户态CPU时间（user） + 内核态CPU时间（sys） 的总和应该接近实际时间（real），但可能会稍微大于实际时间，因为在执行过程中可能还有其他进程的干扰</p><h5 id="（2）使用多个进程的策略（使用exit使得子进程正常结束）"><a href="#（2）使用多个进程的策略（使用exit使得子进程正常结束）" class="headerlink" title="（2）使用多个进程的策略（使用exit使得子进程正常结束）"></a>（2）使用多个进程的策略（使用<code>exit使得子进程正常结束</code>）</h5><p>产生201个子进程，进行质数的筛查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT 30000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT 30200</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j,mark;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="keyword">for</span>(i = LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">&#123;</span><br><span class="line">fflush(<span class="literal">NULL</span>); <span class="comment">/* 刷新所有的流 */</span></span><br><span class="line"><span class="comment">// 产生一个进程</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">//失败</span></span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子进程操作,子进程进程质数筛查的工作</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">mark = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i%j == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 则i不为质数,mark设置为0</span></span><br><span class="line">mark = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mark)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d is a primer\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程 不进行操作 pid 为其他正整数时</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 不操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行上述代码，系统直接卡死</strong>,因为系统实际产生的子进程并非201个，而是2的201次方-1个（2^201-1）</p><p><strong>代码debug</strong>，给子进程一个退出的标记，使用<code>exit()</code>等待子进程结束，使得子进程正常结束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT 30000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT 30200</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j,mark;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="keyword">for</span>(i = LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">&#123;</span><br><span class="line">fflush(<span class="literal">NULL</span>); <span class="comment">/* 刷新所有的流 */</span></span><br><span class="line"><span class="comment">// 产生一个进程</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">//失败</span></span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子进程操作,子进程进程质数筛查的工作</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">mark = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i%j == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 则i不为质数,mark设置为0</span></span><br><span class="line">mark = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mark)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d is a primer\n&quot;</span>,i);</span><br><span class="line">            <span class="comment">// 等待子进程结束</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程 不进行操作 pid 为其他正整数时</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 不操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>make之后执行，<code>$ time [可执行文件]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ time ./<span class="number">3</span></span><br><span class="line"><span class="number">30011</span> is a primer</span><br><span class="line"><span class="number">30013</span> is a primer</span><br><span class="line"><span class="number">30029</span> is a primer</span><br><span class="line"><span class="number">30047</span> is a primer</span><br><span class="line"><span class="number">30059</span> is a primer</span><br><span class="line"><span class="number">30071</span> is a primer</span><br><span class="line"><span class="number">30089</span> is a primer</span><br><span class="line"><span class="number">30091</span> is a primer</span><br><span class="line"><span class="number">30097</span> is a primer</span><br><span class="line"><span class="number">30103</span> is a primer</span><br><span class="line"><span class="number">30109</span> is a primer</span><br><span class="line"><span class="number">30113</span> is a primer</span><br><span class="line"><span class="number">30119</span> is a primer</span><br><span class="line"><span class="number">30133</span> is a primer</span><br><span class="line"><span class="number">30137</span> is a primer</span><br><span class="line"><span class="number">30139</span> is a primer</span><br><span class="line"><span class="number">30161</span> is a primer</span><br><span class="line"><span class="number">30169</span> is a primer</span><br><span class="line"><span class="number">30181</span> is a primer</span><br><span class="line"><span class="number">30187</span> is a primer</span><br><span class="line"><span class="number">30197</span> is a primer</span><br><span class="line"></span><br><span class="line">real<span class="number">0</span>m0<span class="number">.018</span>s</span><br><span class="line">user<span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">sys<span class="number">0</span>m0<span class="number">.018</span>s</span><br></pre></td></tr></table></figure><p>对于执行的结果，实际上每个子进程的执行顺序，是由于调度器的调度策略来决定。但是对于时间，使用多进程并发，<code>real</code>时间好像并没有减少，这与调度器的调度策略以及系统处理器的内核数量(处理器的内核数量（CPU核心数）决定了计算机在同一时刻可以并行处理多少个线程或进程)有关。</p><h5 id="（3）若不使用exit退出子进程，计算总共产生子进程的数量"><a href="#（3）若不使用exit退出子进程，计算总共产生子进程的数量" class="headerlink" title="（3）若不使用exit退出子进程，计算总共产生子进程的数量"></a>（3）若不使用exit退出子进程，计算总共产生子进程的数量</h5><p>编写一个程序，在<code>for</code>循环中<code>fork</code>一定数量的子进程，但是不使用<code>exit</code>等待其结束，计算总产生的子进程数量</p><h6 id="define-process-NUM-1"><a href="#define-process-NUM-1" class="headerlink" title="#define process_NUM 1"></a>#define process_NUM 1</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> process_NUM 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;process_NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">fflush(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 开始复制，一式两份</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败小于0</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;getpid()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程中==0</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程中 返回子进程的PID号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使得进程一直运行，不结束，终端中等待字符输入</span></span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>make 之后运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ make <span class="number">4</span></span><br><span class="line">cc     <span class="number">4.</span>c   -o <span class="number">4</span></span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ ./<span class="number">4</span></span><br><span class="line">[<span class="number">9235</span>]:Begin!</span><br><span class="line">[<span class="number">9235</span>]:Parent is working!</span><br><span class="line">[<span class="number">9235</span>]:End!</span><br><span class="line">[<span class="number">9236</span>]:Child is working!</span><br><span class="line">[<span class="number">9236</span>]:End!</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>产生了一个子进程，PID为<code>9236</code>,使用<code>ps -auf命令</code>查看进程之间的关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zxz         <span class="number">5895</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">14372</span>  <span class="number">5764</span> pts/<span class="number">0</span>    Ss   <span class="number">08</span>:<span class="number">55</span>   <span class="number">0</span>:<span class="number">00</span> bash</span><br><span class="line">zxz         <span class="number">9235</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>   <span class="number">580</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">14</span>   <span class="number">0</span>:<span class="number">00</span>  \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9236</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">14</span>   <span class="number">0</span>:<span class="number">00</span>      \_ ./<span class="number">4</span></span><br></pre></td></tr></table></figure><p>5895为shell的进程，而9235为程序的主进程，9236为9235的子进程，此时产生了一个子进程</p><h6 id="define-process-NUM-2"><a href="#define-process-NUM-2" class="headerlink" title="#define process_NUM 2"></a>#define process_NUM 2</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> process_NUM 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;process_NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">fflush(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 开始复制，一式两份</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败小于0</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;getpid()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程中==0</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程中 返回子进程的PID号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ make <span class="number">4</span></span><br><span class="line">cc     <span class="number">4.</span>c   -o <span class="number">4</span></span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ ./<span class="number">4</span></span><br><span class="line">[<span class="number">9376</span>]:Begin!</span><br><span class="line">[<span class="number">9376</span>]:Parent is working!</span><br><span class="line">[<span class="number">9376</span>]:End!</span><br><span class="line">[<span class="number">9376</span>]:Parent is working!</span><br><span class="line">[<span class="number">9376</span>]:End!</span><br><span class="line">[<span class="number">9377</span>]:Child is working!</span><br><span class="line">[<span class="number">9377</span>]:End!</span><br><span class="line">[<span class="number">9378</span>]:Child is working!</span><br><span class="line">[<span class="number">9378</span>]:End!</span><br><span class="line">[<span class="number">9377</span>]:Parent is working!</span><br><span class="line">[<span class="number">9377</span>]:End!</span><br><span class="line">[<span class="number">9379</span>]:Child is working!</span><br><span class="line">[<span class="number">9379</span>]:End!</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>使用<code>ps -auf命令</code>查看进程之间的关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zxz         <span class="number">5895</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">14372</span>  <span class="number">5764</span> pts/<span class="number">0</span>    Ss   <span class="number">08</span>:<span class="number">55</span>   <span class="number">0</span>:<span class="number">00</span> bash</span><br><span class="line">zxz         <span class="number">9376</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>   <span class="number">584</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">18</span>   <span class="number">0</span>:<span class="number">00</span>  \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9377</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">18</span>   <span class="number">0</span>:<span class="number">00</span>      \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9379</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">18</span>   <span class="number">0</span>:<span class="number">00</span>      |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9378</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">18</span>   <span class="number">0</span>:<span class="number">00</span>      \_ ./<span class="number">4</span></span><br></pre></td></tr></table></figure><p>9376为程序的主进程，9377与9378为主进程的子进程，9379为9377的子进程，程序总共产生了3个子进程</p><h6 id="define-process-NUM-3"><a href="#define-process-NUM-3" class="headerlink" title="#define process_NUM 3"></a>#define process_NUM 3</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> process_NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;process_NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">fflush(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 开始复制，一式两份</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败小于0</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;getpid()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程中==0</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程中 返回子进程的PID号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ make <span class="number">4</span></span><br><span class="line">cc     <span class="number">4.</span>c   -o <span class="number">4</span></span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ ./<span class="number">4</span></span><br><span class="line">[<span class="number">9528</span>]:Begin!</span><br><span class="line">[<span class="number">9528</span>]:Parent is working!</span><br><span class="line">[<span class="number">9528</span>]:End!</span><br><span class="line">[<span class="number">9528</span>]:Parent is working!</span><br><span class="line">[<span class="number">9528</span>]:End!</span><br><span class="line">[<span class="number">9529</span>]:Child is working!</span><br><span class="line">[<span class="number">9529</span>]:End!</span><br><span class="line">[<span class="number">9528</span>]:Parent is working!</span><br><span class="line">[<span class="number">9528</span>]:End!</span><br><span class="line">[<span class="number">9530</span>]:Child is working!</span><br><span class="line">[<span class="number">9530</span>]:End!</span><br><span class="line">[<span class="number">9529</span>]:Parent is working!</span><br><span class="line">[<span class="number">9529</span>]:End!</span><br><span class="line">[<span class="number">9531</span>]:Child is working!</span><br><span class="line">[<span class="number">9531</span>]:End!</span><br><span class="line">[<span class="number">9530</span>]:Parent is working!</span><br><span class="line">[<span class="number">9530</span>]:End!</span><br><span class="line">[<span class="number">9529</span>]:Parent is working!</span><br><span class="line">[<span class="number">9529</span>]:End!</span><br><span class="line">[<span class="number">9532</span>]:Child is working!</span><br><span class="line">[<span class="number">9532</span>]:End!</span><br><span class="line">[<span class="number">9533</span>]:Child is working!</span><br><span class="line">[<span class="number">9533</span>]:End!</span><br><span class="line">[<span class="number">9534</span>]:Child is working!</span><br><span class="line">[<span class="number">9534</span>]:End!</span><br><span class="line">[<span class="number">9532</span>]:Parent is working!</span><br><span class="line">[<span class="number">9532</span>]:End!</span><br><span class="line">[<span class="number">9535</span>]:Child is working!</span><br><span class="line">[<span class="number">9535</span>]:End!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>ps -auf命令</code>查看进程之间的关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zxz         <span class="number">5895</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">14372</span>  <span class="number">5764</span> pts/<span class="number">0</span>    Ss   <span class="number">08</span>:<span class="number">55</span>   <span class="number">0</span>:<span class="number">00</span> bash</span><br><span class="line">zxz         <span class="number">9528</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>   <span class="number">512</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">23</span>   <span class="number">0</span>:<span class="number">00</span>  \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9529</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">84</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">23</span>   <span class="number">0</span>:<span class="number">00</span>      \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9532</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">84</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">23</span>   <span class="number">0</span>:<span class="number">00</span>      |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9535</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">84</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">23</span>   <span class="number">0</span>:<span class="number">00</span>      |   |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9534</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">84</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">23</span>   <span class="number">0</span>:<span class="number">00</span>      |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9530</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">84</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">23</span>   <span class="number">0</span>:<span class="number">00</span>      \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9533</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">84</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">23</span>   <span class="number">0</span>:<span class="number">00</span>      |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9531</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">84</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">23</span>   <span class="number">0</span>:<span class="number">00</span>      \_ ./<span class="number">4</span></span><br></pre></td></tr></table></figure><p>9528为程序的主进程，总共产生了7个子进程</p><h6 id="define-process-NUM-4"><a href="#define-process-NUM-4" class="headerlink" title="#define process_NUM 4"></a>#define process_NUM 4</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> process_NUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;process_NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">fflush(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 开始复制，一式两份</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败小于0</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;getpid()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程中==0</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程中 返回子进程的PID号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ make <span class="number">4</span></span><br><span class="line">cc     <span class="number">4.</span>c   -o <span class="number">4</span></span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ ./<span class="number">4</span></span><br><span class="line">[<span class="number">9697</span>]:Begin!</span><br><span class="line">[<span class="number">9697</span>]:Parent is working!</span><br><span class="line">[<span class="number">9697</span>]:End!</span><br><span class="line">[<span class="number">9697</span>]:Parent is working!</span><br><span class="line">[<span class="number">9697</span>]:End!</span><br><span class="line">[<span class="number">9698</span>]:Child is working!</span><br><span class="line">[<span class="number">9698</span>]:End!</span><br><span class="line">[<span class="number">9699</span>]:Child is working!</span><br><span class="line">[<span class="number">9699</span>]:End!</span><br><span class="line">[<span class="number">9697</span>]:Parent is working!</span><br><span class="line">[<span class="number">9697</span>]:End!</span><br><span class="line">[<span class="number">9697</span>]:Parent is working!</span><br><span class="line">[<span class="number">9698</span>]:Parent is working!</span><br><span class="line">[<span class="number">9697</span>]:End!</span><br><span class="line">[<span class="number">9698</span>]:End!</span><br><span class="line">[<span class="number">9699</span>]:Parent is working!</span><br><span class="line">[<span class="number">9699</span>]:End!</span><br><span class="line">[<span class="number">9700</span>]:Child is working!</span><br><span class="line">[<span class="number">9700</span>]:End!</span><br><span class="line">[<span class="number">9701</span>]:Child is working!</span><br><span class="line">[<span class="number">9701</span>]:End!</span><br><span class="line">[<span class="number">9698</span>]:Parent is working!</span><br><span class="line">[<span class="number">9698</span>]:End!</span><br><span class="line">[<span class="number">9699</span>]:Parent is working!</span><br><span class="line">[<span class="number">9699</span>]:End!</span><br><span class="line">[<span class="number">9702</span>]:Child is working!</span><br><span class="line">[<span class="number">9702</span>]:End!</span><br><span class="line">[<span class="number">9703</span>]:Child is working!</span><br><span class="line">[<span class="number">9700</span>]:Parent is working!</span><br><span class="line">[<span class="number">9703</span>]:End!</span><br><span class="line">[<span class="number">9700</span>]:End!</span><br><span class="line">[<span class="number">9705</span>]:Child is working!</span><br><span class="line">[<span class="number">9705</span>]:End!</span><br><span class="line">[<span class="number">9701</span>]:Parent is working!</span><br><span class="line">[<span class="number">9701</span>]:End!</span><br><span class="line">[<span class="number">9706</span>]:Child is working!</span><br><span class="line">[<span class="number">9706</span>]:End!</span><br><span class="line">[<span class="number">9704</span>]:Child is working!</span><br><span class="line">[<span class="number">9704</span>]:End!</span><br><span class="line">[<span class="number">9698</span>]:Parent is working!</span><br><span class="line">[<span class="number">9698</span>]:End!</span><br><span class="line">[<span class="number">9703</span>]:Parent is working!</span><br><span class="line">[<span class="number">9703</span>]:End!</span><br><span class="line">[<span class="number">9701</span>]:Parent is working!</span><br><span class="line">[<span class="number">9701</span>]:End!</span><br><span class="line">[<span class="number">9709</span>]:Child is working!</span><br><span class="line">[<span class="number">9709</span>]:End!</span><br><span class="line">[<span class="number">9708</span>]:Child is working!</span><br><span class="line">[<span class="number">9707</span>]:Child is working!</span><br><span class="line">[<span class="number">9708</span>]:End!</span><br><span class="line">[<span class="number">9707</span>]:End!</span><br><span class="line">[<span class="number">9710</span>]:Child is working!</span><br><span class="line">[<span class="number">9704</span>]:Parent is working!</span><br><span class="line">[<span class="number">9710</span>]:End!</span><br><span class="line">[<span class="number">9704</span>]:End!</span><br><span class="line">[<span class="number">9707</span>]:Parent is working!</span><br><span class="line">[<span class="number">9707</span>]:End!</span><br><span class="line">[<span class="number">9711</span>]:Child is working!</span><br><span class="line">[<span class="number">9711</span>]:End!</span><br><span class="line">[<span class="number">9712</span>]:Child is working!</span><br><span class="line">[<span class="number">9712</span>]:End!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>ps -auf命令</code>查看进程之间的关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">zxz         <span class="number">5895</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">14372</span>  <span class="number">5764</span> pts/<span class="number">0</span>    Ss   <span class="number">08</span>:<span class="number">55</span>   <span class="number">0</span>:<span class="number">00</span> bash</span><br><span class="line">zxz         <span class="number">9697</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>   <span class="number">580</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>  \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9698</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9701</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9707</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9712</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   |   |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9710</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9704</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9711</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9708</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9699</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9703</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9709</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9705</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9700</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9706</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      |   \_ ./<span class="number">4</span></span><br><span class="line">zxz         <span class="number">9702</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">88</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">27</span>   <span class="number">0</span>:<span class="number">00</span>      \_ ./<span class="number">4</span></span><br></pre></td></tr></table></figure><p>9697为程序的主进程，总共产生了15个子进程</p><h6 id="define-process-NUM-n"><a href="#define-process-NUM-n" class="headerlink" title="#define process_NUM n"></a>#define process_NUM n</h6><p>若将预期产生n个子进程，若不使用<code>exit</code>退出子进程，那么最后总共产生的进程数量为<code>2^n-1</code>,存在数量之庞大的子进程，会吃紧系统的资源，造成系统的性能下降，<strong>由此可见，使用<code>exit</code>退出子进程，是多么的重要！！！</strong></p><h5 id="（4）孤儿进程与僵尸进程"><a href="#（4）孤儿进程与僵尸进程" class="headerlink" title="（4）孤儿进程与僵尸进程"></a>（4）孤儿进程与僵尸进程</h5><h6 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h6><p>在计算机操作系统中，<strong>孤儿进程是指其父进程结束，而它自己还在运行的进程</strong>。当一个父进程结束，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被<code>init</code>进程（进程号为1的进程）所接管。<code>init</code>进程会定期进行清理，等待这些孤儿进程结束。</p><p><strong>孤儿进程并不会对系统造成直接的危害，因为他们是被<code>init</code>进程接管的</strong>，而不是“无人看管”。但是，<strong>他们占用系统资源，比如内存，如果数量过多可能会影响系统性能</strong>。</p><p>创建孤儿进程的一种常见情况是父进程在启动子进程后立即退出，或者是因为某种原因（比如程序错误或意外情况）父进程提前退出。<strong>为了避免产生孤儿进程，父进程通常会通过调用<code>wait()</code>或相关的系统调用来等待一个或多个子进程结束</strong>。这样，父进程就可以获得子进程的退出状态，并且子进程在结束后就不再存在，因此不会成为孤儿进程</p><p><strong>代码产生孤儿进程</strong></p><p>在子进程结束之前使用<code>sleep(1000)</code>使其休眠，使得主进程先结束，这时候的子进程变成了<strong>孤儿进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> process_NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;process_NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">fflush(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 开始复制，一式两份</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败小于0</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;getpid()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">/************************重点代码段*********************/</span></span><br><span class="line"><span class="comment">// 子进程中==0</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working!\n&quot;</span>,getpid());</span><br><span class="line"><span class="comment">// 子进程休眠</span></span><br><span class="line">sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 子进程退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/************************重点代码段*********************/</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 父进程中 返回子进程的PID号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行之后使用<code>ps -auf</code>查看进程关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zxz         <span class="number">5895</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">14372</span>  <span class="number">5764</span> pts/<span class="number">0</span>    Ss+  <span class="number">08</span>:<span class="number">55</span>   <span class="number">0</span>:<span class="number">00</span> bash</span><br><span class="line">zxz        <span class="number">10789</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">84</span> pts/<span class="number">0</span>    S    <span class="number">10</span>:<span class="number">50</span>   <span class="number">0</span>:<span class="number">00</span> ./<span class="number">4</span></span><br><span class="line">zxz        <span class="number">10788</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">84</span> pts/<span class="number">0</span>    S    <span class="number">10</span>:<span class="number">50</span>   <span class="number">0</span>:<span class="number">00</span> ./<span class="number">4</span></span><br><span class="line">zxz        <span class="number">10787</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>    <span class="number">84</span> pts/<span class="number">0</span>    S    <span class="number">10</span>:<span class="number">50</span>   <span class="number">0</span>:<span class="number">00</span> ./<span class="number">4</span></span><br></pre></td></tr></table></figure><p>PID为10789、10788、10787的子进程状态均为 <code>S（可中断的睡眠态）</code>当前进程的<code>./4</code>顶格写表示当前子进程的父进程为<code>init</code>,表示这些子进程变成了孤儿进程，并且由<code>init</code>开始接管，这个时候，<code>init</code>进程需要等待这一批孤儿进程<code>sleep(1000)</code>结束之后给其<code>收尸</code></p><h6 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h6><p>在Unix和类Unix操作系统中，当一个子进程比它的父进程先结束，在父进程还没有来得及获取（回收）子进程的退出状态信息时，子进程就会进入“僵尸”状态。<strong>僵尸进程已经结束，不再占用CPU资源，但它的进程描述符仍保留在系统中，包括它的进程ID、退出状态和资源使用信息等</strong></p><p>僵尸进程的存在主要是为了让父进程在稍后的某个时间点能够获取子进程的退出状态和相关信息。父进程通过调用<code>wait()</code>或<code>waitpid()</code>系统调用来获取这些信息，此时系统将清理僵尸进程的进程描述符，释放其占用的资源。如果父进程没有调用<code>wait()</code>或<code>waitpid()</code>，子进程将会一直保持僵尸状态。</p><p>如果一个进程结束时，它的父进程已经退出，那么这个进程会成为孤儿进程，被init进程（PID为1的进程）接管。<code>init</code>进程会定期调用<code>wait()</code>来获取孤儿进程的退出状态，因此不会有僵尸进程长时间存在。</p><p><strong>虽然单个僵尸进程并不占用多少资源，但如果有大量的僵尸进程存在，它们会消耗有限的进程ID，可能会导致无法创建新的进程</strong>。因此，程序应该适当地处理子进程的退出，避免产生大量的僵尸进程</p><p><strong>代码产生僵尸进程</strong></p><p>在主进程结束之前使用<code>sleep(1000)</code>使其休眠，使得子进程先结束，这时候的子进程没有主进程进行<strong>收尸</strong>变成了<strong>僵尸进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> process_NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;process_NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">fflush(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 开始复制，一式两份</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败小于0</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;getpid()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程中==0</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待子进程结束</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程中 返回子进程的PID号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working!\n&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主进程休眠</span></span><br><span class="line">sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，使用<code>ps -auf</code>查看进程关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zxz         <span class="number">5895</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">14372</span>  <span class="number">5764</span> pts/<span class="number">0</span>    Ss   <span class="number">08</span>:<span class="number">55</span>   <span class="number">0</span>:<span class="number">00</span> bash</span><br><span class="line">zxz        <span class="number">11176</span>  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2500</span>   <span class="number">576</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">59</span>   <span class="number">0</span>:<span class="number">00</span>  \_ ./<span class="number">4</span></span><br><span class="line">zxz        <span class="number">11177</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> pts/<span class="number">0</span>    Z+   <span class="number">10</span>:<span class="number">59</span>   <span class="number">0</span>:<span class="number">00</span>      \_ [<span class="number">4</span>] &lt;defunct&gt;</span><br><span class="line">zxz        <span class="number">11178</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> pts/<span class="number">0</span>    Z+   <span class="number">10</span>:<span class="number">59</span>   <span class="number">0</span>:<span class="number">00</span>      \_ [<span class="number">4</span>] &lt;defunct&gt;</span><br><span class="line">zxz        <span class="number">11179</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> pts/<span class="number">0</span>    Z+   <span class="number">10</span>:<span class="number">59</span>   <span class="number">0</span>:<span class="number">00</span>      \_ [<span class="number">4</span>] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><p>PID为11176、11177、11179的子进程状态均为 <code>Z+（僵尸态）</code></p><h4 id="3-vfork"><a href="#3-vfork" class="headerlink" title="3.vfork()"></a>3.vfork()</h4><p>与 <code>fork()</code> 一样，<code>vfork()</code> 也用于创建新的进程，但与 <code>fork()</code> 不同的是，<code>vfork()</code> 创建的子进程会共享父进程的地址空间，而不是像 <code>fork()</code> 那样创建一个完全独立的地址空间。这使得 <code>vfork()</code> 在创建进程时更加高效，因为不需要复制父进程的页表条目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">vfork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>返回类型是 <code>pid_t</code>，适用于存储进程 ID 的整数类型。</p><p><code>vfork()</code> 的返回值和 <code>fork()</code> 相同：</p><ul><li>如果 <code>vfork()</code> 的返回值为负数，表示创建新进程失败。</li><li>如果 <code>vfork()</code> 的返回值为 0，表示这是新创建的子进程。在子进程中，<code>vfork()</code> 函数将返回 0。</li><li>如果 <code>vfork()</code> 的返回值为正数，这个值就是新创建子进程的 PID（进程ID），这意味着当前代码在父进程中执行</li></ul><p>由于 <code>vfork()</code> 会导致子进程和父进程共享同一地址空间，因此需要特别小心处理父进程和子进程之间的交互，以避免数据竞争和其他并发问题。在子进程中，必须避免修改父进程的内存，且在执行任何可能影响这个内存的操作之前，子进程必须先通过调用 <code>_exit()</code> 或者 <code>exec()</code> 来退出。因此，使用 <code>vfork()</code> 需要特别小心，只有在特定的性能要求下才会选择使用</p><p><strong>重点</strong>:使用 <code>fork()</code> 通常是更安全、更可靠的选择,<code>vfork</code>基本已经废弃</p><h3 id="三、进程的消亡与释放资源"><a href="#三、进程的消亡与释放资源" class="headerlink" title="三、进程的消亡与释放资源"></a>三、进程的消亡与释放资源</h3><h4 id="1-wait与waitpid与waitid"><a href="#1-wait与waitpid与waitid" class="headerlink" title="1.wait与waitpid与waitid"></a>1.wait与waitpid与waitid</h4><h5 id="（1）wait"><a href="#（1）wait" class="headerlink" title="（1）wait()"></a>（1）wait()</h5><p><code>wait()</code> 是一个系统调用，它用于使父进程暂停执行，直到它的一个子进程结束为止。这对于防止子进程变成僵尸进程（已经终止但尚未被父进程收集的进程）非常有用</p><p><strong>存在误解</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">确切地说，wait() 函数的确使父进程暂停执行，直到其任意一个子进程结束。使用 wait() 函数的主要目的是回收子进程的资源，防止其成为僵尸进程。当一个子进程结束，但父进程还没有调用 wait() 或 waitpid() 来读取它的退出状态时，这个子进程就会成为僵尸进程。</span><br><span class="line"></span><br><span class="line">你所说的孤儿进程是指父进程结束，而子进程仍然在运行的情况。在这种情况下，子进程会被 init 进程（在 Unix 和 Linux 系统中 PID 为 <span class="number">1</span> 的进程）接管，子进程不会变成僵尸进程，因为 init 进程会自动调用 wait() 来等待它们结束。</span><br></pre></td></tr></table></figure><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的参数是一个指向整数的指针，它用于存储子进程的退出状态信息。如果你对退出状态不感兴趣，你可以传递一个空指针</p><p>函数的返回值是已经终止的子进程的进程 ID。如果调用失败，函数将返回 -1</p><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> tpid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork() failure\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程操作</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the child process. pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">10</span>);  <span class="comment">// Sleep for 10 seconds</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 父进程操作</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 等待子进程结束，并且回收子进程资源</span></span><br><span class="line">            tpid = wait(&amp;status);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Exited child pid = %d\n&quot;</span>, tpid);</span><br><span class="line">        &#125; <span class="keyword">while</span> (tpid != pid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先创建一个新的子进程。子进程会睡眠 10 秒，然后正常退出。父进程会通过 <code>wait()</code> 调用来等待子进程退出。当 <code>wait()</code> 返回时，我们知道子进程已经退出，我们可以获取和打印子进程的退出状态</p><h5 id="（2）waitpid"><a href="#（2）waitpid" class="headerlink" title="（2）waitpid()"></a>（2）waitpid()</h5><p><code>waitpid()</code> 是一个系统调用，它用于让父进程等待其子进程的结束。不过，与 <code>wait()</code> 不同，<code>waitpid()</code> 允许你指定你想要等待的特定子进程，或者等待满足特定条件的子进程</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p><code>pid</code>: 是你想要等待的子进程的进程 ID。有几种不同的值：</p><ul><li>如果 <code>pid</code> &gt; 0，<code>waitpid()</code> 只会等待特定 PID 的子进程。</li><li>如果 <code>pid</code> &#x3D;&#x3D; -1，<code>waitpid()</code> 会等待任何子进程，和 <code>wait()</code> 相同。</li><li>如果 <code>pid</code> &#x3D;&#x3D; 0，<code>waitpid()</code> 会等待与当前进程在同一进程组的任何子进程。</li><li>如果 <code>pid</code> &lt; -1，<code>waitpid()</code> 会等待其进程组 ID 等于 <code>pid</code> 的绝对值的任何子进程。</li></ul><p><code>status</code>: 是一个指向 <code>int</code> 的指针，这个 <code>int</code> 用来存储子进程的结束状态信息</p><p><code>options</code>: 是一个控制 <code>waitpid()</code> 行为的标志位，如下：</p><ul><li><code>WNOHANG</code>：如果没有子进程已经结束，那么 <code>waitpid()</code> 不会阻塞，而是立即返回一个 0。</li><li><code>WUNTRACED</code>：如果子进程已经停止（不是结束），那么也视为结束。</li></ul><p><code>waitpid()</code> 函数的返回值是子进程的 PID（如果子进程已经结束），或者是 0（如果设置了 <code>WNOHANG</code> 选项并且没有子进程已经结束），或者是 -1（如果函数调用失败）</p><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid,tpid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork() failure\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the child process. pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">10</span>);  <span class="comment">// Sleep for 10 seconds</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            tpid  = waitpid(pid, &amp;status, WNOHANG);</span><br><span class="line">            <span class="keyword">if</span>(tpid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Child is still running.\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);  <span class="comment">// Sleep for 1 second</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Child exited with status %d\n&quot;</span>, status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (tpid == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先创建一个新的子进程。子进程会睡眠 10 秒，然后正常退出。父进程通过 <code>waitpid()</code> 调用来检查子进程是否已经退出，但如果子进程还在运行，父进程不会被阻塞，而是打印一条消息然后继续检查。当子进程退出时，父进程获取并打印子进程的退出状态</p><h4 id="2-进程的交叉分配筛选质数"><a href="#2-进程的交叉分配筛选质数" class="headerlink" title="2.进程的交叉分配筛选质数"></a>2.进程的交叉分配筛选质数</h4><p>在第二节的第2小节的进程实例中，使用多个进程的策略，创建了201个子进程实现质数的筛选，这样的做法不太好，可以使用<strong>交叉分配法</strong>来实现质数的筛选，总共fork三个子进程，轮流将待检查的数字交给创建的子进程</p><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j,mark,n,f_n;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fork三个子进程</span></span><br><span class="line"><span class="keyword">for</span>(n = <span class="number">0</span>;n&lt;N;n++)</span><br><span class="line">&#123;</span><br><span class="line">fflush(<span class="literal">NULL</span>); <span class="comment">/* 刷新所有的流 */</span></span><br><span class="line"><span class="comment">// 产生一个进程</span></span><br><span class="line">pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="comment">//失败</span></span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line"><span class="comment">// 还需要进行资源的回收</span></span><br><span class="line"><span class="keyword">for</span>(f_n = <span class="number">0</span>;f_n&lt;n;f_n++)</span><br><span class="line">&#123;</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异常退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程操作,子进程进程质数筛查的工作</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将待检查的数字交叉分配给创建的子进程进行判断</span></span><br><span class="line"><span class="keyword">for</span>(i = LEFT+n;i&lt;=RIGHT;i+=N)</span><br><span class="line">&#123;</span><br><span class="line">mark = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i%j == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 则i不为质数,mark设置为0</span></span><br><span class="line">mark = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mark)</span><br><span class="line"><span class="comment">// [%d] 表示的是那一个进程执行的此次任务，并非pid号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:%d is a primer\n&quot;</span>,n,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个子进程将各自的任务完成后，子进程结束</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程的资源回收</span></span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;N;n++)</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ make <span class="number">7</span></span><br><span class="line">cc     <span class="number">7.</span>c   -o <span class="number">7</span></span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ ./<span class="number">7</span></span><br><span class="line">[<span class="number">2</span>]:<span class="number">30000023</span> is a primer</span><br><span class="line">[<span class="number">1</span>]:<span class="number">30000001</span> is a primer</span><br><span class="line">[<span class="number">2</span>]:<span class="number">30000041</span> is a primer</span><br><span class="line">[<span class="number">1</span>]:<span class="number">30000037</span> is a primer</span><br><span class="line">[<span class="number">2</span>]:<span class="number">30000059</span> is a primer</span><br><span class="line">[<span class="number">1</span>]:<span class="number">30000049</span> is a primer</span><br><span class="line">[<span class="number">2</span>]:<span class="number">30000071</span> is a primer</span><br><span class="line">[<span class="number">1</span>]:<span class="number">30000079</span> is a primer</span><br><span class="line">[<span class="number">1</span>]:<span class="number">30000109</span> is a primer</span><br><span class="line">[<span class="number">2</span>]:<span class="number">30000083</span> is a primer</span><br><span class="line">[<span class="number">1</span>]:<span class="number">30000133</span> is a primer</span><br><span class="line">[<span class="number">2</span>]:<span class="number">30000137</span> is a primer</span><br><span class="line">[<span class="number">1</span>]:<span class="number">30000163</span> is a primer</span><br><span class="line">[<span class="number">2</span>]:<span class="number">30000149</span> is a primer</span><br><span class="line">[<span class="number">2</span>]:<span class="number">30000167</span> is a primer</span><br><span class="line">[<span class="number">1</span>]:<span class="number">30000169</span> is a primer</span><br><span class="line">[<span class="number">1</span>]:<span class="number">30000193</span> is a primer</span><br><span class="line">[<span class="number">1</span>]:<span class="number">30000199</span> is a primer</span><br></pre></td></tr></table></figure><h3 id="四、exec函数族"><a href="#四、exec函数族" class="headerlink" title="四、exec函数族"></a>四、exec函数族</h3><p><code>exec()</code> 函数系列<strong>用于从当前进程空间加载并运行一个新的程序</strong>。<code>exec()</code> 函数实际上是一组函数，也被称为 <code>exec</code> 函数族。这些函数包括：<code>execl()</code>、<code>execle()</code>、<code>execlp()</code>、<code>execv()</code>、<code>execvp()</code> 和 <code>execvpe()</code>。</p><p>这些函数的主要区别在于如何指定新程序的参数，以及如何查找新程序的文件。</p><p>所有的 <code>exec()</code> 函数都有以下几个共同的特性：</p><ul><li>执行 <code>exec()</code> 会替换当前进程的映像，新的程序从其 <code>main()</code> 函数开始执行。<strong>如果 <code>exec()</code> 执行成功，它就不会返回。如果返回了，那就表示有错误发生</strong></li><li><code>exec()</code> 函数使用的文件描述符默认都是继承自原来的进程。这就意味着在 <code>exec()</code> 之后，新的程序将能够使用已经打开的文件描述符</li></ul><h4 id="1-execl与execp与exece"><a href="#1-execl与execp与exece" class="headerlink" title="1.execl与execp与exece"></a>1.execl与execp与exece</h4><h5 id="（1）execl"><a href="#（1）execl" class="headerlink" title="（1）execl()"></a>（1）execl()</h5><p><code>execl()</code> 函数它用于<strong>替换当前进程的映像为一个新的程序</strong></p><p><strong>在使用exec函数族的函数时，都需要刷新所有的流，同<code>fork</code>函数</strong></p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg0, ..., <span class="literal">NULL</span>)</span>;</span><br></pre></td></tr></table></figure><p>函数的参数如下：</p><ul><li><code>path</code>：新程序的完全路径名。</li><li><code>arg0</code>，<code>arg1</code>，…：传递给新程序的参数列表。按照惯例，<code>arg0</code> 应该是程序的名称（它不必是程序的完整路径）。<strong>这个参数列表必须以一个 <code>NULL</code> 指针作为结束</strong></li></ul><p>如果 <code>execl()</code> 函数<strong>调用成功，那么这个函数不会返回</strong>，因为当前进程已经被新程序完全替换。如果函数返回，那只能说明出现了错误。在这种情况下，<strong>函数返回 -1，并且设置 <code>errno</code> 为具体的错误代码</strong></p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line">    <span class="comment">// 在使用exec函数族的函数时，都需要刷新所有的流，同fork函数</span></span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果这句代码执行成功，则会执行一个新的程序 &quot;/bin/ls&quot;</span></span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若执行成功后面的语句均不会执行</span></span><br><span class="line">    <span class="comment">// 若执行失败，则会继续执行下面的语句</span></span><br><span class="line">    perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们用 <code>/bin/ls</code> 程序替换了当前进程，传递了两个参数给 <code>ls</code> 程序：<code>ls</code> 和 <code>-l</code>。请注意，参数列表必须以 <code>NULL</code> 指针作为结束。如果 <code>execl()</code> 函数调用成功，那么这个函数不会返回。如果函数返回，那就表示有错误发生</p><p>运行结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ ./<span class="number">8</span></span><br><span class="line">Begin!</span><br><span class="line">总用量 <span class="number">196</span></span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16912</span> <span class="number">7</span>月  <span class="number">29</span> <span class="number">15</span>:<span class="number">58</span> <span class="number">1</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">517</span> <span class="number">7</span>月  <span class="number">30</span> <span class="number">09</span>:<span class="number">06</span> <span class="number">1.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16736</span> <span class="number">7</span>月  <span class="number">29</span> <span class="number">16</span>:<span class="number">09</span> <span class="number">2</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">331</span> <span class="number">7</span>月  <span class="number">29</span> <span class="number">16</span>:<span class="number">09</span> <span class="number">2.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16912</span> <span class="number">7</span>月  <span class="number">30</span> <span class="number">10</span>:<span class="number">39</span> <span class="number">3</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">734</span> <span class="number">7</span>月  <span class="number">30</span> <span class="number">10</span>:<span class="number">43</span> <span class="number">3.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16952</span> <span class="number">7</span>月  <span class="number">30</span> <span class="number">10</span>:<span class="number">59</span> <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">689</span> <span class="number">7</span>月  <span class="number">30</span> <span class="number">10</span>:<span class="number">59</span> <span class="number">4.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16960</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">10</span>:<span class="number">11</span> <span class="number">5</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">751</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">10</span>:<span class="number">11</span> <span class="number">5.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">17048</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">10</span>:<span class="number">26</span> <span class="number">6</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">801</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">10</span>:<span class="number">26</span> <span class="number">6.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16912</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">11</span>:<span class="number">07</span> <span class="number">7</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz  <span class="number">1164</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">11</span>:<span class="number">08</span> <span class="number">7.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16824</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">11</span>:<span class="number">29</span> <span class="number">8</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">391</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">11</span>:<span class="number">29</span> <span class="number">8.</span>c</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz    <span class="number">94</span> <span class="number">7</span>月  <span class="number">29</span> <span class="number">15</span>:<span class="number">58</span> out</span><br></pre></td></tr></table></figure><h6 id="在子进程中使用execl函数"><a href="#在子进程中使用execl函数" class="headerlink" title="在子进程中使用execl函数"></a>在子进程中使用execl函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fork至其需要刷新所有的流</span></span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子进程操作</span></span><br><span class="line">    <span class="keyword">if</span>(pid ==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 如果这句代码执行成功，则会执行一个新的程序 &quot;/bin/ls&quot;</span></span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 执行失败才会执行下面的语句</span></span><br><span class="line">    perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">    <span class="comment">// 子进程结束</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父进程，等待回收子进程资源</span></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ make <span class="number">9</span></span><br><span class="line">cc     <span class="number">9.</span>c   -o <span class="number">9</span></span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/process$ ./<span class="number">9</span></span><br><span class="line">Begin!</span><br><span class="line">总用量 <span class="number">220</span></span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16912</span> <span class="number">7</span>月  <span class="number">29</span> <span class="number">15</span>:<span class="number">58</span> <span class="number">1</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">517</span> <span class="number">7</span>月  <span class="number">30</span> <span class="number">09</span>:<span class="number">06</span> <span class="number">1.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16736</span> <span class="number">7</span>月  <span class="number">29</span> <span class="number">16</span>:<span class="number">09</span> <span class="number">2</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">331</span> <span class="number">7</span>月  <span class="number">29</span> <span class="number">16</span>:<span class="number">09</span> <span class="number">2.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16912</span> <span class="number">7</span>月  <span class="number">30</span> <span class="number">10</span>:<span class="number">39</span> <span class="number">3</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">734</span> <span class="number">7</span>月  <span class="number">30</span> <span class="number">10</span>:<span class="number">43</span> <span class="number">3.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16952</span> <span class="number">7</span>月  <span class="number">30</span> <span class="number">10</span>:<span class="number">59</span> <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">689</span> <span class="number">7</span>月  <span class="number">30</span> <span class="number">10</span>:<span class="number">59</span> <span class="number">4.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16960</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">10</span>:<span class="number">11</span> <span class="number">5</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">751</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">10</span>:<span class="number">11</span> <span class="number">5.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">17048</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">10</span>:<span class="number">26</span> <span class="number">6</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">801</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">10</span>:<span class="number">26</span> <span class="number">6.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16912</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">11</span>:<span class="number">07</span> <span class="number">7</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz  <span class="number">1164</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">11</span>:<span class="number">08</span> <span class="number">7.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16864</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">11</span>:<span class="number">32</span> <span class="number">8</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">502</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">11</span>:<span class="number">32</span> <span class="number">8.</span>c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">16952</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">11</span>:<span class="number">41</span> <span class="number">9</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">735</span> <span class="number">7</span>月  <span class="number">31</span> <span class="number">11</span>:<span class="number">40</span> <span class="number">9.</span>c</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz    <span class="number">94</span> <span class="number">7</span>月  <span class="number">29</span> <span class="number">15</span>:<span class="number">58</span> out</span><br><span class="line">End!</span><br></pre></td></tr></table></figure><h3 id="五、用户权限及组权限"><a href="#五、用户权限及组权限" class="headerlink" title="五、用户权限及组权限"></a>五、用户权限及组权限</h3><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=176&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><h3 id="六、解释器文件"><a href="#六、解释器文件" class="headerlink" title="六、解释器文件"></a>六、解释器文件</h3><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=177">视频教程</a></p><h3 id="七、system"><a href="#七、system" class="headerlink" title="七、system()"></a>七、system()</h3><p><strong>理解</strong>： <code>fork + execl + wait</code>的封装</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure><p>函数的参数如下：</p><ul><li><code>command</code>：一个 C 字符串，包含了要执行的 shell 命令。</li></ul><p><code>system()</code> 函数的返回值取决于 shell 命令的执行情况：如果 shell 命令执行成功，那么返回值通常是命令的退出状态。如果 shell 命令执行失败，那么返回值通常是 -1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> return_value;</span><br><span class="line"></span><br><span class="line">    return_value = system(<span class="string">&quot;ls -l&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Return value is %d\n&quot;</span>, return_value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>system()</code> 函数执行 <code>ls -l</code> 命令。然后我们打印 <code>system()</code> 函数的返回值。请注意，<code>system()</code> 函数的行为可能受到信号、阻塞操作等因素的影响，所以在具有高安全要求的环境中应谨慎使用</p><h3 id="八、进程会计、进程时间"><a href="#八、进程会计、进程时间" class="headerlink" title="八、进程会计、进程时间"></a>八、进程会计、进程时间</h3><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=178&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><h3 id="九、守护进程"><a href="#九、守护进程" class="headerlink" title="九、守护进程"></a>九、守护进程</h3><p>守护进程是 Unix 和类 Unix 系统（比如 Linux）中的一种特殊的后台进程。<strong>它们独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程通常在系统引导装载的时候启动，然后一直运行直到系统关闭</strong>。有时，它们也会在需要时启动，然后在不再需要时结束。</p><p><strong>守护进程一般满足以下条件</strong>：</p><ul><li><strong>脱离控制终端，控制终端上的输入输出对守护进程存在影响（同时会将其标准的输入输出IO进行重定向）</strong>，可以在终端中发送信号直接关联上守护进程，会影响守护进程的使用</li><li>守护进程一般是<strong>一个会话的leader以及一个进程组的leader</strong></li></ul><p>守护进程的名字通常以 “d” 结尾，以表明它们是后台运行的守护进程，比如 <code>sshd</code>、<code>httpd</code>、<code>mysqld</code> 等</p><p><strong>为了创建一个守护进程，一个进程通常会包含以下步骤</strong>：</p><ul><li>用 <code>fork()</code> 创建子进程，然后使父进程退出。这样做的目的是让守护进程在后台运行，并且让 shell 认为该命令已经执行完毕。</li><li>在子进程中创建一个新的会话。这样做的目的是让守护进程摆脱原来的控制终端。</li><li>改变当前目录到根目录（<code>/</code>）。这样做的目的是防止守护进程占用一个可能已经被卸载的文件系统。</li><li>重设文件权限掩码。这样做的目的是确保守护进程有可能创建的任何文件都有合适的权限。</li><li>关闭所有继承的文件描述符。这样做的目的是防止守护进程保持打开不必要的文件描述符</li></ul><h4 id="1-会话"><a href="#1-会话" class="headerlink" title="1.会话"></a>1.会话</h4><p>会话（<code>Session</code>）是一种组织进程的方式。会话中可以包含一个或多个进程组（Process Group），每个进程组又可以包含一个或多个进程。会话和进程组都是以进程 ID（<code>PID</code>）来标识的，即**一个会话的 ID 就是该会话的领头进程的 <code>PID</code>，一个进程组的 ID 就是该进程组的领头进程的 <code>PID</code>**。</p><p><strong>会话通常由 shell（登陆shell可以理解为一次成功的终端登陆） 或者登录进程创建。当用户登录系统时，登录进程就会创建一个新的会话，然后在这个会话中启动 shell</strong>。然后，用户通过 shell 创建的所有进程（包括后台进程）都会成为这个会话的一部分</p><p>一个会话内的所有进程组共享一个控制终端（Controlling Terminal）。这个控制终端通常就是用户登录时的终端（可以是物理终端，也可以是伪终端，比如一个终端窗口）。会话的领头进程就是拥有这个控制终端的进程，也是可以接收来自控制终端的各种信号的进程。</p><p>一个会话中的所有进程共享同样的登录凭据，包括相同的用户 ID、组 ID、项目 ID 等。</p><p>在创建守护进程时，通常需要调用 <code>setsid()</code> 来创建一个新的会话，以便摆脱原有的控制终端和登录会话，使守护进程在后台独立运行</p><h5 id="（1）前台进程组与后台进程组"><a href="#（1）前台进程组与后台进程组" class="headerlink" title="（1）前台进程组与后台进程组"></a>（1）前台进程组与后台进程组</h5><p>进程组是一个或多个进程的集合，这些进程可以接收来自同一终端的信号。<strong>一个会话中可以有多个进程组，其中一个被标记为前台进程组，其他的被标记为后台进程组</strong>。</p><p><strong>前台进程组</strong> 是当前与用户交互的进程组。在命令行终端中，用户输入的命令通常在前台进程组中运行，<strong>并且只有前台进程组可以从终端接收输入（前台进程组只能有一个）</strong>。如果你在命令行中运行一个命令，这个命令就会在前台执行，直到它完成</p><p><strong>后台进程组</strong> 是那些当前不与用户交互的进程组。后台进程组不会接收到来自终端的输入。你可以在命令行中使用 <code>&amp;</code> 符号来启动一个后台进程。例如，<code>command &amp;</code> 会在后台启动 <code>command</code> 命令，而终端会立即返回命令提示符，让你可以输入其他命令。<strong>注意，若我们尝试将一个标准输入的内容给后台进程，那么这个时候会将后台进程杀死</strong></p><p>前台和后台的概念允许用户在一个终端中同时运行多个命令。你可以在前台运行一个命令，同时在后台运行一个或多个其他命令。然后，你可以使用 <code>fg</code> 和 <code>bg</code> 命令来在前台和后台之间移动进程</p><h4 id="2-setsid"><a href="#2-setsid" class="headerlink" title="2.setsid"></a>2.setsid</h4><p><code>setsid()</code> 是一个用来创建新会话（session）的系统调用。<strong>当一个进程调用 <code>setsid()</code> 时，该进程将成为新会话的领头进程和新进程组的领头进程</strong></p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>该函数没有参数。如果成功，它将返回新会话的会话 ID。如果失败，它将返回 -1 并设置 <code>errno</code></p><p>调用 <code>setsid()</code> 的进程不能是进程组的领头进程（<strong>父进程与子进程在同一个进程组里面，并且父进程为组里面的领头进程，父进程不能调用<code>setsid</code>函数</strong>）。这就是为什么在创建守护进程时，<strong>我们通常先调用 <code>fork()</code> 然后使父进程退出，这样子进程就不是进程组的领头进程了</strong>，然后在子进程中调用 <code>setsid()</code></p><p>创建新会话后，该进程将：</p><ul><li>成为新会话的领头进程和新进程组的领头进程</li><li>没有控制终端。如果调用 <code>setsid()</code> 前该进程有控制终端，那么这个连接将被断开</li><li>成为其创建的任何新文件的文件主</li></ul><p>在创建守护进程时，通常会调用 <code>setsid()</code> 来创建新会话，使守护进程不受控制终端的影响</p><h4 id="3-getpgrp"><a href="#3-getpgrp" class="headerlink" title="3.getpgrp"></a>3.getpgrp</h4><p><code>getpgrp()</code>函数用于获取当前进程的进程组ID。<strong>进程组是一种可以将相关进程组织在一起的机制，允许操作系统对一组进程进行统一管理</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><code>getpgrp()</code>函数没有参数。如果成功，它将返回当前进程的进程组ID。如果失败，它将返回-1并设置<code>errno</code></p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pgid;</span><br><span class="line"></span><br><span class="line">    pgid = getpgrp();</span><br><span class="line">    <span class="keyword">if</span> (pgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;getpgrp()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The process group ID is %d\n&quot;</span>, pgid);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>getpgrp()</code>获取当前进程的进程组ID，然后打印它。如果调用失败，我们打印错误信息并退出程序</p><h4 id="4-getpgid"><a href="#4-getpgid" class="headerlink" title="4.getpgid"></a>4.getpgid</h4><p><code>getpgid()</code> 函数用于获取指定进程的进程组 ID。</p><p>函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure><p>函数的参数如下：</p><ul><li><code>pid</code>：要查询的进程的 ID。如果 <code>pid</code> 是 0，<code>getpgid()</code> 将返回调用进程的进程组 ID。</li></ul><p>如果成功，<code>getpgid()</code> 函数将返回指定进程的进程组 ID。如果失败，它将返回 -1，并且将 <code>errno</code> 设置为具体的错误码</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 当前进程的进程组ID（即当前进程组领头进程的PID）</span></span><br><span class="line">    <span class="type">pid_t</span> pgid;</span><br><span class="line">    <span class="comment">// 当前进程的PID</span></span><br><span class="line">    <span class="type">pid_t</span> cP_pid;</span><br><span class="line">    <span class="comment">// 当前进程的进程组ID</span></span><br><span class="line">    <span class="type">pid_t</span> cP_G_pid;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    pgid = getpgrp();</span><br><span class="line">    <span class="keyword">if</span> (pgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;getpgrp()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The process group ID is %d\n&quot;</span>, pgid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前进程的pid</span></span><br><span class="line">    cP_pid = getpid();</span><br><span class="line">    <span class="comment">// 获取当前进程的进程组ID</span></span><br><span class="line">    cP_G_pid = getpgid(cP_pid);</span><br><span class="line">    <span class="keyword">if</span> (cP_G_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;getpgid()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The process group ID is %d\n&quot;</span>, cP_G_pid);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>getpid()</code> 函数获取当前进程的 ID，然后使用 <code>getpgid()</code> 函数获取当前进程的进程组 ID，然后打印它。如果调用失败，我们打印错误信息并退出程序</p><h4 id="5-创建一个守护进程"><a href="#5-创建一个守护进程" class="headerlink" title="5.创建一个守护进程"></a>5.创建一个守护进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建一个守护进程，向一个指定的文件每一秒输入一个数字</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FNAME <span class="string">&quot;/tmp/out&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 守护进程函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">daemonize</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="comment">// 创建一个子进程</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使父进程退出,这样做的目的是让守护进程在后台运行</span></span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他是子进程的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 守护进程脱离控制终端，但是子进程会复制父进程的相关数据，文件描述符有关标准输入输出的0,1,2也会被与预定义，需要进行重定向</span></span><br><span class="line"><span class="comment">// 打开空设备</span></span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd  &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对文件描述符0，1，2进行重定向</span></span><br><span class="line">dup2(fd,<span class="number">0</span>);</span><br><span class="line">dup2(fd,<span class="number">1</span>);</span><br><span class="line">dup2(fd,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(fd &gt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子进程中创建一个新的会话,这样做的目的是让守护进程摆脱原来的控制终端</span></span><br><span class="line">setsid();</span><br><span class="line"></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变工作路径---切换到跟目录</span></span><br><span class="line">chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">// umask(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(daemonize())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fp = fopen(FNAME,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fp==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件中一秒输入一个字符</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"><span class="comment">// 向文件写入是全缓冲模式，刷新流的操作</span></span><br><span class="line">fflush(fp);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，使用<code>ps axj</code>查看进程树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1874</span>   <span class="number">15262</span>   <span class="number">15262</span>   <span class="number">15262</span> ?             <span class="number">-1</span> Ss    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> ./guard</span><br></pre></td></tr></table></figure><p>上述的结果TTY为?表示脱离了控制终端，但是PPID，父进程的PID为1874不知道为什么</p><p>但是上面的代码中使用<code>perror()</code>进行输出是不正确的</p><h3 id="十、系统日志"><a href="#十、系统日志" class="headerlink" title="十、系统日志"></a>十、系统日志</h3><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=181">视频教程</a></p><h4 id="1-var-log目录"><a href="#1-var-log目录" class="headerlink" title="1./var/log目录"></a>1.<code>/var/log</code>目录</h4><p>ubuntu下的系统日志目录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>Ubuntu系统的主要日志文件存储在 <code>/var/log/</code> 目录中，其中包括了大量的关于系统和应用行为的信息。这些日志文件有助于诊断和解决系统和应用程序的问题。以下是一些最重要的日志文件：</p><ul><li><code>/var/log/syslog</code>：这是系统的主要日志文件，几乎所有的系统活动都会在这里被记录。这包括系统启动过程中的信息，以及运行中各种服务和应用程序的日志信息。</li><li><code>/var/log/auth.log</code>：这个日志文件记录了所有的系统授权信息，包括用户登录和身份验证失败等。</li><li><code>/var/log/kern.log</code>：这个日志文件包含了内核的日志信息，这在解决硬件和操作系统问题时可能会有用。</li><li><code>/var/log/dmesg</code>：这个日志文件包含了系统在启动过程中，内核打印的信息。</li><li><code>/var/log/boot.log</code>：这个日志文件包含了系统启动过程中的信息，这有助于诊断系统启动问题。</li><li><code>/var/log/apache2/</code> 和 <code>/var/log/mysql/</code>：如果你在服务器上运行Apache或MySQL，那么这两个目录将包含这些应用程序的日志文件。</li></ul><p>注意，访问这些日志文件通常需要管理员权限。你可以使用 <code>sudo</code> 命令来查看这些文件，例如 <code>sudo less /var/log/syslog</code></p><h4 id="2-syslogd服务"><a href="#2-syslogd服务" class="headerlink" title="2.syslogd服务"></a>2.syslogd服务</h4><p><code>syslogd</code> 是一个在 Unix 和 Unix-like 操作系统中运行的守护进程，它用于处理系统日志。其全名是 <code>System Logging Daemon</code></p><p><strong><code>syslogd</code> 会接收来自系统的各种消息</strong>，包括内核、系统库以及各种运行中的服务和应用程序。<strong>它将这些消息进行分类并写入到不同的日志文件中，通常这些文件都位于 <code>/var/log/</code> 目录</strong></p><p>在 C 语言中，你可以使用 <code>syslog</code> 函数来向 <code>syslogd</code> 发送消息。这个函数在 <code>syslog.h</code> 头文件中声明</p><p>实例程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    openlog(<span class="string">&quot;myprogram&quot;</span>, LOG_PID|LOG_CONS, LOG_USER);</span><br><span class="line">    syslog(LOG_INFO, <span class="string">&quot;This is a test message.&quot;</span>);</span><br><span class="line">    closelog();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>openlog</code> 函数初始化了 <code>syslog</code> 系统。它接受三个参数：日志名，日志选项以及默认的日志设施（通常是 <code>LOG_USER</code>）。在这个例子中，日志选项包括了 <code>LOG_PID</code>（在每条日志信息中包含进程 ID）和 <code>LOG_CONS</code>（如果消息不能发送到<code> syslogd</code>，将其写入到控制台）。</li><li><code>syslog</code> 函数发送了一条日志消息。它接受两个参数：消息的优先级（在这个例子中是 <code>LOG_INFO</code>）以及消息本身。</li><li><code>closelog</code> 函数关闭了<code>syslog</code>连接。在程序结束时调用这个函数是一个好的实践。</li></ul><p>请注意，<code>syslog</code>、<code>openlog</code> 和 <code>closelog</code> 这些函数都是线程安全的，可以在多线程程序中使用</p><h5 id="（1）openlog"><a href="#（1）openlog" class="headerlink" title="（1）openlog"></a>（1）openlog</h5><p><code>openlog()</code>函数是一个系统调用，它用于设置<code>syslogd</code>的参数，以便向<code>syslog</code>守护进程发送消息。这个函数通常在调用<code>syslog()</code>函数之前被调用,<strong>(与<code>syslogd</code>服务实现关联)</strong></p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span>;</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li><code>ident</code>：这是一个字符串，它将添加到每个生成的日志条目之前。通常，它被设置为程序的名称<strong>（这个参数随便给就可以）</strong>。</li><li><code>option</code>：这是一个位掩码，<strong>用于设置日志记录的各种选项</strong>。可能的选项包括<code>LOG_PID</code>（在每条日志消息中记录进程ID）、<code>LOG_CONS</code>（如果消息不能发送给<code>syslogd</code>，那么将消息直接写入到控制台）、<code>LOG_NDELAY</code>（立即打开连接，而不是等到第一条消息被发送）、<code>LOG_ODELAY</code>（延迟打开连接，直到第一条消息被发送），等等。选项可以通过或运算（<code>|</code>）来组合。</li><li><code>facility</code>：这是一个标识符，用于指示消息的类型**(信息来源，从那里来的)**。可能的值包括<code>LOG_USER</code>（用户级别的消息）、<code>LOG_MAIL</code>（邮件系统的消息）、<code>LOG_DAEMON</code>（系统守护进程的消息）、<code>LOG_AUTH</code>（安全&#x2F;授权消息），等等</li></ul><p>返回值:</p><ul><li><code>openlog()</code>函数并不会返回任何值</li></ul><h5 id="（2）syslog"><a href="#（2）syslog" class="headerlink" title="（2）syslog"></a>（2）syslog</h5><p><code>syslog()</code> 函数用于向系统日志发送一条消息。此函数通过<code>syslogd</code>守护进程将消息写入日志。在使用 <code>syslog()</code> 之前，通常会使用 <code>openlog()</code> 函数来设置 <code>syslogd </code>的一些参数</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li><code>priority</code>：这是一个整数，用于指定消息的优先级。这是由两部分组成的，一部分是设施值（facility value），一部分是严重性级别（severity level）。设施值用于指定消息的类型，比如 <code>LOG_USER</code>（用户级消息）、<code>LOG_MAIL</code>（邮件系统）、<code>LOG_DAEMON</code>（系统守护进程）等。严重性级别包括 <code>LOG_EMERG</code>（紧急情况，需要立即采取行动）、<code>LOG_ALERT</code>（应立即更正的问题）、<code>LOG_CRIT</code>（关键条件，如硬设备错误）、<code>LOG_ERR</code>（错误条件）、<code>LOG_WARNING</code>（警告条件）、<code>LOG_NOTICE</code>（正常，但重要的条件）、<code>LOG_INFO</code>（信息性消息）以及 <code>LOG_DEBUG</code>（调试级别的信息）。设施值和严重性级别可以用 <code>|</code> 运算符组合起来。</li><li><code>format</code>：这是一个格式化字符串，和 <code>printf()</code> 函数中的格式化字符串相同。你可以在这个字符串中使用 <code>%</code> 转义序列来插入变量值，这些值通过可变参数列表提供</li></ul><p>实例程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    openlog(<span class="string">&quot;myProgram&quot;</span>, LOG_PID | LOG_CONS, LOG_USER);</span><br><span class="line">    syslog(LOG_INFO, <span class="string">&quot;Informational message: %d&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    closelog();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syslog()</code> 发送了一条用户级别的信息性消息，消息内容是 “Informational message: 123”</p><h5 id="（2）closelog"><a href="#（2）closelog" class="headerlink" title="（2）closelog"></a>（2）closelog</h5><p><code>closelog()</code> 函数是一个系统调用，它用于关闭当前进程与系统日志服务（<code>syslogd</code>）的连接。在 <code>openlog()</code> 和 <code>syslog()</code> 调用之后，可以使用 <code>closelog()</code> 来释放资源</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><code>closelog()</code> 函数没有参数，并且也不返回任何值。</p><p>通常，程序会在所有日志消息都已经被发送到 <code>syslog</code> 服务之后调用 <code>closelog()</code> 函数。这是一个良好的实践，尽管大多数现代的 Unix 和 Unix-like 系统会在进程退出时自动关闭 <code>syslog </code>连接</p><h4 id="3-使用系统日志实例"><a href="#3-使用系统日志实例" class="headerlink" title="3.使用系统日志实例"></a>3.使用系统日志实例</h4><p>在之前的守护进程的基础上，将出错信息，发送给系统 日志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建一个守护进程，向一个指定的文件每一秒输入一个数字</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FNAME <span class="string">&quot;/tmp/out&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 守护进程函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">daemonize</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="comment">// 创建一个子进程</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="comment">// 失败</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使父进程退出,这样做的目的是让守护进程在后台运行</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他是子进程的操作</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 守护进程脱离控制终端，但是子进程会复制父进程的相关数据，文件描述符有关标准输入输出的0,1,2也会被与预定义，需要进行重定向</span></span><br><span class="line"><span class="comment">// 打开空设备</span></span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd  &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对文件描述符0，1，2进行重定向</span></span><br><span class="line">dup2(fd,<span class="number">0</span>);</span><br><span class="line">dup2(fd,<span class="number">1</span>);</span><br><span class="line">dup2(fd,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(fd &gt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子进程中创建一个新的会话,这样做的目的是让守护进程摆脱原来的控制终端</span></span><br><span class="line">setsid();</span><br><span class="line"></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变工作路径---切换到根目录</span></span><br><span class="line">chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与系统日志建立链接</span></span><br><span class="line"><span class="comment">// 参数1:随便给</span></span><br><span class="line"><span class="comment">// 参数2:每条日志中需要包含的信息</span></span><br><span class="line"><span class="comment">// 参数3:信息来源,该程序中是守护进程将日志信息发送给syslog服务</span></span><br><span class="line">openlog(<span class="string">&quot;mydaemon&quot;</span>,LOG_PID,LOG_DAEMON);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(daemonize())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 若守护进程创建失败，将错误信息向系统日志进行提交</span></span><br><span class="line"><span class="comment">// 参数1: 信息的级别</span></span><br><span class="line"><span class="comment">// 参数2: 信息格式(换行符这些类型的字符，也会被syslog函数直接识别的原本的字符进行输入，不会将其理解为换行)</span></span><br><span class="line">syslog(LOG_ERR,<span class="string">&quot;daemonize() failed!&quot;</span>);</span><br><span class="line"><span class="comment">// 守护进程结束</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">syslog(LOG_INFO,<span class="string">&quot;daemonize() successded!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fp = fopen(FNAME,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fp==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 向系统日志发送错误信息</span></span><br><span class="line">syslog(LOG_ERR,<span class="string">&quot;fopen():%s&quot;</span>,strerror(errno));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syslog(LOG_INFO,<span class="string">&quot;%s was opened.&quot;</span>,FNAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件中一秒输入一个字符</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"><span class="comment">// 向文件写入是全缓冲模式，刷新流的操作</span></span><br><span class="line">fflush(fp);</span><br><span class="line"><span class="comment">// 每向文件中输入一个数字，就向日志文件中输入一个调试信息</span></span><br><span class="line">syslog(LOG_DEBUG,<span class="string">&quot;%d is printed.&quot;</span>,i);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭与系统日志syslogd服务的链接</span></span><br><span class="line">closelog();</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，前往目录<code>/var/log</code>目录下的<code>syslog</code>文件查看日志信息<code>tail -f /var/log/syslog</code></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202308021117685.png" alt="image-20230802111750637"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境编程-文件系统（9）</title>
      <link href="/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%889%EF%BC%89/"/>
      <url>/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%889%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="UNIX环境编程-文件系统（9）"><a href="#UNIX环境编程-文件系统（9）" class="headerlink" title="UNIX环境编程-文件系统（9）"></a>UNIX环境编程-文件系统（9）</h2><h3 id="一、目录和文件"><a href="#一、目录和文件" class="headerlink" title="一、目录和文件"></a>一、目录和文件</h3><h4 id="1-获取文件属性"><a href="#1-获取文件属性" class="headerlink" title="1.获取文件属性"></a>1.获取文件属性</h4><h5 id="（1）stat、fstat、lstat"><a href="#（1）stat、fstat、lstat" class="headerlink" title="（1）stat、fstat、lstat"></a>（1）stat、fstat、lstat</h5><p>在 C 语言中，<code>stat</code>，<code>fstat</code> 和 <code>lstat</code> 函数用于获取文件的状态信息。这些信息包括文件大小，创建和修改时间，权限等。这些函数在 <code>&lt;sys/stat.h&gt;</code> 头文件中定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>stat</strong></p><p>函数获取指定路径的文件的状态信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> statbuf)</span>;</span><br></pre></td></tr></table></figure><p><strong>fstat</strong></p><p>函数获取一个已经打开的文件（由文件描述符指定）的状态信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br></pre></td></tr></table></figure><p><strong>lstat</strong></p><p>函数类似于 <code>stat</code>，但当指定的路径是一个符号链接时，<code>lstat</code> 返回的是这个链接本身的信息，而 <code>stat</code> 返回的是链接指向的文件的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> statbuf)</span>;</span><br></pre></td></tr></table></figure><p>所有这三个函数都把信息保存在一个 <code>struct stat</code> 结构体中。这个结构体包含了很多字段，包括：</p><ul><li><code>st_mode</code>：文件类型和权限</li><li><code>st_ino</code>：节点编号</li><li><code>st_dev</code>：包含该文件的设备编号</li><li><code>st_nlink</code>：硬链接的数量</li><li><code>st_uid</code>：文件的用户 ID</li><li><code>st_gid</code>：文件的组 ID</li><li><code>st_size</code>：文件的大小（字节）</li><li><code>st_atime</code>，<code>st_mtime</code>，<code>st_ctime</code>：文件的访问，修改和状态改变的时间</li><li><code>st_blksize</code>：优化读文件的块大小</li><li><code>st_blocks</code>：文件占用的磁盘块数</li></ul><p>例如，<strong>下面的程序获取一个文件的大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">&quot;/path/to/your/file&quot;</span>, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File size: %lld bytes\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>) sb.st_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>filesize.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件大小的函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">off_t</span> <span class="title function_">flen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fname)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statres</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(stat(fname,&amp;statres) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;stat()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> statres.st_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Uage...\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)flen(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端中使用 下面的命令查看文件属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$stat filesize.c</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307250947961.png" alt="image-20230725094746926"></p><p>其中大小为:404</p><p>运行程序的可执行文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./filesize filesize.c</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307250949318.png" alt="image-20230725094912284"></p><h4 id="2-文件访问权限"><a href="#2-文件访问权限" class="headerlink" title="2.文件访问权限"></a>2.文件访问权限</h4><p><code>st_mode</code>:stat结构体中st_mode元素涵盖了文件的权限信息，<strong>是一个16位的位图</strong>,用于表示文件类型,文件访问权限,以及特殊权限位。</p><p><code>st_mode</code> 是在 C 语言的 <code>stat</code> 结构中用于描述文件类型和文件权限的成员。<code>stat</code> 结构是 <code>stat()</code>, <code>fstat()</code>, <code>lstat()</code> 等函数的输出，这些函数用来获取文件的属性。</p><p><code>st_mode</code> 是一个位字段，其中一部分用于指示文件类型，另一部分用于指示文件权限。</p><p>在 <code>&lt;sys/stat.h&gt;</code> 头文件中定义了一系列的宏，可以用来检测 <code>st_mode</code> 中的不同位。</p><p>例如，这些宏可以用来检测文件类型：</p><ul><li><code>S_ISREG(m)</code>: 如果 m 是一个普通文件，则返回非零值。</li><li><code>S_ISDIR(m)</code>: 如果 m 是一个目录，则返回非零值。</li><li><code>S_ISCHR(m)</code>: 如果 m 是一个字符设备，则返回非零值。</li><li><code>S_ISBLK(m)</code>: 如果 m 是一个块设备，则返回非零值。</li><li><code>S_ISFIFO(m)</code>: 如果 m 是一个FIFO或者管道，则返回非零值。</li><li><code>S_ISLNK(m)</code>: 如果 m 是一个符号链接，则返回非零值。</li><li><code>S_ISSOCK(m)</code>: 如果 m 是一个套接字，则返回非零值。</li></ul><p>下面的代码检查一个文件是否是一个目录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">&quot;/path/to/your/file&quot;</span>, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a directory.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s not a directory.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-umask"><a href="#3-umask" class="headerlink" title="3.umask"></a>3.umask</h4><h5 id="（1）-rw-rw-r-的含义"><a href="#（1）-rw-rw-r-的含义" class="headerlink" title="（1）-rw-rw-r--的含义"></a>（1）<code>-rw-rw-r--</code>的含义</h5><p>在Linux中，文件权限通常由一个字符串表示，例如<code>-rw-rw-r--</code>。这个字符串由10个字符组成，每个字符的含义如下：</p><p>第一个字符表示文件类型：</p><ul><li><code>-</code> 表示普通文件</li></ul><ul><li><code>d</code> 表示目录</li><li><code>l</code> 表示符号链接</li><li>其他字符表示其他特殊类型的文件</li></ul><p>接下来的三个字符表示文件所有者的权限：</p><ul><li><code>r</code> 表示读权限</li><li><code>w</code> 表示写权限</li><li><code>x</code> 表示执行权限</li><li><code>-</code> 表示没有对应的权限</li></ul><p>因此，在<code>-rw-rw-r--</code>中，<code>rw-</code>表示文件所有者具有读和写权限。</p><ol><li>然后的三个字符表示文件所属的用户组的权限，它们的含义与文件所有者的权限相同。</li><li>最后的三个字符表示其他用户的权限，它们的含义也与文件所有者的权限相同。</li></ol><p>因此，在<code>-rw-rw-r--</code>中，<code>rw-rw-r--</code>表示文件所有者和文件所属的用户组具有读写权限，其他用户只有读权限</p><h5 id="（2）umask的使用"><a href="#（2）umask的使用" class="headerlink" title="（2）umask的使用"></a>（2）umask的使用</h5><p>防止产生权限过松的文件</p><p><code>umask</code>是Unix和Linux系统中用于设置新文件默认权限的命令和函数。它用于控制新建文件或者目录的默认权限设置。具体的权限位是通过取<code>umask</code>和默认权限位（通常为666对于文件，或者777对于目录）的反向位与运算来得到。</p><p>举个例子，如果<code>umask</code>值被设置为022，新建文件的默认权限就会是644（也就是rw-r–r–）。这是因为默认权限666（也就是rw-rw-rw-）和umask值022进行反向位与运算的结果是644。</p><p>同样的，新建目录的默认权限会是755（也就是rwxr-xr-x）。这是因为默认权限777（也就是rwxrwxrwx）和umask值022进行反向位与运算的结果是755</p><p>可以在命令行中用<code>umask</code>命令来查看或者修改当前的<code>umask</code>值。例如，输入<code>umask</code>并按回车，就会显示当前的<code>umask</code>值。输入<code>umask 022</code>并回车，就会设置<code>umask</code>值为022</p><p>需要注意的是，<code>umask</code>不应该被用于修改已经存在的文件或者目录的权限，对于这个目的应该使用<code>chmod</code>命令</p><p>在终端可以输入<code>umask</code>查看当前新建文件的权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/fs$ umask </span><br><span class="line"><span class="number">0002</span></span><br></pre></td></tr></table></figure><p>终端输入<code>ll</code>查看文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/fs$ ll</span><br><span class="line">总用量 <span class="number">36</span></span><br><span class="line">drwxrwxr-x <span class="number">2</span> zxz zxz  <span class="number">4096</span> <span class="number">7</span>月  <span class="number">26</span> <span class="number">09</span>:<span class="number">53</span> ./</span><br><span class="line">drwxrwxr-x <span class="number">4</span> zxz zxz  <span class="number">4096</span> <span class="number">7</span>月  <span class="number">25</span> <span class="number">09</span>:<span class="number">37</span> ../</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz     <span class="number">7</span> <span class="number">7</span>月  <span class="number">25</span> <span class="number">09</span>:<span class="number">44</span> <span class="number">1.</span>txt</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz     <span class="number">0</span> <span class="number">7</span>月  <span class="number">26</span> <span class="number">09</span>:<span class="number">53</span> big.c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">17056</span> <span class="number">7</span>月  <span class="number">25</span> <span class="number">09</span>:<span class="number">50</span> filesize*</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">419</span> <span class="number">7</span>月  <span class="number">25</span> <span class="number">09</span>:<span class="number">50</span> filesize.c</span><br></pre></td></tr></table></figure><p>更改权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$umask <span class="number">0666</span></span><br></pre></td></tr></table></figure><p>则此时新创建的文件权限为<code>0666 &amp; ~0666</code> &#x3D; <code>0000</code> 若创建的是目录则文件权限为<code>0777 &amp; ~0666</code> </p><p>创建新文件big1.c</p><p>查看文件权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/fs$ touch big1.c</span><br><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/fs$ ll</span><br><span class="line">总用量 <span class="number">36</span></span><br><span class="line">drwxrwxr-x <span class="number">2</span> zxz zxz  <span class="number">4096</span> <span class="number">7</span>月  <span class="number">26</span> <span class="number">10</span>:<span class="number">02</span> ./</span><br><span class="line">drwxrwxr-x <span class="number">4</span> zxz zxz  <span class="number">4096</span> <span class="number">7</span>月  <span class="number">25</span> <span class="number">09</span>:<span class="number">37</span> ../</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz     <span class="number">7</span> <span class="number">7</span>月  <span class="number">25</span> <span class="number">09</span>:<span class="number">44</span> <span class="number">1.</span>txt</span><br><span class="line">---------- <span class="number">1</span> zxz zxz     <span class="number">0</span> <span class="number">7</span>月  <span class="number">26</span> <span class="number">10</span>:<span class="number">02</span> big1.c</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz     <span class="number">0</span> <span class="number">7</span>月  <span class="number">26</span> <span class="number">09</span>:<span class="number">53</span> big.c</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> zxz zxz <span class="number">17056</span> <span class="number">7</span>月  <span class="number">25</span> <span class="number">09</span>:<span class="number">50</span> filesize*</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> zxz zxz   <span class="number">419</span> <span class="number">7</span>月  <span class="number">25</span> <span class="number">09</span>:<span class="number">50</span> filesize.c</span><br></pre></td></tr></table></figure><p>可以知道<code>big1.c</code>文件权限为<code>----------</code></p><p>终端的<code>umask</code>指令是通过系统调用umask进行封装的，可以通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man <span class="number">2</span> umask # 查看umask系统调用函数</span><br></pre></td></tr></table></figure><h4 id="4-文件权限的更改-x2F-管理"><a href="#4-文件权限的更改-x2F-管理" class="headerlink" title="4.文件权限的更改&#x2F;管理"></a>4.文件权限的更改&#x2F;管理</h4><h5 id="（1）chmod"><a href="#（1）chmod" class="headerlink" title="（1）chmod"></a>（1）chmod</h5><p>可以改变文件的权限</p><p>如:<code>chmod a+x big.c</code></p><ul><li><code>a</code> 代表所有用户，包括文件所有者、用户组和其他用户。它是 “all” 的缩写。也可以使用 <code>u</code> 代表文件所有者 (“user”)，<code>g</code> 代表用户组 (“group”)，<code>o</code> 代表其他用户 (“others”)</li><li><code>+</code> 是一个操作符，表示添加权限</li><li><code>x</code> 表示执行权限</li><li><code>chmod a+x big.c</code> 这个命令的意思是，给所有用户添加对 <code>big.c</code> 文件的执行权限。在执行了这个命令之后，所有用户都可以执行 <code>big.c</code> 文件（如果它是一个可执行的程序）</li></ul><p>在程序编写中可以使用<code>chmod()</code>与<code>fchmod()</code>函数对文件的的权限进行更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><h4 id="5-粘住位"><a href="#5-粘住位" class="headerlink" title="5.粘住位"></a>5.粘住位</h4><p>“粘住位”（Sticky Bit）是 Unix 和 Unix-like 系统中的一个权限标志，通常用于目录权限的设置</p><p><strong>目的</strong>：</p><p><strong>粘住位的主要作用是防止非所有者删除或重命名目录下的文件</strong>。在默认情况下，如果用户对一个目录有写权限和执行权限，那么他可以删除目录下的任何文件，不管这个文件是由哪个用户创建的。这在某些公共目录（比如&#x2F;tmp和&#x2F;var&#x2F;tmp）中可能会造成问题。通过设置粘住位，我们可以改变这种情况。<strong>当一个目录的粘住位被设置之后，只有文件的所有者或者超级用户（root）才能删除或重命名目录下的文件</strong>。</p><p>在 Unix-like 系统中，你可以使用 chmod 命令来设置粘住位。例如，以下命令会在 &#x2F;tmp 目录上设置粘住位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +t /tmp</span><br></pre></td></tr></table></figure><p>如果你查看一个设置了粘住位的目录的权限，你会发现权限的最后一位是 t，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxrwt  <span class="number">30</span> root     root     <span class="number">4096</span> Apr <span class="number">19</span> <span class="number">19</span>:<span class="number">16</span> /tmp</span><br></pre></td></tr></table></figure><h4 id="6-文件系统-FAT、UFS"><a href="#6-文件系统-FAT、UFS" class="headerlink" title="6.文件系统:FAT、UFS"></a>6.文件系统:<code>FAT</code>、<code>UFS</code></h4><p>文件系统：文件或者数据的存储与管理</p><h5 id="（1）inode"><a href="#（1）inode" class="headerlink" title="（1）inode"></a>（1）inode</h5><p>在 Unix 或 Unix-like 系统（比如 Linux）中，每个文件或目录都有一个相关的 inode (索引节点)，其中包含了大部分文件的元数据（metadata），例如：</p><ul><li>文件类型（普通文件，目录，符号链接，设备文件等）</li><li>文件权限（读，写，执行权限等）</li><li>文件的所有者和群组</li><li>文件的大小</li><li>文件的时间戳，包括最后访问时间（atime）、最后修改时间（mtime）和状态最后改变时间（ctime）</li><li>文件的链接数（硬链接）</li><li>文件的实际数据块的位置</li></ul><p>注意，<strong>文件的名字并不存储在 inode 中，而是存储在目录的数据部分</strong>。</p><p>每个 inode 都有一个唯一的 inode 号，可以用来唯一标识一个文件。实际上，当你通过文件名访问一个文件时，操作系统首先会在目录数据中查找文件名对应的 inode 号，然后通过 inode 号找到 inode，再通过 inode 找到文件的实际数据。</p><p>可以使用 ‘ls -i’ 命令查看文件的 inode 号，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -i /etc/passwd</span><br><span class="line"><span class="number">262146</span> /etc/passwd</span><br></pre></td></tr></table></figure><h5 id="（2）目录项"><a href="#（2）目录项" class="headerlink" title="（2）目录项"></a>（2）目录项</h5><p>在Unix-like系统中，每个目录项通常包括以下两个部分：</p><ul><li>文件名（filename）：表示文件的名称。这是人类可读的文件标识符，用于通过文件系统浏览和访问文件。</li><li>Inode号（inode number）：是文件在文件系统中的唯一标识符，存储文件的元数据，如文件大小、所有者、权限等，并<strong>指向存储文件数据的物理块</strong>。</li></ul><p>目录实际上就是一组目录项的列表，每个目录项都链接到一个inode，这个inode可以是文件，也可以是其他目录。这样，通过目录和目录项，文件系统能够实现文件和目录的组织和查找。</p><p>值得注意的是，目录项并不包含文件内容或文件属性（如修改日期、权限等）。这些信息都存储在inode中</p><h5 id="（3）FAT与UFS"><a href="#（3）FAT与UFS" class="headerlink" title="（3）FAT与UFS"></a>（3）FAT与UFS</h5><p>FAT文件系统：</p><p> FAT是一种由微软公司创建的老式文件系统，主要用于微软的操作系统中，如DOS和早期的Windows。FAT文件系统有几个不同的版本，包括FAT12（用于早期的PC-DOS和MS-DOS系统），FAT16和FAT32。FAT的主要特点是简单且兼容性强，这使得它在许多嵌入式系统和可移动存储设备（如U盘和SD卡）中得到广泛应用。然而，FAT文件系统也有其局限性，比如在FAT32中，单个文件的最大大小限制为4GB，且不支持权限管理等。</p><p>UFS文件系统： </p><p>UFS是一种主要用于Unix和Unix-like系统（包括BSD、Solaris等）的文件系统。它是基于更早期的FFS（Fast File System）发展而来的，支持更多的现代文件系统特性，如日志（journalling，能提高文件系统的健壮性和恢复速度），软链接（symbolic links）和硬链接（hard links），以及更复杂的权限管理。UFS使用inode来存储文件元数据，支持大文件（多于4GB）的存储。</p><h4 id="7-硬链接与符号链接"><a href="#7-硬链接与符号链接" class="headerlink" title="7.硬链接与符号链接"></a>7.硬链接与符号链接</h4><h5 id="（1）硬链接"><a href="#（1）硬链接" class="headerlink" title="（1）硬链接"></a>（1）硬链接</h5><p>创建一个文件<code>touch big1.c</code></p><p>可以使用<code>stat big1.c</code>查看文件属性，其中硬链数也存在</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307261110391.png" alt="image-20230726111037355"></p><p>给该文件做一个硬链接<code>ln</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln big1.c big1_link</span><br></pre></td></tr></table></figure><p>查看<code>big1_link</code>的文件属性</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307261113453.png" alt="image-20230726111309413"></p><p>可以知道此时<code>big1_link</code>文件的硬链接数量+1，且其inode号与big1.c相同</p><p><strong>硬链接可以使得多个不同的文件关联同一个inode信息</strong>，类似多个指针指向同一个空间</p><p>将原文件<code>big1.c</code>删除，查看<code>big1_link</code>文件属性</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307261115630.png" alt="image-20230726111552589"></p><p>硬链接数量-1，但是仍然可以通过<code>big1_link</code>操作<code>inode</code>号指向的物理内存</p><p><strong>硬链接为目录项的同义词</strong></p><p><strong>硬链接</strong>：硬链接是一个文件系统中的条目或引用，指向存储数据的inode。原始文件和硬链接共享相同的inode和存储空间，它们在文件系统中是平等的，没有主从之分。<strong>删除任何一个都不会影响其他的</strong>。但是，硬链接不能跨文件系统，也不能链接到目录(<strong>不能给分区也不能给目录建立</strong>)</p><h5 id="（2）符号链接"><a href="#（2）符号链接" class="headerlink" title="（2）符号链接"></a>（2）符号链接</h5><p><strong>符号链接</strong>：符号链接和硬链接不同，它是一个单独的文件，包含了另一个文件的路径（可以理解为一个指向另一个文件或目录的指针）。可以跨文件系统，可以链接目录。<strong>如果删除了符号链接指向的原始文件，那么符号链接将会失效</strong></p><p><strong>在windows下类似于软件的快捷方式</strong></p><p>创建符号链接<code>ln -l</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -l big1.c big1_link</span><br></pre></td></tr></table></figure><h5 id="（3）link-与unlink-函数"><a href="#（3）link-与unlink-函数" class="headerlink" title="（3）link()与unlink()函数"></a>（3）link()与unlink()函数</h5><p>在C语言中，link和unlink是两个系统调用函数，它们用于操作Unix&#x2F;Linux文件系统中的硬链接</p><ul><li>link()：此函数用于创建一个新的硬链接。函数原型如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *existing, <span class="type">const</span> <span class="type">char</span> *new)</span>;</span><br></pre></td></tr></table></figure><p>其中，existing参数是现有文件的路径，new参数是新创建的硬链接的路径。成功时，这个函数返回0，如果出现错误，它返回-1，并设置errno为指示错误类型的值</p><ul><li>unlink()：此函数用于删除一个文件的硬链接。函数原型如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>其中，pathname参数是需要删除链接的文件路径。如果成功，此函数返回0，如果失败，它返回-1，并设置errno为指示错误的值</p><p>注意，当一个文件的硬链接被删除，文件系统会减少文件inode的链接计数。只有当这个链接计数减少到0时（也就是说，没有硬链接指向该文件），文件系统才会真正删除该文件，并释放它所占用的磁盘空间</p><h5 id="（4）remove与rename函数"><a href="#（4）remove与rename函数" class="headerlink" title="（4）remove与rename函数"></a>（4）remove与rename函数</h5><p>remove()和rename()都是标准库函数，它们在&lt;stdio.h&gt;头文件中声明。它们用于文件操作，如删除文件或重命名文件</p><ul><li>remove(): 此函数用于删除一个文件或者目录。函数原型如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>其中，pathname是需要删除的文件或目录的路径。如果成功，此函数返回0。如果失败，它返回-1，并设置errno为指示错误的值</p><ul><li>rename(): 此函数用于重命名一个文件或目录。函数原型如下\</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure><p>其中，oldpath是现有文件或目录的路径，newpath是新的名称。如果成功，此函数返回0。如果失败，它返回-1，并设置errno为指示错误的值</p><p>请注意，remove()和rename()函数的行为可能会因文件系统类型和操作系统而有所不同。例如，rename()在某些系统上可能无法跨文件系统移动文件，或者如果newpath已经存在，它的行为可能会因系统而异。因此，当使用这些函数时，您应该总是检查它们的返回值以确定操作是否成功，并适当地处理错误</p><h4 id="8-utime"><a href="#8-utime" class="headerlink" title="8.utime"></a>8.utime</h4><p>可以更改文件最后的读的时间与最后修改的时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span>;</span><br></pre></td></tr></table></figure><h4 id="9-目录的创建和销毁"><a href="#9-目录的创建和销毁" class="headerlink" title="9.目录的创建和销毁"></a>9.目录的创建和销毁</h4><h5 id="（1）mkdir与rmdir"><a href="#（1）mkdir与rmdir" class="headerlink" title="（1）mkdir与rmdir"></a>（1）mkdir与rmdir</h5><p>在C语言中，mkdir() 和 rmdir() 函数是用来创建和删除目录的。这两个函数在 <code>&lt;sys/stat.h&gt;</code> 和 <code>&lt;sys/types.h&gt;</code> 头文件中声明。</p><ul><li><code>mkdir()</code>: 这个函数用于创建一个新的目录。函数的原型如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mkdir(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure><p>其中，<code>pathname</code> 是要创建的新目录的路径，<code>mode</code> 是新目录的权限位。如果函数成功，则返回 0。如果失败，则返回 -1，并设置 <code>errno</code> 为表示错误的值。</p><ul><li><code>rmdir()</code>: 这个函数用于删除一个已存在的目录。函数的原型如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rmdir(const char *pathname);</span><br></pre></td></tr></table></figure><p>其中，<code>pathname</code> 是要删除的目录的路径。如果函数成功，则返回 0。如果失败，则返回 -1，并设置 <code>errno</code> 为表示错误的值。</p><p>注意：<strong>在使用 <code>rmdir()</code> 删除一个目录时，该目录必须为空</strong>，也就是说，它不包含任何其他的文件或目录。如果目录非空，则函数将失败。</p><h4 id="10-更改当前工作路径"><a href="#10-更改当前工作路径" class="headerlink" title="10.更改当前工作路径"></a>10.更改当前工作路径</h4><h5 id="（1）chdir与fchdir"><a href="#（1）chdir与fchdir" class="headerlink" title="（1）chdir与fchdir"></a>（1）chdir与fchdir</h5><p>在C语言中，chdir()和fchdir()都是用来改变当前的工作目录的</p><ul><li><code>chdir()</code>: 这个函数用于改变当前的工作目录。函数的原型如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int chdir(const char *path);</span><br></pre></td></tr></table></figure><p>其中，<code>path</code> 是要设为新的工作目录的路径。如果函数成功，则返回 0。如果失败，则返回 -1，并设置 <code>errno</code> 为表示错误的值。</p><p><strong>可以更改当前进程的工作目录，若需要将一个进程设置为守护进程，需要一直运行，这个时候可以将这个进程切换到一个一直存在不会被轻易卸载的路径</strong></p><ul><li><code>fchdir()</code>: 这个函数也是用于改变当前的工作目录，但是它接收一个已经打开的目录文件的文件描述符作为参数，而不是一个路径。函数的原型如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fchdir(int fd);</span><br></pre></td></tr></table></figure><p>其中，<code>fd</code> 是一个已经打开的目录文件的文件描述符。如果函数成功，则返回 0。如果失败，则返回 -1，并设置 <code>errno</code> 为表示错误的值。</p><p><code>chdir()</code> 和 <code>fchdir()</code> 函数都声明在 <code>&lt;unistd.h&gt;</code> 头文件中</p><h5 id="（2）getcwd"><a href="#（2）getcwd" class="headerlink" title="（2）getcwd"></a>（2）getcwd</h5><p>在C语言中，<code>getcwd()</code>函数用于获取当前工作目录的绝对路径。这个函数在<code>unistd.h</code>头文件中声明。</p><p><code>getcwd()</code>函数的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *getcwd(char *buf, size_t size);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>buf</code> 是一个字符指针，指向一个预先分配的缓冲区，这个缓冲区用于存储获取的路径。如果<code>buf</code>参数为NULL，新的缓冲区可能会被malloc()，<strong>需要在使用完后free()这个缓冲区</strong>。</li><li><code>size</code> 参数是缓冲区的大小。如果路径的长度超过这个大小，函数将返回NULL，并将<code>errno</code>设置为<code>ERANGE</code>。</li></ul><p>函数的返回值是一个指向表示当前工作目录的字符串的指针。如果出错，它会返回 NULL，并设置 <code>errno</code> 来表示错误</p><p>示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *cwd;</span><br><span class="line">    cwd = getcwd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cwd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current working directory is: %s\n&quot;</span>, cwd);</span><br><span class="line">        <span class="built_in">free</span>(cwd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会打印出当前的工作目录。注意我们在使用完 <code>cwd</code> 后调用 <code>free()</code> 函数来释放内存</p><h4 id="11-分析目录-x2F-读取目录内容"><a href="#11-分析目录-x2F-读取目录内容" class="headerlink" title="11.分析目录&#x2F;读取目录内容"></a>11.分析目录&#x2F;读取目录内容</h4><h5 id="（1）glob"><a href="#（1）glob" class="headerlink" title="（1）glob"></a>（1）glob</h5><p><code>glob()</code>函数是C语言中用于查找文件系统中与给定模式匹配的路径名的函数。这个函数在文件系统中查找文件名，并返回一个包含所有匹配的路径名的列表<br><strong>函数原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">glob</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pattern, <span class="type">int</span> flags, </span></span><br><span class="line"><span class="params">         <span class="type">int</span> (*errfunc) (<span class="type">const</span> <span class="type">char</span> *epath, <span class="type">int</span> eerrno), </span></span><br><span class="line"><span class="params">         <span class="type">glob_t</span> *pglob)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p><code>pattern</code>：这是要匹配的模式字符串。它可以包含各种特殊字符，如星号（*），问号（?）和方括号（[]）等，这些都可以用于匹配一个或多个字符。</p></li><li><p><code>flags</code>：这是影响 <code>glob()</code> 函数行为的标志。例如，<code>0</code>表示不需要进行其他扩展,<code>GLOB_TILDE</code> 会扩展波浪号（~），<code>GLOB_BRACE</code> 会扩展花括号表达式，等等。</p></li><li><p><code>errfunc</code>：这是一个函数指针，可以用来处理在查找过程中发生的错误。如果这个参数为 <code>NULL</code>，<code>glob()</code> 将忽略所有错误。，若发生错误，会将发生错误的路径传给epath,错误号赋值给errno</p></li><li><p><code>pglob</code>：这是一个指向 <code>glob_t</code> 结构体的指针，用于接收匹配的结果。<code>glob_t</code> 结构体包含了匹配到的路径名的数量和指向路径名数组的指针。</p></li><li><pre><code class="c">typedef struct &#123;    size_t   gl_pathc;    /* Count of paths matched so far */    char   **gl_pathv;    /* List of matched pathnames.  */    size_t   gl_offs;     /* Slots to reserve in `gl_pathv&#39;.  */&#125; glob_t;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `gl_pathc`：这个字段表示匹配到的路径的数量。</span><br><span class="line">- `gl_pathv`：这是一个指向字符串数组的指针，这个数组包含了所有匹配的路径名。数组以一个空指针（NULL）结束，因此你可以像遍历常规的以 NULL 结束的 C 字符串数组一样遍历它。</span><br><span class="line">- `gl_offs`：这个字段被 `glob()` 函数用来确定在 `gl_pathv` 中预留多少个空槽位。如果 `GLOB_DOOFFS` 标志被设置，那么 `gl_pathv` 数组的前 `gl_offs` 个元素将被初始化为 NULL。</span><br><span class="line"></span><br><span class="line">需要注意的是，`glob()` 函数会为 `gl_pathv` 数组分配内存，因此在使用完这个结构后，需要调用 `globfree()` 函数来释放这部分内存，防止内存泄漏。</span><br><span class="line"></span><br><span class="line">`glob()`函数执行成功后，返回0，失败时返回一个错误代码</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;glob.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 模式是当前目录下 以b开头的文件</span><br><span class="line">#define PAT &quot;./b*&quot;  </span><br><span class="line"></span><br><span class="line">// 回调函数</span><br><span class="line">#if 1</span><br><span class="line">static int errfunc_(const char *errpath,int errno)</span><br><span class="line">&#123;</span><br><span class="line">puts(errpath);</span><br><span class="line">fprintf(stderr,&quot;ERROR MSG:%s\n&quot;,strerror(errno));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">int err;</span><br><span class="line">glob_t globres;</span><br><span class="line"></span><br><span class="line">// err==0表示成功 否则失败</span><br><span class="line">err = glob(PAT,0,errfunc_,&amp;globres);</span><br><span class="line">if(err)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;ERROR CODE  = %d \n&quot;,err);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将glob_t结构体的信息打印</span><br><span class="line">for(int i = 0;i&lt;globres.gl_pathc;i++)</span><br><span class="line">puts(globres.gl_pathv[i]);</span><br><span class="line"></span><br><span class="line">globfree(&amp;globres);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h5 id="（2）globfree"><a href="#（2）globfree" class="headerlink" title="（2）globfree"></a>（2）globfree</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">globfree</span><span class="params">(<span class="type">glob_t</span> *pglob)</span>;</span><br></pre></td></tr></table></figure><p>这个函数用于释放 <code>glob()</code> 函数为 <code>pglob</code> 结构分配的内存</p><h3 id="二、系统数据文件和信息"><a href="#二、系统数据文件和信息" class="headerlink" title="二、系统数据文件和信息"></a>二、系统数据文件和信息</h3><h4 id="1-时间函数精讲"><a href="#1-时间函数精讲" class="headerlink" title="1.时间函数精讲"></a>1.时间函数精讲</h4><p><a href="https://www.bilibili.com/video/BV18p4y167Md/?p=156&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><h5 id="（1）time"><a href="#（1）time" class="headerlink" title="（1）time"></a>（1）time</h5><p><code>time</code>函数是一个系统调用，可以将系统时间获得，并且存储在一个<code>time_t</code>存储日历时间的算术类型中</p><p><code>time()</code>函数会返回系统的当前日历时间，自1970年1月1日以来的秒数（也被称为UNIX时间或POSIX时间）。如果系统没有时间，则返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       time - get time in seconds</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line">       <span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *tloc)</span>;</span><br></pre></td></tr></table></figure><p>参数 <code>tloc</code> 是一个指向 <code>time_t</code> 类型的指针，如果该指针不为空，那么返回的时间值也会存储在这个指针指向的位置。如果传入NULL，那么函数只会返回时间值。</p><p>使用方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> stamp;</span><br><span class="line"><span class="comment">// 传入 time_t 类型数据</span></span><br><span class="line">time(&amp;stamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入NULL</span></span><br><span class="line">stamp = time(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTime == ((<span class="type">time_t</span>)<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failure to compute the current time.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The current time is %ld.\n&quot;</span>, currentTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们获取了当前的时间，并打印出来。如果 <code>time()</code> 函数返回 <code>-1</code>，我们就输出一个错误消息</p><h5 id="（2）gmtime"><a href="#（2）gmtime" class="headerlink" title="（2）gmtime"></a>（2）gmtime</h5><p>在C语言中，<code>gmtime()</code>函数用于将<code>time_t</code>类型的时间转换为一个表示UTC时间的<code>tm</code>结构体</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> tm * <span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timer)</span>;</span><br></pre></td></tr></table></figure><p>函数接受一个指向<code>time_t</code>类型的指针<code>timer</code>，并返回一个指向<code>tm</code>结构体的指针。这个结构体包含了转换后的时间（UTC时间）</p><p><code>tm</code>结构体包含成员如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">   <span class="type">int</span> tm_sec;   <span class="comment">// 秒，正常范围从0到59，但允许至61</span></span><br><span class="line">   <span class="type">int</span> tm_min;   <span class="comment">// 分，范围从0到59</span></span><br><span class="line">   <span class="type">int</span> tm_hour;  <span class="comment">// 小时，范围从0到23</span></span><br><span class="line">   <span class="type">int</span> tm_mday;  <span class="comment">// 一月中的第几天，范围从1到31</span></span><br><span class="line">   <span class="type">int</span> tm_mon;   <span class="comment">// 月，范围从0到11</span></span><br><span class="line">   <span class="type">int</span> tm_year;  <span class="comment">// 自1900年起的年数</span></span><br><span class="line">   <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的第几天，范围从0到6，从星期日算起</span></span><br><span class="line">   <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的第几天，范围从0到365，从1月1日算起</span></span><br><span class="line">   <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> rawtime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">timeinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    time (&amp;rawtime);</span><br><span class="line">    timeinfo = gmtime(&amp;rawtime);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The current date/time is: %s&quot;</span>, asctime(timeinfo));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子获取当前的时间，转换为UTC时间，并打印出来</p><h5 id="（3）localtime"><a href="#（3）localtime" class="headerlink" title="（3）localtime"></a>（3）localtime</h5><p>在C语言中，<code>localtime()</code> 函数被用于将一个 <code>time_t</code> 类型的时间转换为表示本地时间的 <code>tm</code> 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> tm* <span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timer)</span>;</span><br></pre></td></tr></table></figure><p><code>localtime()</code> 函数接收一个指向 <code>time_t</code> 类型的指针 <code>timer</code>，并返回一个指向 <code>tm</code> 结构体的指针。这个结构体包含了转换后的时间（即本地时间）</p><p>示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> rawtime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">timeinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    time (&amp;rawtime);</span><br><span class="line">    timeinfo = localtime(&amp;rawtime);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;The current local time is: %s&quot;</span>, asctime(timeinfo));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例获取了当前的时间，并将其转换为本地时间，然后将其打印出来</p><h5 id="（4）mktime"><a href="#（4）mktime" class="headerlink" title="（4）mktime"></a>（4）mktime</h5><p><code>mktime</code> 是C语言中的一个函数，它用于将一个 <code>tm</code> 结构体（通常由 <code>gmtime</code> 或 <code>localtime</code> 返回）转换为一个 <code>time_t</code> 类型的值（该值表示从Epoch（1970年1月1日 00:00:00 UTC）到指定时间的秒数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用是将 <code>tm</code> 结构体表示的本地时间转换为 <code>time_t</code> 类型表示的自Epoch以来的秒数。如果转换成功，函数会返回转换后的 <code>time_t</code> 值。如果转换失败，函数会返回 <code>(time_t) -1</code></p><p>注意，<code>mktime</code> 会调整 <code>tm</code> 结构体的 <code>tm_wday</code> 和 <code>tm_yday</code> 字段，并可能调整其他字段，以便所有字段的值都处于正常范围内（<strong>自动调整肯不正确的结构体元素</strong>）</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">timeinfo</span>;</span></span><br><span class="line">    <span class="type">time_t</span> rawtime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 timeinfo 为 2023 年 7 月 27 日 12 点 0 分</span></span><br><span class="line">    timeinfo.tm_year = <span class="number">2023</span> - <span class="number">1900</span>;</span><br><span class="line">    timeinfo.tm_mon = <span class="number">7</span> - <span class="number">1</span>;</span><br><span class="line">    timeinfo.tm_mday = <span class="number">27</span>;</span><br><span class="line">    timeinfo.tm_hour = <span class="number">12</span>;</span><br><span class="line">    timeinfo.tm_min = <span class="number">0</span>;</span><br><span class="line">    timeinfo.tm_sec = <span class="number">0</span>;</span><br><span class="line">    timeinfo.tm_isdst = <span class="number">-1</span>; <span class="comment">// 让 mktime 自动检测夏令时</span></span><br><span class="line"></span><br><span class="line">    rawtime = mktime(&amp;timeinfo);</span><br><span class="line">    <span class="keyword">if</span> (rawtime == (<span class="type">time_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mktime failed\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The time is %s&quot;</span>, ctime(&amp;rawtime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子将日期 “2023-07-27 12:00:00” 转换为自Epoch以来的秒数，并打印出转换后的时间</p><h5 id="（5）strftime"><a href="#（5）strftime" class="headerlink" title="（5）strftime"></a>（5）strftime</h5><p><code>strftime</code> 是C语言中的一个函数，它可以根据给定的格式字符串将一个 <code>struct tm</code> 结构体格式化为一个字符串。这个函数对于日期和时间的格式化非常有用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> maxsize, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *tim_p)</span>;</span><br></pre></td></tr></table></figure><p>参数的意义如下：</p><ul><li><code>s</code> 是用来存储格式化字符串的缓冲区。</li><li><code>maxsize</code> 是缓冲区的大小。</li><li><code>format</code> 是格式字符串，它定义了输出的格式。</li><li><code>tim_p</code> 是一个指向 <code>struct tm</code> 结构体的指针，这个结构体包含了要格式化的时间。</li></ul><p>这个函数将根据 <code>format</code> 中的格式说明符将时间格式化为字符串，并将结果存储在 <code>s</code> 中。如果格式化的字符串（包括终止的空字符）的长度大于 <code>maxsize</code>，那么 <code>strftime</code> 会返回0，并且 <code>s</code> 的内容可能是未定义的</p><p>以下是一些常见的格式说明符：</p><ul><li><code>%Y</code>：四位数的年份</li><li><code>%m</code>：两位数的月份</li><li><code>%d</code>：两位数的日期</li><li><code>%H</code>：24小时制的小时</li><li><code>%M</code>：两位数的分钟</li><li><code>%S</code>：两位数的秒</li><li><code>%A</code>：完整的星期几名称</li><li><code>%B</code>：完整的月份名称</li></ul><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line">    <span class="type">time_t</span> rawtime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">timeinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    time(&amp;rawtime);</span><br><span class="line">    timeinfo = localtime(&amp;rawtime);</span><br><span class="line"></span><br><span class="line">    strftime(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;%A %B %d, %Y %H:%M:%S&quot;</span>, timeinfo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Formatted time: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子首先获取当前的时间（自Epoch以来的秒数），然后将其转换为本地时间，最后使用 <code>strftime</code> 将时间格式化为一个字符串并打印出来</p><h5 id="（6）编写程序在一个指定文件中输入当前的时间变化"><a href="#（6）编写程序在一个指定文件中输入当前的时间变化" class="headerlink" title="（6）编写程序在一个指定文件中输入当前的时间变化"></a>（6）编写程序在一个指定文件中输入当前的时间变化</h5><p>执行程序后可以重新打开一个终端使用以下命令进行跟踪当前文件内容的变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f &#123;文件路径&#125;</span><br></pre></td></tr></table></figure><p>程序代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILENAME <span class="string">&quot;./out&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="type">char</span> buf[BUFSIZE];</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">time_t</span> stamp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对文件进行追加读写，若不存在则进行创建</span></span><br><span class="line">fp = fopen(FILENAME,<span class="string">&quot;a+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件内容并且统计行数</span></span><br><span class="line"><span class="keyword">while</span>(fgets(buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,fp)!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环，会存在内存泄漏，因为fclose执行不了</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">time(&amp;stamp);</span><br><span class="line">tm = localtime(&amp;stamp);</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%-4d %d-%d-%d %d:%d:%d\n&quot;</span>,\</span><br><span class="line">++count,tm-&gt;tm_year+<span class="number">1900</span>,tm-&gt;tm_mon+<span class="number">1</span>,tm-&gt;tm_mday,\</span><br><span class="line">tm-&gt;tm_hour,tm-&gt;tm_min,tm-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新缓冲区(因为fprintf函数不会因为\n 而刷新缓冲区，会得内容满了在刷新，所以需要主动刷新)</span></span><br><span class="line">fflush(fp);</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>make之后，执行<code>tail -f ./out</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/fs$ tail -f ./out </span><br><span class="line"><span class="number">42</span>   <span class="number">123</span><span class="number">-6</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">58</span></span><br><span class="line"><span class="number">43</span>   <span class="number">123</span><span class="number">-6</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">59</span></span><br><span class="line"><span class="number">44</span>   <span class="number">123</span><span class="number">-6</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">0</span></span><br><span class="line"><span class="number">45</span>   <span class="number">123</span><span class="number">-6</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">1</span></span><br><span class="line"><span class="number">46</span>   <span class="number">123</span><span class="number">-6</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">2</span></span><br><span class="line"><span class="number">47</span>   <span class="number">123</span><span class="number">-6</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">3</span></span><br><span class="line"><span class="number">48</span>   <span class="number">123</span><span class="number">-6</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">4</span></span><br><span class="line"><span class="number">49</span>   <span class="number">2023</span><span class="number">-7</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">15</span>:<span class="number">45</span></span><br><span class="line"><span class="number">50</span>   <span class="number">2023</span><span class="number">-7</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">15</span>:<span class="number">46</span></span><br><span class="line"><span class="number">51</span>   <span class="number">2023</span><span class="number">-7</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">15</span>:<span class="number">47</span></span><br><span class="line"><span class="number">52</span>   <span class="number">2023</span><span class="number">-7</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">15</span>:<span class="number">48</span></span><br><span class="line"><span class="number">53</span>   <span class="number">2023</span><span class="number">-7</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">15</span>:<span class="number">49</span></span><br><span class="line"><span class="number">54</span>   <span class="number">2023</span><span class="number">-7</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">15</span>:<span class="number">50</span></span><br><span class="line"><span class="number">55</span>   <span class="number">2023</span><span class="number">-7</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">15</span>:<span class="number">51</span></span><br><span class="line"><span class="number">56</span>   <span class="number">2023</span><span class="number">-7</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">15</span>:<span class="number">52</span></span><br><span class="line"><span class="number">57</span>   <span class="number">2023</span><span class="number">-7</span><span class="number">-27</span> <span class="number">10</span>:<span class="number">15</span>:<span class="number">53</span></span><br></pre></td></tr></table></figure><h3 id="三、进程环境"><a href="#三、进程环境" class="headerlink" title="三、进程环境"></a>三、进程环境</h3><h4 id="1-main函数"><a href="#1-main函数" class="headerlink" title="1.main函数"></a>1.main函数</h4><p>​<code>int main(int argc,char *argv[])</code></p><h4 id="2-进程的终止"><a href="#2-进程的终止" class="headerlink" title="2.进程的终止"></a>2.进程的终止</h4><p>正常终止:</p><p>​从<code>main</code>函数<code>return</code></p><p>​调用<code>exit()</code></p><p>​调用<code>_exit</code>或者<code>_EXIT</code></p><p>​最后一个线程从其启动例程返回</p><p>​最后一个线程调用pthread_exit</p><p>异常终止:</p><p>​调用abort</p><p>​接到一个信号并且终止</p><p>​最后一个线程对其取消请求作出响应</p><p>​</p><h5 id="（1）父子进程"><a href="#（1）父子进程" class="headerlink" title="（1）父子进程"></a>（1）父子进程</h5><p>在操作系统中，<strong>进程（Process）是程序的一次运行实例</strong>，可以被操作系统管理和调度的基本单位。<strong>每个进程都有其自己的内存空间和系统资源。进程间不能直接访问彼此的资源，只能通过进程间通信（如：管道、消息队列、信号等）来进行数据交换</strong></p><p>在Unix&#x2F;Linux系统中，进程之间的关系通常为父子关系，即一个进程是由另一个进程创建的。</p><p><strong>父进程</strong>：是创建其他进程（子进程）的进程。</p><p><strong>子进程</strong>：是由其他进程（父进程）创建的进程。</p><p>子进程和父进程的<strong>主要区别</strong>是它们的内存空间和系统资源。<strong>子进程是父进程的复制品，它获得父进程数据的副本（例如变量，环境变量等），但是子进程并不能访问父进程的数据段，代码段。换句话说，父进程和子进程有各自独立的运行环境</strong>。</p><p>在C语言中，通常使用<code>fork</code>函数来创建子进程。<code>fork</code>函数会创建一个新的进程，新进程是调用<code>fork</code>的进程（父进程）的一个复制品。</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fork a child process */</span></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123; <span class="comment">/* error occurred */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* child process */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child %d\n&quot;</span>,pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* parent process */</span></span><br><span class="line">        <span class="comment">/* parent will wait for the child to complete */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the parent %d\n&quot;</span>,pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，**<code>fork</code>函数被调用一次，但返回两次**。一次是在父进程中，一次是在子进程中。在子进程中，<code>fork</code>函数返回0，在父进程中，<code>fork</code>函数返回子进程的PID</p><h5 id="（2）钩子函数"><a href="#（2）钩子函数" class="headerlink" title="（2）钩子函数"></a>（2）钩子函数</h5><p>钩子函数也被称为回调函数，它是一种将函数指针作为参数传递给其他函数的技术。当特定的事件或条件发生时，这个回调函数会被调用，以改变或扩展原有的执行流程</p><h6 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h6><p>在C语言中，<code>exit()</code>函数被用于结束一个程序。这个函数接受一个整型参数，这个参数会被作为程序的退出状态返回给操作系统。函数原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure><ul><li><code>status</code>：这是一个整型参数，可以是任意整型值。这个值通常是<code>EXIT_SUCCESS</code>（这是一个宏，通常被定义为0），<code>EXIT_FAILURE</code>（这也是一个宏，通常被定义为非0值）或者其他一些特定的错误代码。这个退出状态值可以被其他程序（比如shell）获取，以了解程序是如何退出的。</li></ul><p>当调用<code>exit()</code>函数时，程序会立即终止，并且完成一些清理工作，包括：</p><ul><li>关闭所有的标准I&#x2F;O流（如stdin、stdout和stderr等）。</li><li>调用由<code>atexit()</code>函数注册的所有退出处理程序（如果有的话）。</li></ul><p>需要注意的是，<code>exit()</code>函数在终止程序后不会返回，所以它位于程序代码的任何位置，都会立即结束程序</p><h6 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h6><p><code>atexit()</code>函数是C语言库中的一个函数，用于注册一些在程序正常结束时（例如，当<code>return</code>从<code>main()</code>返回或者调用<code>exit()</code>时）需要被调用的函数。这些注册的函数被称为终止处理程序或退出处理程序。<strong>在程序终止时，这些函数将按照与注册（声明）相反的顺序被调用</strong>。这个函数的作用被称之为<strong>钩子函数,一个进程正常终止前会调用钩子函数，释放该释放的内容</strong></p><p><strong>钩子函数顾名思义，去下来的顺序与挂上去的顺序相反，释放顺序类似于栈，主要用于释放资源</strong></p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><p>它在C标准库&lt;stdlib.h&gt;中定义。参数是一个无参且无返回值的函数指针（即，一个接受<code>void</code>参数并返回<code>void</code>的函数）。如果注册成功，<code>atexit()</code>返回0，否则返回非零值</p><p>示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;f1()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;f2()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;f3()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Begin...&quot;</span>);</span><br><span class="line"></span><br><span class="line">atexit(f1());</span><br><span class="line">atexit(f2());</span><br><span class="line">atexit(f3());</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>make之后执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/fs$ make gouzi</span><br><span class="line">cc     gouzi.c   -o <span class="title function_">gouzi</span></span><br><span class="line"><span class="params">(base)</span> zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/fs$ ./gouzi </span><br><span class="line">Begin...</span><br><span class="line">End!</span><br><span class="line"><span class="title function_">f3</span><span class="params">()</span></span><br><span class="line"><span class="title function_">f2</span><span class="params">()</span></span><br><span class="line"><span class="title function_">f1</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>分析:</p><p>程序中写到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atexit(f1());</span><br><span class="line">atexit(f2());</span><br><span class="line">atexit(f3());</span><br></pre></td></tr></table></figure><p>并不是调用，着相当于把这些函数挂到钩子上，<strong>当程序正常结束的时候，才会按照挂上去的相反顺序取下（调用）</strong></p><h5 id="（3）abort"><a href="#（3）abort" class="headerlink" title="（3）abort"></a>（3）abort</h5><p><code>abort</code>函数是C标准库中的一个函数，用于使程序异常终止，并生成一个核心转储文件。它不调用任何由<code>atexit</code>或者<code>on_exit</code>函数注册的函数，也不刷新任何打开的流。函数原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void abort(void);</span><br></pre></td></tr></table></figure><p><code>abort</code>函数没有参数。它会发送一个<code>SIGABRT</code>信号给调用进程，除非这个信号被捕获并且信号处理程序没有返回，否则会使程序异常终止。</p><p>请注意，<code>abort</code>函数的调用不会返回。</p><p>一个简单的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Starting the program...\n&quot;);</span><br><span class="line">    printf(&quot;Aborting the program...\n&quot;);</span><br><span class="line">    abort();</span><br><span class="line">    // The following line will not be printed</span><br><span class="line">    printf(&quot;This line will not be printed.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，程序会在调用<code>abort()</code>之后立即结束，并可能生成一个核心转储文件，所以最后一行printf的语句不会被执行</p><h4 id="3-命令行参数的分析"><a href="#3-命令行参数的分析" class="headerlink" title="3.命令行参数的分析"></a>3.命令行参数的分析</h4><p><a href="https://www.bilibili.com/video/BV18p4y167Md/?p=161&spm_id_from=pageDriver&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><h5 id="（1）getopt"><a href="#（1）getopt" class="headerlink" title="（1）getopt"></a>（1）getopt</h5><h5 id="（2）getopt-long"><a href="#（2）getopt-long" class="headerlink" title="（2）getopt_long"></a>（2）getopt_long</h5><h4 id="4-环境变量"><a href="#4-环境变量" class="headerlink" title="4.环境变量"></a>4.环境变量</h4><h5 id="（1）查看环境变量"><a href="#（1）查看环境变量" class="headerlink" title="（1）查看环境变量"></a>（1）查看环境变量</h5><p>在Ubuntu（以及其他大多数Linux系统）中，<strong>环境变量是存储系统行为信息的全局值</strong>。这些环境变量可以被系统、应用程序、Shell脚本等使用。<strong>环境变量存在于每个运行的进程环境中，子进程会从父进程那里继承这些变量</strong></p><p>以下是一些常见的环境变量：</p><ul><li><code>PATH</code>：这是一个由冒号分隔的目录列表，当你要运行一个可执行文件时，Shell会在<code>PATH</code>中列出的这些目录中查找。</li><li><code>HOME</code>：当前用户的主目录的路径。</li><li><code>PWD</code>：当前工作目录的路径。</li><li><code>USER</code>：当前用户的用户名。</li><li><code>SHELL</code>：当前用户默认的shell。</li><li><code>LANG</code>和<code>LC_*</code>：这些变量用于定义用户的语言和地区设置，包括货币、日期格式、字符编码等。</li><li><code>LD_LIBRARY_PATH</code>：这个变量包含了动态链接库的搜索路径</li></ul><p>可以使用<code>printenv</code>命令来查看当前的环境变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ printenv</span><br></pre></td></tr></table></figure><p>你也可以使用<code>echo</code>命令查看环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br></pre></td></tr></table></figure><p>也可以在终端输入<code>export</code>查看当前系统的环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export</span><br></pre></td></tr></table></figure><p>你可以使用<code>export</code>命令设置新的环境变量，或修改已有的环境变量。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export VARNAME=value</span><br></pre></td></tr></table></figure><p>请注意，通过这种方式设置的环境变量只会对当前Shell及其子进程有效。如果你希望在整个用户会话或系统范围内设置环境变量，你需要在特定的配置文件中（如<code>~/.bashrc</code>，<code>~/.profile</code>，<code>/etc/environment</code>等）设置这些变量。具体取决于你的使用场景和需求。</p><h5 id="（2）编写程序输出环境变量"><a href="#（2）编写程序输出环境变量" class="headerlink" title="（2）编写程序输出环境变量"></a>（2）编写程序输出环境变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;environ[i]!= <span class="literal">NULL</span>;i++)</span><br><span class="line"><span class="built_in">puts</span>(environ[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中，<code>environ</code>是一个全局的外部变量，包含了所有的环境变量。它是一个<strong>字符指针数组</strong>，每个指针都指向一个形如“name&#x3D;value”的字符串，这个字符串就代表一个环境变量的名称和对应的值。这个数组以NULL指针作为结束标志。</p><p>下面是一个简单的例子，展示了如何使用<code>environ</code>来访问环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">extern char **environ;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char **var;</span><br><span class="line">    for (var = environ; *var != NULL; ++var)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, *var);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会打印出所有的环境变量及其对应的值。请注意，在编写依赖于<code>environ</code>的程序时，你需要注意环境变量可能会被其他程序改变，所以依赖于特定环境变量的程序需要在使用这些环境变量之前进行检查。</p><p>另外，如果你只是需要获取特定的环境变量，C标准库提供了<code>getenv</code>函数，可以直接获取指定的环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char *path = getenv(&quot;PATH&quot;);</span><br><span class="line">    if (path != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;PATH = %s\n&quot;, path);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子会打印出PATH环境变量的值</p><h4 id="5-C程序的存储空间布局"><a href="#5-C程序的存储空间布局" class="headerlink" title="5.C程序的存储空间布局"></a>5.C程序的存储空间布局</h4><h5 id="（1）虚拟地址空间"><a href="#（1）虚拟地址空间" class="headerlink" title="（1）虚拟地址空间"></a>（1）虚拟地址空间</h5><p>在32位系统中，<strong>虚拟地址空间</strong>的大小是<strong>由地址的位数决定的</strong>。一般来说，N位的地址可以表示<code>2^N</code>个地址。因此，32位系统可以表示<code>2^32</code>个地址</p><p><code>2^32</code>是<code>4294967296</code>，换算成字节，就是4GB的地址空间。这是理论上的最大值，实际上可用的地址空间可能会因为操作系统的设计和配置而有所不同</p><p>例如，在Windows和Linux操作系统中，32位系统的用户空间通常是2GB或者3GB，剩下的1GB或2GB被保留给内核使用。具体的分配方式取决于操作系统的设计以及配置参数</p><p>需要注意的是，虽然32位系统的虚拟地址空间最大是4GB，但是这并不意味着系统就能支持4GB的物理内存。物理内存的支持量取决于多种因素，包括CPU的寻址能力、主板的设计以及操作系统的配置等</p><h5 id="（2）虚拟地址空间布局"><a href="#（2）虚拟地址空间布局" class="headerlink" title="（2）虚拟地址空间布局"></a>（2）虚拟地址空间布局</h5><p>在一个典型的32位Linux操作系统中，虚拟地址空间分布如下：</p><ul><li>用户空间：这是虚拟地址空间的低地址部分，通常包括从0x00000000到0xBFFFFFFF的地址。这部分地址空间主要用于存放用户程序的代码、数据、堆和栈等。用户空间的大小通常是3GB。</li><li>内核空间：这是虚拟地址空间的高地址部分，通常包括从0xC0000000到0xFFFFFFFF的地址。这部分地址空间主要用于存放内核代码和数据，以及用于操作系统管理的各种数据结构。内核空间的大小通常是1GB。</li></ul><p>在用户空间中，地址布局通常如下：</p><ul><li>低地址部分（通常从0x00000000开始）是代码段，这里存放的是程序的机器代码。</li><li>代码段之后是数据段，这里存放的是程序的全局变量等初始化的数据。</li><li>数据段之后是BSS段，这里存放的是程序未初始化的全局变量。</li><li>BSS段之后是堆（heap）区域，这是动态分配（如malloc和new等操作）的内存区域。堆从低地址向高地址增长。</li><li>高地址部分（通常接近0xBFFFFFFF）是栈（stack）区域，这是存放函数调用栈和局部变量的内存区域。栈从高地址向低地址增长。</li><li>堆和栈之间的部分，通常称为未映射区域，这部分地址空间是空闲的，可以被映射到文件或者被用于扩展堆等。</li></ul><p>以上都是虚拟地址空间的布局，实际的物理内存是由操作系统的内存管理子系统负责分配和回收的。虚拟地址到物理地址的映射是由硬件的内存管理单元（MMU）完成的。</p><h4 id="6-库"><a href="#6-库" class="headerlink" title="6.库"></a>6.库</h4><p>动态库</p><p>静态库</p><h5 id="（1）手工装载库"><a href="#（1）手工装载库" class="headerlink" title="（1）手工装载库"></a>（1）手工装载库</h5><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=164&spm_id_from=pageDriver&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><p>在C语言中，通常我们会静态地或动态地链接到一个库。静态链接会在编译时将库的代码整合到可执行文件中，而动态链接则会在程序运行时将库代码链接到程序中。但除此之外，还有一种手工装载库的方式，它允许我们在程序运行时动态地加载或卸载库。这种方式在Linux系统中主要依赖于<code>dlopen()</code>, <code>dlsym()</code>, <code>dlclose()</code> 和 <code>dlerror()</code> 这几个函数，它们定义在<code>dlfcn.h</code>头文件中</p><p>以下是如何使用这些函数进行手工装载库的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">double</span> (*cosine)(<span class="type">double</span>);  <span class="comment">// 函数指针，指向我们希望调用的库函数</span></span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开库文件</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;libm.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除任何现有的错误</span></span><br><span class="line">    dlerror();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取cos函数的地址</span></span><br><span class="line">    *(<span class="type">void</span> **) (&amp;cosine) = dlsym(handle, <span class="string">&quot;cos&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, (*cosine)(<span class="number">2.0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭库文件</span></span><br><span class="line">    dlclose(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了<code>dlopen()</code>函数打开一个库（这里是数学库<code>libm.so</code>），然后使用<code>dlsym()</code>获取<code>cos</code>函数的地址，并通过一个函数指针调用它。完成后，我们使用<code>dlclose()</code>关闭库</p><p>注意：当你编译这个程序时，你可能需要链接<code>dl</code>库，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprogram myprogram.c -ldl</span><br></pre></td></tr></table></figure><p>手工装载库在很多应用中都很有用，例如插件系统，它允许软件在运行时加载额外的功能或模块</p><h4 id="7-函数跳转"><a href="#7-函数跳转" class="headerlink" title="7.函数跳转"></a>7.函数跳转</h4><h5 id="（1）setjmp与longjmp"><a href="#（1）setjmp与longjmp" class="headerlink" title="（1）setjmp与longjmp"></a>（1）setjmp与longjmp</h5><p><code>setjmp</code> 和 <code>longjmp</code> 是C语言中用于非局部跳转的函数，它们定义在 <code>setjmp.h</code> 头文件中。这两个函数通常配对使用，可以用于从深度嵌套的函数调用中跳回到一个预定的位置，这种跳转方式通常被用于处理错误和异常</p><h6 id="setjmp"><a href="#setjmp" class="headerlink" title="setjmp"></a>setjmp</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br></pre></td></tr></table></figure><p><code>setjmp</code> 是 C 语言中用于保存当前的程序执行环境的函数，这个环境可以被 <code>longjmp</code> 函数用来进行非局部跳转。<code>setjmp</code> 定义在 <code>setjmp.h</code> 头文件中</p><p>这里，<code>jmp_buf</code> 是一个宏，用于保存 setjmp 环境相关的信息，包括堆栈、寄存器等信息</p><p><code>setjmp</code> 函数会保存当前的程序执行环境到 <code>jmp_buf</code> 类型的变量中，然后返回0。</p><p>一旦执行环境被保存，就可以使用 <code>longjmp</code> 函数进行跳转，这会使得程序跳转回 <code>setjmp</code> 的位置，并且 <code>setjmp</code> 的返回值会被设置为 <code>longjmp</code> 的第二个参数的值。</p><h6 id="longjmp"><a href="#longjmp" class="headerlink" title="longjmp"></a>longjmp</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure><p><code>longjmp</code> 是C语言中用于实现非局部跳转的函数。它可以使程序从深度嵌套的函数调用中跳出，回到一个预定的、固定的位置，这个位置就是之前用 <code>setjmp</code> 函数设定的位置。</p><p><code>longjmp</code> 函数的第一个参数是 <code>setjmp</code> 保存环境信息的 <code>jmp_buf</code> 类型变量，第二个参数 <code>val</code> 是设定的返回值，它将会成为 <code>setjmp</code> 的返回值。需要注意的是，<strong>val 的值不能为0，如果val 为0，那么 <code>setjmp</code> 返回值为1</strong>。</p><p><strong><code>setjmp</code>执行一次返回两次，第一次是调用的时候直接返回0，第二次是<code>longjmp</code>跳转到<code>setjmp</code>标记的位置时，将<code>longjmp</code>的第二个参数<code>val</code>作为返回值返回</strong></p><p>使用 <code>longjmp</code> 会使得程序回到最近一次 <code>setjmp</code> 的位置，并且 <code>setjmp</code> 会返回 <code>longjmp</code> 的第二个参数 <code>val</code> 的值。</p><h5 id="（2）代码测试"><a href="#（2）代码测试" class="headerlink" title="（2）代码测试"></a>（2）代码测试</h5><p><strong>查看程序的压栈与弹栈效果</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">c</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Call d().\n&quot;</span>,__FUNCTION__);</span><br><span class="line">d();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():d() returned.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">b</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Call c().\n&quot;</span>,__FUNCTION__);</span><br><span class="line">c();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():c() returned.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Call b().\n&quot;</span>,__FUNCTION__);</span><br><span class="line">b();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():b() returned.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Call a().\n&quot;</span>,__FUNCTION__);</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():a() returned.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的实现逻辑是：在程序中a调用b,b调用c,c调用d,d最后返回。从程序执行效果可以看出，前部分为相互嵌套调用的顺序，后半部分为出栈的顺序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/fs$ ./myjmp </span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>:Begin.</span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>:Call <span class="title function_">a</span><span class="params">()</span>.</span><br><span class="line"><span class="title function_">a</span><span class="params">()</span>:Begin.</span><br><span class="line"><span class="title function_">a</span><span class="params">()</span>:Call <span class="title function_">b</span><span class="params">()</span>.</span><br><span class="line"><span class="title function_">b</span><span class="params">()</span>:Begin.</span><br><span class="line"><span class="title function_">b</span><span class="params">()</span>:Call <span class="title function_">c</span><span class="params">()</span>.</span><br><span class="line"><span class="title function_">c</span><span class="params">()</span>:Begin.</span><br><span class="line"><span class="title function_">c</span><span class="params">()</span>:Call <span class="title function_">d</span><span class="params">()</span>.</span><br><span class="line"><span class="title function_">d</span><span class="params">()</span>:Begin.</span><br><span class="line">    </span><br><span class="line"><span class="title function_">d</span><span class="params">()</span>:End.</span><br><span class="line"><span class="title function_">c</span><span class="params">()</span>:<span class="title function_">d</span><span class="params">()</span> returned.</span><br><span class="line"><span class="title function_">c</span><span class="params">()</span>:End.</span><br><span class="line"><span class="title function_">b</span><span class="params">()</span>:<span class="title function_">c</span><span class="params">()</span> returned.</span><br><span class="line"><span class="title function_">b</span><span class="params">()</span>:End.</span><br><span class="line"><span class="title function_">a</span><span class="params">()</span>:<span class="title function_">b</span><span class="params">()</span> returned.</span><br><span class="line"><span class="title function_">a</span><span class="params">()</span>:End.</span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>:<span class="title function_">a</span><span class="params">()</span> returned.</span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>:End.</span><br></pre></td></tr></table></figure><p>在上述代码的基础上进行修改程序</p><p><strong>在函数<code>d()</code>中进行<code>longjmp</code>,在函数<code>a()</code>中设置跳转点即在函数<code>a()</code>中进行<code>setjmp</code>的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Jump now!\n&quot;</span>,__FUNCTION__);</span><br><span class="line">longjmp(env,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">c</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Call d().\n&quot;</span>,__FUNCTION__);</span><br><span class="line">d();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():d() returned.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">b</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Call c().\n&quot;</span>,__FUNCTION__);</span><br><span class="line">c();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():c() returned.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定义setjmp的返回值</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = setjmp(env);</span><br><span class="line"><span class="comment">// 设置跳转点的时候setjmp返回0</span></span><br><span class="line"><span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Call b().\n&quot;</span>,__FUNCTION__);</span><br><span class="line">b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若通过longjmp从别处跳转回来，则此时返回非0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Jumped back here with code %d \n&quot;</span>,__FUNCTION__,ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():b() returned.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():Call a().\n&quot;</span>,__FUNCTION__);</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():a() returned.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>make之后执行程序运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO/fs$ ./jmp </span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>:Begin.</span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>:Call <span class="title function_">a</span><span class="params">()</span>.</span><br><span class="line"><span class="title function_">a</span><span class="params">()</span>:Begin.</span><br><span class="line"><span class="title function_">a</span><span class="params">()</span>:Call <span class="title function_">b</span><span class="params">()</span>.</span><br><span class="line"><span class="title function_">b</span><span class="params">()</span>:Begin.</span><br><span class="line"><span class="title function_">b</span><span class="params">()</span>:Call <span class="title function_">c</span><span class="params">()</span>.</span><br><span class="line"><span class="title function_">c</span><span class="params">()</span>:Begin.</span><br><span class="line"><span class="title function_">c</span><span class="params">()</span>:Call <span class="title function_">d</span><span class="params">()</span>.</span><br><span class="line"><span class="title function_">d</span><span class="params">()</span>:Begin.</span><br><span class="line"><span class="title function_">d</span><span class="params">()</span>:Jump now!</span><br><span class="line">    </span><br><span class="line"><span class="title function_">a</span><span class="params">()</span>:Jumped back here with code 6 </span><br><span class="line"><span class="title function_">a</span><span class="params">()</span>:<span class="title function_">b</span><span class="params">()</span> returned.</span><br><span class="line"><span class="title function_">a</span><span class="params">()</span>:End.</span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>:<span class="title function_">a</span><span class="params">()</span> returned.</span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>:End.</span><br></pre></td></tr></table></figure><p>可以对比<code>压栈与弹栈效果</code>的程序，原来的弹栈顺序为<code>d-&gt;c-&gt;b-&gt;a</code>,现在程序直接从<code>d</code>跳转到了<code>a</code></p><h4 id="8-资源的获取及控制"><a href="#8-资源的获取及控制" class="headerlink" title="8.资源的获取及控制"></a>8.资源的获取及控制</h4><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=166&spm_id_from=pageDriver&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><h5 id="（1）getrlimit"><a href="#（1）getrlimit" class="headerlink" title="（1）getrlimit"></a>（1）getrlimit</h5><h5 id="（2）setrlimit"><a href="#（2）setrlimit" class="headerlink" title="（2）setrlimit"></a>（2）setrlimit</h5>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境编程-系统调用IO（8）</title>
      <link href="/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8IO%EF%BC%888%EF%BC%89/"/>
      <url>/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8IO%EF%BC%888%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="UNIX环境编程-系统调用IO（8）"><a href="#UNIX环境编程-系统调用IO（8）" class="headerlink" title="UNIX环境编程-系统调用IO（8）"></a>UNIX环境编程-系统调用IO（8）</h2><h3 id="一、文件描述符"><a href="#一、文件描述符" class="headerlink" title="一、文件描述符"></a>一、文件描述符</h3><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=135&spm_id_from=pageDriver&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171951547.png" alt="image-20230717195108379"></p><p>文件描述符的实质:一个整型数字，<strong>数组下标</strong></p><p>在 Unix 和类 Unix 系统（如 Linux）中，文件描述符（file descriptor）是一个抽象的概念，用于表征一个打开的文件或者其他输入&#x2F;输出资源，如管道或网络套接字。</p><p>文件描述符通常是一个非负整数。当一个进程打开一个现有文件或者创建一个新文件时，内核会创建一个文件描述符来表征这个文件。然后，进程可以使用这个文件描述符来读取文件、写入文件，或者进行其他操作。</p><p>例如，在 C 语言中，你可以使用 open 系统调用来打开一个文件，然后得到一个文件描述符。然后你可以使用 read、write 或其他系统调用来操作这个文件</p><p>通常情况下，每个 Unix 或类 Unix 进程都会有三个预定义的文件描述符：<strong>标准输入（0）、标准输出（1）、和标准错误输出（2） 文件描述符的数组中，前三个值是系统给定的</strong>（0，1，2）。这些文件描述符通常分别关联到键盘输入和终端的输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>)  <span class="comment">// 使用系统IO，向标准输出中写入 一个字符b</span></span><br></pre></td></tr></table></figure><p>文件描述符是 Unix 风格操作系统进行 I&#x2F;O 操作的主要方式。</p><h3 id="二、系统调用IO函数"><a href="#二、系统调用IO函数" class="headerlink" title="二、系统调用IO函数"></a>二、系统调用IO函数</h3><h4 id="1-open、close"><a href="#1-open、close" class="headerlink" title="1.open、close"></a>1.open、close</h4><h5 id="（1）open"><a href="#（1）open" class="headerlink" title="（1）open"></a>（1）open</h5><p>在Linux或Unix操作系统中，<code>open</code>是一个系统调用，用于打开文件并返回一个文件描述符。文件描述符是一个用于访问和管理打开文件的抽象指示器。你可以通过这个文件描述符进行读取，写入，或者关闭文件等操作。</p><p>以下是<code>open</code>函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p><code>open</code>函数接收两个或三个参数：</p><ul><li><code>pathname</code>：文件的路径。</li><li><code>flags</code>：打开文件的模式，比如 <code>O_RDONLY</code>（只读），<code>O_WRONLY</code>（只写），<code>O_RDWR</code>（读写），<code>O_CREAT</code>（如果文件不存在，则创建文件），<code>O_TRUNC</code>（如果文件已存在且为可写，则清空文件内容），等等。</li><li><code>mode</code>：当创建新文件时（即使用了<code>O_CREAT</code>标志），<code>mode</code>参数用于指定新文件的权限。这是一个可选参数。</li></ul><p>return : <code>open</code>函数返回一个非负的文件描述符，如果打开文件失败，则返回-1。</p><p><strong>以下是一个简单的示例</strong>，该示例使用<code>open</code>函数打开一个文件进行写入操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Handle error */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Use the file descriptor for writing */</span></span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，如果文件<code>test.txt</code>不存在，那么<code>open</code>函数会创建这个文件，文件的权限会被设置为0644（这意味着文件的所有者可以读写文件，其他用户只能读取文件）。然后，你可以使用返回的文件描述符<code>fd</code>进行写入操作。完成写入操作后，别忘了使用<code>close</code>函数关闭文件。</p><p>在使用<code>open</code>函数时，务必检查其返回值以确保文件已成功打开。如果文件打开失败，<code>open</code>函数将返回-1，并设置全局变量<code>errno</code>以指示发生了什么错误。</p><h4 id="2-read、write、lseek以及mycopy的实现"><a href="#2-read、write、lseek以及mycopy的实现" class="headerlink" title="2.read、write、lseek以及mycopy的实现"></a>2.read、write、lseek以及mycopy的实现</h4><h5 id="（1）read"><a href="#（1）read" class="headerlink" title="（1）read"></a>（1）read</h5><p>在Linux或Unix系统中，<code>read</code>是一个系统调用，用于从打开的文件描述符中读取数据。以下是<code>read</code>函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p><code>read</code>函数接收三个参数：</p><ul><li><code>fd</code>：要读取的文件描述符。这通常是一个先前使用<code>open</code>函数打开的文件的文件描述符。</li><li><code>buf</code>：一个缓冲区，用于存储从文件描述符中读取的数据。</li><li><code>count</code>：要从文件描述符中读取的字节数。</li></ul><p><code>read</code>函数返回实际读取的字节数。如果发生错误，它将返回-1，并设置全局变量<code>errno</code>以指示发生了什么错误。</p><p>在Linux或Unix系统中，<code>read</code>是一个系统调用，用于从打开的文件描述符中读取数据。以下是<code>read</code>函数的原型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cCopy code#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br></pre></td></tr></table></figure><p><code>read</code>函数接收三个参数：</p><ul><li><code>fd</code>：要读取的文件描述符。这通常是一个先前使用<code>open</code>函数打开的文件的文件描述符。</li><li><code>buf</code>：一个缓冲区，用于存储从文件描述符中读取的数据。</li><li><code>count</code>：要从文件描述符中读取的字节数。</li></ul><p><code>read</code>函数<strong>返回实际读取的字节数</strong>。如果发生错误，它将返回-1，并设置全局变量<code>errno</code>以指示发生了什么错误。</p><p><strong>以下是一个简单的示例</strong>，该示例使用<code>read</code>函数从一个文件中读取数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Handle error */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ssize_t</span> bytesRead = read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytesRead == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Handle error */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buffer[bytesRead] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// Null-terminate the string</span></span><br><span class="line">            <span class="comment">/* Now buffer contains the first sizeof(buffer) - 1 bytes of the file. */</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们打开一个名为<code>test.txt</code>的文件，然后尝试从该文件中读取最多127个字节的数据（我们预留一个字节用于字符串的空字符终止符）。然后，我们在读取的数据后添加一个空字符，使其成为一个有效的C字符串。如果读取过程中发生错误，我们需要处理该错误。</p><p>使用<code>read</code>函数时，务必检查其返回值，以确保没有发生错误并且已成功读取到数据。当你读到文件的末尾时，<code>read</code>函数将<strong>返回0，表示没有更多的数据可以读取。</strong></p><h5 id="（2）write"><a href="#（2）write" class="headerlink" title="（2）write"></a>（2）write</h5><p>在Linux或Unix系统中，<code>write</code>是一个系统调用，用于将数据写入到打开的文件描述符。以下是<code>write</code>函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p><code>write</code>函数接收三个参数：</p><ul><li><code>fd</code>：要写入的文件描述符。这通常是一个先前使用<code>open</code>函数打开的文件的文件描述符。</li><li><code>buf</code>：包含要写入的数据的缓冲区。</li><li><code>count</code>：要写入的字节数。</li></ul><p><code>write</code>函数<strong>返回实际写入的字节数</strong>。如果发生错误，它将返回-1，并设置全局变量<code>errno</code>以指示发生了什么错误。</p><p><strong>以下是一个简单的示例</strong>，该示例使用<code>write</code>函数向一个文件中写入数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *text = <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Handle error */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ssize_t</span> bytesWritten = write(fd, text, <span class="built_in">strlen</span>(text));</span><br><span class="line">        <span class="keyword">if</span> (bytesWritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Handle error */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">size_t</span>)bytesWritten &lt; <span class="built_in">strlen</span>(text)) &#123;</span><br><span class="line">            <span class="comment">/*若此时写入的字节数小于text的长度则报错*/</span></span><br><span class="line">            <span class="comment">/* Handle partial write */</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们打开（或创建）一个名为<code>test.txt</code>的文件，然后尝试向该文件中写入一个字符串。如果写入过程中发生错误，我们需要处理该错误。我们还检查了<code>write</code>函数是否已成功写入所有的数据。</p><p>使用<code>write</code>函数时，务必检查其返回值，以确保没有发生错误并且所有数据都已成功写入。在某些情况下（例如，磁盘空间不足），<code>write</code>函数可能只写入部分数据，这时你需要处理这种部分写入的情况。</p><h5 id="（3）lseek"><a href="#（3）lseek" class="headerlink" title="（3）lseek"></a>（3）lseek</h5><p>在Linux或Unix系统中，<code>lseek</code>是一个系统调用，用于改变打开文件的当前读&#x2F;写位置。这个读&#x2F;写位置通常被称为文件的“偏移量”。以下是<code>lseek</code>函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p><code>lseek</code>函数接收三个参数：</p><ul><li><code>fd</code>：要改变偏移量的文件描述符。这通常是一个先前使用<code>open</code>函数打开的文件的文件描述符。</li><li><code>offset</code>：要移动的字节数。这个值可以是负数，表示向后移动。</li><li><code>whence</code>：移动的基点，它可以是以下三个值之一：<code>SEEK_SET</code>（从文件开始处移动），<code>SEEK_CUR</code>（从当前位置移动），<code>SEEK_END</code>（从文件结束处移动）。</li></ul><p><code>lseek</code>函数<strong>返回新的文件偏移量</strong>。如果发生错误，它将返回-1，并设置全局变量<code>errno</code>以指示发生了什么错误。</p><p><strong>以下是一个简单的示例</strong>，该示例使用<code>lseek</code>函数跳过一个文件的前100字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Handle error */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">off_t</span> newOffset = lseek(fd, <span class="number">100</span>, SEEK_SET);</span><br><span class="line">        <span class="keyword">if</span> (newOffset == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Handle error */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Now the next read or write will start 100 bytes into the file. */</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们打开一个名为<code>test.txt</code>的文件，然后使用<code>lseek</code>函数将文件的偏移量设置为100。这意味着下一次<code>read</code>或<code>write</code>操作将从文件的第100字节开始。如果<code>lseek</code>调用失败，我们需要处理该错误。</p><p>使用<code>lseek</code>函数时，务必检查其返回值，以确保操作已成功完成。</p><h6 id="off-t"><a href="#off-t" class="headerlink" title="off_t"></a>off_t</h6><p><code>off_t</code> 是用于表示文件偏移量或者大小的类型。这种类型是符号整型，因此可以表示正数、零和负数。<code>off_t</code> 常常被用于文件I&#x2F;O操作</p><p>根据你的系统和编译器，<code>off_t</code> 可能会有不同的大小。在许多系统中，<code>off_t</code> 是一个 64 位的类型，这样它就可以表示超过 2GB 的文件大小和偏移量。但是在一些旧的或者嵌入式的系统中，<code>off_t</code> 可能只有 32 位</p><h5 id="（4）模拟cp-指令将-src文件-复制到dest文件中"><a href="#（4）模拟cp-指令将-src文件-复制到dest文件中" class="headerlink" title="（4）模拟cp 指令将 src文件 复制到dest文件中"></a>（4）模拟cp 指令将 src文件 复制到dest文件中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp src dest</span><br></pre></td></tr></table></figure><p><code>mycpy2.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定义源文件以及目标文件的文件描述符（整型数字）</span></span><br><span class="line"><span class="type">int</span> sfd,dfd;</span><br><span class="line"><span class="type">char</span> buf[BUFSIZE];</span><br><span class="line"><span class="type">int</span> len,ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行输入的参数数量不够</span></span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;USage ...\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件返回文件描述符</span></span><br><span class="line"><span class="comment">// 源文件(必须先存在)</span></span><br><span class="line">sfd = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (sfd==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 打开失败 perror 函数关联了全局变量errno</span></span><br><span class="line">perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开目标文件，目标文件写入O_WRONLY，不需要一定存在，不存在则创建O_CREAT，而且若存在则需要清空进行重写截断O_TRUNC</span></span><br><span class="line">dfd = open(argv[<span class="number">2</span>],O_WRONLY|O_CREAT|O_TRUNC);</span><br><span class="line"><span class="keyword">if</span>(dfd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 打开失败</span></span><br><span class="line">perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">close(sfd); <span class="comment">// 关闭源文件，防止产生内存泄漏</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 开始读取</span></span><br><span class="line">len=read(sfd,buf,BUFSIZE);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 读取失败</span></span><br><span class="line">perror(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 当你读到文件的末尾时，`read`函数将**返回0，表示没有更多的数据可以读取</span></span><br><span class="line"><span class="comment">// 读完了</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始向目标文件写入数据</span></span><br><span class="line">ret = write(dfd,buf,len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 写入失败</span></span><br><span class="line">perror(<span class="string">&quot;write()&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(sfd);</span><br><span class="line">close(dfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建源文件<code>src.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456789</span></span><br><span class="line">今天又是元气满满的一天呢！</span><br></pre></td></tr></table></figure><p>使用命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./mycpy2 src.txt dest.txt</span><br></pre></td></tr></table></figure><p>打开<code>dest.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456789</span></span><br><span class="line">今天又是元气满满的一天呢！</span><br></pre></td></tr></table></figure><p>成功</p><p><strong>BUG</strong>： 但是实际上，上面的程序存在bug,因为在向目标文件写入数据的时候，假设我们需要写入10个字节，但是实际只写入了3个字节，那么ret返回值&#x3D;&#x3D;3，也是非负值，此时并没有写入全部数据数据，下一次还会继续进行写入，但是第二次写入会将第一次写入的数据进行截断覆盖，因此做以下修正</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定义源文件以及目标文件的文件描述符（整型数字）</span></span><br><span class="line"><span class="type">int</span> sfd,dfd;</span><br><span class="line"><span class="type">char</span> buf[BUFSIZE];</span><br><span class="line"><span class="type">int</span> len,ret,pos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行输入的参数数量不够</span></span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;USage ...\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件返回文件描述符</span></span><br><span class="line"><span class="comment">// 源文件(必须先存在)</span></span><br><span class="line">sfd = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (sfd==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 打开失败 perror 函数关联了全局变量errno</span></span><br><span class="line">perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开目标文件，目标文件写入O_WRONLY，不需要一定存在，不存在则创建O_CREAT，而且若存在则需要清空进行重写截断O_TRUNC</span></span><br><span class="line">dfd = open(argv[<span class="number">2</span>],O_WRONLY|O_CREAT|O_TRUNC);</span><br><span class="line"><span class="keyword">if</span>(dfd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 打开失败</span></span><br><span class="line">perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">close(sfd); <span class="comment">// 关闭源文件，防止产生内存泄漏</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 开始读取</span></span><br><span class="line">len=read(sfd,buf,BUFSIZE);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 读取失败</span></span><br><span class="line">perror(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 当你读到文件的末尾时，`read`函数将**返回0，表示没有更多的数据可以读取</span></span><br><span class="line"><span class="comment">// 读完了</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 开始向目标文件写入数据</span></span><br><span class="line"><span class="comment">// 之后每次写入都从buf数组中的buf+pos位置写入</span></span><br><span class="line">ret = write(dfd,buf+pos,len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 写入失败</span></span><br><span class="line">perror(<span class="string">&quot;write()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 此时会存在内存泄漏</span></span><br><span class="line">&#125;</span><br><span class="line">pos += ret;</span><br><span class="line">len -= ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(sfd);</span><br><span class="line">close(dfd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序成功</p><h3 id="三、标准IO与系统文件IO的区别关系"><a href="#三、标准IO与系统文件IO的区别关系" class="headerlink" title="三、标准IO与系统文件IO的区别关系"></a>三、标准IO与系统文件IO的区别关系</h3><h4 id="1-区别关系"><a href="#1-区别关系" class="headerlink" title="1.区别关系"></a>1.区别关系</h4><p><a href="https://www.bilibili.com/video/BV18p4y167Md/?p=138&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><p>标准IO是依赖系统文件IO实现的</p><p><strong>标准IO</strong>：在 C 语言中，标准 I&#x2F;O 提供了许多函数，如 <code>fopen</code>、<code>fclose</code>、<code>fread</code>、<code>fwrite</code>、<code>printf</code> 和 <code>scanf</code>。这些函数是通过一个 <code>FILE</code> 指针进行操作的，这个指针指向一个包含所有相关状态信息的对象。</p><p>标准 I&#x2F;O 通常处理的三个主要的 I&#x2F;O 流是：</p><ul><li>标准输入（stdin）：通常来自键盘的输入数据流。</li><li>标准输出（stdout）：输出到终端或另一个程序的正常输出数据流。</li><li>标准错误输出（stderr）：输出到终端或另一个程序的错误或诊断消息。</li></ul><p><strong>系统IO</strong>：系统 I&#x2F;O，或称为低级 I&#x2F;O，是一种用于执行输入&#x2F;输出操作的接口。这些操作通常涉及到数据在内存和硬盘或其他I&#x2F;O设备（例如，键盘或鼠标）之间的传输。在许多操作系统中，这些I&#x2F;O操作是通过系统调用实现的。</p><p>以下是一些常见的系统 I&#x2F;O 函数：</p><ul><li><p>**open()**：打开一个文件或设备，以便进行读取或写入操作。成功时，返回一个文件描述符，这是一个非负整数，用于标识操作系统中打开的特定文件或设备。失败时，返回-1。</p></li><li><p>**close()**：关闭一个先前打开的文件或设备。如果成功，返回0。如果失败，返回-1。</p></li><li><p>**read()**：从一个打开的文件或设备读取数据。返回实际读取的字节数，或者在出现错误或达到文件末尾时返回-1。</p></li><li><p>**write()**：向一个打开的文件或设备写入数据。返回实际写入的字节数，或者在出现错误时返回-1。</p></li><li><p>**lseek()**：改变一个打开的文件的当前读&#x2F;写位置。</p></li><li><p>**fstat()<strong>，</strong>stat()**：获取关于文件的信息，例如它的大小，所有者，创建时间等。</p></li></ul><p>以上函数都属于底层I&#x2F;O，直接与操作系统交互，没有经过任何缓冲处理，速度较快，但是使用起来比较复杂。另外，这些函数都是非标准的，因此在不同的操作系统之间可能存在差异。</p><p><strong>标准IO与系统IO的区别</strong></p><ul><li><strong>层级</strong>：系统 I&#x2F;O 是操作系统提供的底层接口，常见的有 open，read，write，close 等系统调用。标准 I&#x2F;O 是建立在系统 I&#x2F;O 之上的库级接口，它是由 C 语言的标准库提供的，例如 fopen, fread, fwrite, fclose 等函数</li><li><strong>缓冲机制</strong>：<strong>标准 I&#x2F;O 提供了缓冲机制，而系统 I&#x2F;O 并不提供</strong>。这意味着，当你使用标准 I&#x2F;O 函数写入数据时，数据可能首先被写入到一个内部缓冲区，然后在适当的时候才会被写入到实际的文件或设备。这可以提高 I&#x2F;O 性能，因为许多小的 I&#x2F;O 操作通常比一次大的 I&#x2F;O 操作更昂贵。缓冲区满或者调用 fflush()函数时才会真正进行系统调用。而系统 I&#x2F;O 每次调用 read 或 write 都直接进行系统调用。<strong>（标准IO的吞吐量大，而系统IO响应速度快）</strong></li><li><strong>跨平台性</strong>：由于标准 I&#x2F;O 是由 C 语言的标准库提供的，它在不同的操作系统上提供了一致的接口，因此具有更好的跨平台性。而系统 I&#x2F;O 则强依赖于特定的操作系统</li><li><strong>文件描述符和 FILE 结构体</strong>：系统 I&#x2F;O 使用的是文件描述符，它是一个非负整数。而标准 I&#x2F;O 则使用的是 FILE 结构体，它是一个包含了缓冲区、状态指示器、文件位置指示器等信息的复杂结构</li><li><strong>错误处理</strong>：系统 I&#x2F;O 通常通过返回 -1 并设置全局变量 errno 来报告错误，而标准 I&#x2F;O 则提供了一些额外的错误检测和报告机制</li><li><strong>功能</strong>：系统 I&#x2F;O 提供的功能更为底层且强大，例如支持异步 I&#x2F;O，scatter&#x2F;gather I&#x2F;O 等。而标准 I&#x2F;O 更注重普通文件读写操作的便利性。</li></ul><h4 id="2-标准IO与系统IO不能混用"><a href="#2-标准IO与系统IO不能混用" class="headerlink" title="2.标准IO与系统IO不能混用"></a>2.标准IO与系统IO不能混用</h4><p>如下程序:</p><p><code>test2.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// putchar 是标准IO</span></span><br><span class="line"><span class="comment">// write 是系统IO</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">write(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">write(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">write(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>make</code>运行输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/UNIX/IO$ ./test2</span><br><span class="line">bbbaaa</span><br></pre></td></tr></table></figure><p>可以看到是先输出的bbb  然后输出的aaa,这个也反映了标准IO的缓冲机制与响应速度，系统IO是没用缓冲机制的</p><h5 id="（1）strance"><a href="#（1）strance" class="headerlink" title="（1）strance"></a>（1）strance</h5><p>在终端中可以使用<code>strance</code>命令查看一个可执行文件的系统调用是如何发生的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strance ./test2</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307230942298.png" alt="image-20230723094225249"></p><p>看到上图,<code>putchar</code>标准IO输出都是依赖底层的系统调用IO <code>write</code>实现，<code>putchar(&#39;a&#39;)</code>先将数据放入了缓冲区</p><p>，然后最后等待缓冲区进行刷新时，将三个<code>aaa</code>全部交给了<code>write</code>写入输出IO中，进行输出，而使用<code>write(1,&quot;b&quot;,1)</code>则没用缓冲机制，直接进行输出</p><h5 id="（2）fileno与fdopen"><a href="#（2）fileno与fdopen" class="headerlink" title="（2）fileno与fdopen"></a>（2）fileno与fdopen</h5><p><code>fileno</code> 和 <code>fdopen</code> 是 C 语言库中的两个用于处理文件 I&#x2F;O 的函数。它们在处理涉及文件描述符和 <code>FILE *</code> 流之间的转换时非常有用</p><ul><li><strong>fileno</strong></li></ul><p>此函数用于获取与给定的 <code>FILE *</code> 流关联的文件描述符。该函数接收一个 <code>FILE *</code> 参数，并返回一个整型的文件描述符。如果出现错误，此函数将返回 -1 并设置 errno 以指示错误的类型。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fd = fileno(fp);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Now you can use fd in functions that require a file descriptor</span></span><br></pre></td></tr></table></figure><ul><li><strong>fdopen</strong></li></ul><p>此函数用于根据已存在的文件描述符创建一个 <code>FILE *</code> 流。此函数接收两个参数：一个文件描述符和一个模式字符串（如 “r”、”w”、”a” 等）。如果成功，此函数将返回一个新的 <code>FILE *</code> 流。如果出现错误，它将返回 NULL 并设置 errno 以指示错误的类型。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br><span class="line">FILE* fp = fdopen(fd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Now you can use fp in functions that require a FILE *</span></span><br></pre></td></tr></table></figure><p>总的来说，这两个函数可以在系统级 I&#x2F;O（文件描述符）和库级 I&#x2F;O（<code>FILE *</code> 流）之间建立桥梁，使得两种 I&#x2F;O 方式能够在一定程度上互换使用</p><h3 id="四、文件共享"><a href="#四、文件共享" class="headerlink" title="四、文件共享"></a>四、文件共享</h3><p><a href="https://www.bilibili.com/video/BV18p4y167Md/?p=139&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><p>多个任务同时操作一个文件或者协同完成任务</p><h4 id="1-删除文件的第10行代码实现"><a href="#1-删除文件的第10行代码实现" class="headerlink" title="1.删除文件的第10行代码实现"></a>1.删除文件的第10行代码实现</h4><p><code>truncate</code> 和 <code>ftruncate</code> 是 UNIX 系统中的两个系统调用，用于调整文件的大小</p><h5 id="（1）truncate"><a href="#（1）truncate" class="headerlink" title="（1）truncate"></a>（1）truncate</h5><p>此函数用于将指定路径的文件大小设置为指定的长度。如果文件原来的大小大于这个长度，那么超出的数据会被丢弃。如果文件原来的大小小于这个长度，那么文件大小会被扩展，并且新增的部分将会被填充为零字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>path</code> 是要调整大小的<strong>文件的路径</strong></li><li><code>length</code> 是要设置的新的文件大小</li></ul><p><strong>return</strong>: 函数成功时返回 0，失败时返回 -1，并设置 <code>errno</code> 表示错误</p><h5 id="（2）ftruncate"><a href="#（2）ftruncate" class="headerlink" title="（2）ftruncate"></a>（2）<strong>ftruncate</strong></h5><p>此函数用于将已打开的文件（由文件描述符指定）的大小设置为指定的长度。它的功能和 <code>truncate</code> 相同，<strong>但是它操作的是通过文件描述符指定的文件</strong>，而不是路径指定的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>fd</code> 是已打开文件的文件描述符</li><li><code>length</code> 是要设置的新的文件大小</li></ul><p><strong>return</strong>: 函数成功时返回 0，失败时返回 -1，并设置 <code>errno</code> 表示错误</p><h5 id="（3）代码实现"><a href="#（3）代码实现" class="headerlink" title="（3）代码实现"></a>（3）代码实现</h5><p><a href="https://gitee.com/raymentkong/linux-c/blob/master/io/sys/sys_delline.c">程序地址</a></p><h3 id="五、原子操作"><a href="#五、原子操作" class="headerlink" title="五、原子操作"></a>五、原子操作</h3><p><strong>原子操作</strong>: 不可以分割的最小单位</p><p>原子操作的作用:解决竞争和冲突</p><p>多进程与多线程并发的时候，可以使用原子操作，需要将操作原子化</p><h3 id="六、程序中的重定向-dup与dup2"><a href="#六、程序中的重定向-dup与dup2" class="headerlink" title="六、程序中的重定向:dup与dup2"></a>六、程序中的重定向:<code>dup</code>与dup2</h3><p><a href="https://www.bilibili.com/video/BV18p4y167Md/?p=140&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><p> 示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;！hello&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端运行输出:</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307241931316.png" alt="image-20230724193116286"></p><p>我们可以知道<code>puts</code>的输出为标准输出即对应于预定义的文件描述符<code>1</code>，但是我们如何操作可以使得，<code>puts</code>输出不在标准输出中(显示在终端上)，重定向其输出位置</p><p>之前我们知道,通常情况下，在文件描述符中，每个 Unix 或类 Unix 进程都会有三个预定义的文件描述符：<strong>标准输入（0）、标准输出（1）、和标准错误输出（2）</strong></p><p><strong>方法一</strong>:</p><p>我们可以将标准输出的文件描述符 关闭<code>close(1)</code>,而<strong>文件描述符是优先使用可用范围内最小的内容</strong>，若此时重新<code>open</code>一个文件，并且返回其文件描述符，那么这个文件描述符就是1，我们再使用<code>puts</code>函数进行输出仍然是输出至文件描述符<code>1</code>所对应的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILENAME <span class="string">&quot;/tmp/out.txt&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">fd = open(FILENAME,O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0600</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;！hello&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gedit /tmp/out</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307241950742.png" alt="image-20230724195036719"></p><h4 id="1-dup"><a href="#1-dup" class="headerlink" title="1.dup"></a>1.dup</h4><p><code>dup</code> 函数接受一个打开的文件描述符 <code>oldfd</code> 作为参数，并返回一个新的文件描述符。新的文件描述符将会是当前可用的最小的整数值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br></pre></td></tr></table></figure><h4 id="2-dup2"><a href="#2-dup2" class="headerlink" title="2.dup2"></a>2.dup2</h4><p><code>dup2</code> 函数接受两个参数 <code>oldfd</code> 和 <code>newfd</code>。它会先关闭 <code>newfd</code>（如果 <code>newfd</code> 已经打开的话），然后将 <code>oldfd</code> 的复制赋值给 <code>newfd</code>。如果 <code>oldfd</code> 和 <code>newfd</code> 相同，那么 <code>dup2</code> 什么也不做并返回 <code>newfd</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p>这两个函数都会设置新的文件描述符的文件状态标志（例如非阻塞标志等）为 <code>oldfd</code> 相同的值，并且新的文件描述符和 <code>oldfd</code> 将会共享同一个文件偏移量和同一个打开文件（也就是说，如果通过其中一个文件描述符进行了写操作，那么在另一个文件描述符看来文件的内容和偏移量都会改变）。</p><p>如果成功，它们都会返回新的文件描述符。如果出错，它们都会返回 -1 并设置 <code>errno</code> 为相应的错误号。</p><h3 id="七、fcntl与iocntl"><a href="#七、fcntl与iocntl" class="headerlink" title="七、fcntl与iocntl"></a>七、fcntl与iocntl</h3><p><code>/dev/fd/</code>目录: 虚目录 显示的是当前进程的文件描述符信息</p><h4 id="1-fcntl"><a href="#1-fcntl" class="headerlink" title="1.fcntl"></a>1.fcntl</h4><p><code>fcntl</code> 是 Unix&#x2F;Linux 系统调用，它的名字来源于 “file control”，用于对文件描述符进行各种操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><p>这个函数接受一个文件描述符 <code>fd</code>，一个命令 <code>cmd</code>，以及可能需要的额外参数（这取决于 <code>cmd</code> 的值）。它的返回值取决于 <code>cmd</code> 的值，如果出错，它会返回 -1 并设置 <code>errno</code></p><p><code>fcntl</code> 支持很多命令，下面是一些最常用的：</p><ul><li><code>F_DUPFD</code>：复制一个文件描述符，和 <code>dup</code> 功能类似，但你可以指定新的文件描述符的最小值。</li><li><code>F_GETFD</code> 和 <code>F_SETFD</code>：获取和设置文件描述符标志，如 close-on-exec。</li><li><code>F_GETFL</code> 和 <code>F_SETFL</code>：获取和设置文件状态标志，如阻塞和非阻塞I&#x2F;O，append模式等。</li><li><code>F_GETLK</code>, <code>F_SETLK</code> 和 <code>F_SETLKW</code>：检查，设置或释放文件锁。</li></ul><p>注意，<code>fcntl</code> 对于非文件类型的文件描述符（例如，sockets 和 pipes）可能会有不同的行为，或者可能不支持所有的命令。</p><p>这是一个简单的使用 <code>fcntl</code> 进行非阻塞I&#x2F;O设置的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> flags = fcntl(STDIN_FILENO, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl F_GETFL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(STDIN_FILENO, F_SETFL, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl F_SETFL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now reads from stdin will not block.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-iocntl"><a href="#2-iocntl" class="headerlink" title="2.iocntl"></a>2.iocntl</h4><p><code>ioctl</code> 是 Unix&#x2F;Linux 系统调用，用于设备特定的输入&#x2F;输出操作。它的名字是 “input&#x2F;output control” 的缩写。<code>ioctl</code> 函数提供了一种通用的方式来做一些不能用常规的系统调用做的事情，特别是和设备驱动程序交互的事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure><p>这个函数接受一个文件描述符 <code>fd</code>，一个请求码 <code>request</code>，和零个或多个额外的参数。额外参数的数量和类型取决于 <code>request</code> 的值。<code>ioctl</code> 的返回值通常取决于 <code>request</code>，如果出错，它会返回 -1 并设置 <code>errno</code>。</p><p><code>ioctl</code> 的请求码和额外参数完全取决于特定的设备驱动程序。例如，终端设备（如你的 shell）提供了很多 <code>ioctl</code> 操作来获取和设置各种终端属性。这是一个简单的例子，它使用 <code>ioctl</code> 来获取终端的窗口大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">ws</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(STDOUT_FILENO, TIOCGWINSZ, &amp;ws) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ioctl TIOCGWINSZ&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;window size: %d rows, %d columns\n&quot;</span>, ws.ws_row, ws.ws_col);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>ioctl</code> 函数和 <code>fcntl</code> 函数都可以对文件描述符进行控制，但是 <code>ioctl</code> 更为特定于设备，通常用于处理设备驱动程序提供的更复杂的情况。而 <code>fcntl</code> 主要用于处理文件I&#x2F;O的通用属性，如文件锁，读写模式等</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境编程-标准IO （7）</title>
      <link href="/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%A0%87%E5%87%86IO%EF%BC%887%EF%BC%89/"/>
      <url>/2023/08/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-%E6%A0%87%E5%87%86IO%EF%BC%887%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="UNIX环境编程-标准IO-（7）"><a href="#UNIX环境编程-标准IO-（7）" class="headerlink" title="UNIX环境编程-标准IO （7）"></a>UNIX环境编程-标准IO （7）</h2><p>IO：input &amp; output 一切实现的基础</p><p>IO分类：</p><ul><li>stdio(标准IO)–<strong>优先使用</strong> 对于不同的系统均可以使用</li><li>sysio系统调用IO(文件IO)</li></ul><p>标准IO优点：</p><ul><li>移植性性好、合并系统调用（可以为读写做一个加速的机制）</li><li>在不同的系统下，标准IO所依赖的系统调用的函数不同</li></ul><h3 id="一、fopen"><a href="#一、fopen" class="headerlink" title="一、fopen()"></a>一、fopen()</h3><h4 id="1-fprintf"><a href="#1-fprintf" class="headerlink" title="1.fprintf"></a>1.fprintf</h4><p><code>fprintf</code> 是 C 语言标准库中的一个函数，用于将格式化的数据输出到文件。它是 <code>printf</code> 函数的文件版本，<code>printf</code> 输出到标准输出，而 <code>fprintf</code> 可以输出到任意文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ... )</span>;</span><br><span class="line"><span class="comment">// fprintf()函数根据指定的format(格式)发送信息(参数)到由stream(流)指定的文件.因此fprintf()可以使得信息输出到指定的文件</span></span><br><span class="line"><span class="comment">// 如下:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    char name[20] = &quot;Mary&quot;;</span></span><br><span class="line"><span class="comment">    FILE *out;</span></span><br><span class="line"><span class="comment">    out = fopen( &quot;output.txt&quot;, &quot;w&quot; );</span></span><br><span class="line"><span class="comment">    if( out != NULL )</span></span><br><span class="line"><span class="comment">    fprintf( out, &quot;Hello %s\n&quot;, name );</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>参数的意义如下：</p><ul><li><code>stream</code>：这是一个指向 <code>FILE</code> 类型的指针，代表要写入的文件。可以是任何已打开的文件，包括 <code>stdout</code>。</li><li><code>format</code>：这是一个格式字符串，它定义了输出的格式。格式字符串可以包含普通字符和格式说明符。</li><li><code>...</code>：这是可变参数列表，它们的类型和数量由 <code>format</code> 字符串中的格式说明符决定。</li></ul><p>函数返回写入的字符数，或者在出错时返回一个负数。</p><p><strong>关于刷新缓冲区</strong>，C 语言标准库提供了 <code>fflush</code> 函数来刷新一个文件的缓冲区。如果你想立即将 <code>fprintf</code> 的输出发送到文件，<strong>而不等待缓冲区满或文件关闭，你可以使用 <code>fflush</code> 函数</strong>。</p><p><code>fflush</code> 函数的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fflush(FILE *stream);</span><br></pre></td></tr></table></figure><p><code>stream</code> 是你想刷新的文件的 <code>FILE</code> 指针。函数成功时返回0，出错时返回EOF。</p><p>示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    fflush(fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子首先打开一个文件用于写入，然后使用 <code>fprintf</code> 将一行文字写入文件，接着使用 <code>fflush</code> 将输出立即写入文件，最后关闭文件</p><p>在ubuntu终端可以使用<code>man fopen</code>查看<code>fopen()</code>函数相关信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>; <span class="comment">// FILE是一个文件类型的结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mode:</span></span><br><span class="line"><span class="comment">// r : Open text file for reading.  The stream is positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment">// r+: Open  for  reading and writing.  The stream is positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment">// w : Truncate file to zero length or create text  file  for  writing(文件存在则清空，文件不存在则创建,只是写入).The stream is positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment">// w+: Open  for  reading  and writing.  The file is created if it does not exist（相较w包含读写操作）, otherwise it is truncated.  The stream is  positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment">// a : Open  for  appending (writing at end of file)(在文件内容末尾进行内容追加).  The file is created if it does not exist.The stream is positioned at the  end of the file.</span></span><br><span class="line"><span class="comment">// a+: Open  for  reading  and appending (writing at end of file)(读写) The file is created if it does not exist.  Output is always appended to  the  end  of  the file.  POSIX is silent on what the initial read position is when using this mode.  For glibc,  the  initial file  position  for reading is at the beginning of the file, but for Android/BSD/MacOS, the initial file position for reading  is at the end of the file.</span></span><br></pre></td></tr></table></figure><p><code>Return</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upon  successful  completion  <span class="title function_">fopen</span><span class="params">()</span>,  <span class="title function_">fdopen</span><span class="params">()</span> and <span class="title function_">freopen</span><span class="params">()</span> <span class="keyword">return</span> a FILE pointer.  Otherwise, <span class="literal">NULL</span> is returned and errno is <span class="built_in">set</span> to indicate the error. </span><br><span class="line"><span class="comment">// 也会得到一个对应的errno </span></span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前并为创建 tem.txt文件</span></span><br><span class="line">fp = fopen(<span class="string">&quot;./tem.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fopen() failed! errno = %d\n&quot;</span>,errno);</span><br><span class="line"><span class="comment">// 异常退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;OK!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可执行文件输出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fopen() failed! errno = <span class="number">2</span></span><br><span class="line"><span class="comment">// errno 可以进入 该目录查看 vim /usr/include/asm-generic/errno-base.h </span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307161950174.png" alt="image-20230716195033135"></p><p>这样不太方便，因为对于报错的errno有很多，如果这样进行使用，后续还需要进入该目录下，查看该errno所对应的报错信息是什么</p><h4 id="2-perror"><a href="#2-perror" class="headerlink" title="2.perror"></a>2.perror</h4><p>这个函数可以对errno报错的信息进行自动关联（自动关联全局变量errno）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       perror - print a system error message</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前并为创建 tem.txt文件</span></span><br><span class="line">fp = fopen(<span class="string">&quot;./tem.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;fopen() failed! errno = %d\n&quot;,errno);</span></span><br><span class="line">perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line"><span class="comment">// 异常退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;OK!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可执行文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash: ./fopen: 没有那个文件或目录</span><br></pre></td></tr></table></figure><h4 id="3-strerror"><a href="#3-strerror" class="headerlink" title="3.strerror"></a>3.strerror</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       strerror, strerror_r, strerror_l - <span class="keyword">return</span> <span class="built_in">string</span> describing error number</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 需要的参数是一个errno</span></span><br><span class="line">       <span class="type">char</span> *strerror(<span class="type">int</span> errnum);</span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前并为创建 tem.txt文件</span></span><br><span class="line">fp = fopen(<span class="string">&quot;./tem.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fp ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;fopen() failed! errno = %d\n&quot;,errno);</span></span><br><span class="line"><span class="comment">// perror(&quot;fopen()&quot;); </span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fopen(): %s\n&quot;</span>,strerror(errno));</span><br><span class="line"><span class="comment">// 异常退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;OK!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可执行文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash: ./fopen: 没有那个文件或目录</span><br></pre></td></tr></table></figure><h4 id="4-fopen相关问题"><a href="#4-fopen相关问题" class="headerlink" title="4.fopen相关问题"></a>4.fopen相关问题</h4><h5 id="（1）fopen返回的FILE类型指针指向的是哪一个空间"><a href="#（1）fopen返回的FILE类型指针指向的是哪一个空间" class="headerlink" title="（1）fopen返回的FILE类型指针指向的是哪一个空间"></a>（1）fopen返回的FILE类型指针指向的是哪一个空间</h5><p>栈  or 静态区 or 堆  答案： 堆上</p><ul><li><p>栈是局部变量存放的空间，不对 fopen返回的内容需要在整个程序（进程）运行期间均存在，所以不在栈上</p></li><li><p>静态区 用static修饰该FILE变量.如下,但是需要注意的是，如果fopen函数被重复调用的时候，这个<code>static FILE tmp;</code>只会被声明一次，则如果多次调用<code>fopen</code>函数那么之前所返回的FILE指针则会被覆盖，不能用，有效的则是最后调用的那个<code>fopen</code>函数</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> FILE tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>堆上，如下，需要对所使用的内存空间进行动态开辟<code>malloc</code>,那么<code>fcolse</code>函数则是对这块动态开辟的空间进行释放</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *tmp = <span class="literal">NULL</span> ;</span><br><span class="line">    </span><br><span class="line">    tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FILE));</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、字符输入与输出"><a href="#二、字符输入与输出" class="headerlink" title="二、字符输入与输出"></a>二、字符输入与输出</h3><p><a href="https://www.runoob.com/cprogramming/c-standard-library-stdio-h.html">菜鸟教程</a></p><h4 id="1-模拟cp-指令将-src文件-复制到dest文件中"><a href="#1-模拟cp-指令将-src文件-复制到dest文件中" class="headerlink" title="1.模拟cp 指令将 src文件 复制到dest文件中"></a>1.模拟cp 指令将 src文件 复制到dest文件中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp src dest</span><br></pre></td></tr></table></figure><h5 id="（1）fgetc"><a href="#（1）fgetc" class="headerlink" title="（1）fgetc"></a>（1）fgetc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fgetc（）从流中读取下一个字符，并将其作为一个无符号字符返回，该字符转换为int，或文件末尾的EOF或error</span></span><br><span class="line"><span class="comment">从文件流中读取数据 ,并且返回</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="（2）fputc"><a href="#（2）fputc" class="headerlink" title="（2）fputc"></a>（2）fputc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C 库函数 int fputc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流stream 中，并把位置标识符往前移动</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="（3）实现代码"><a href="#（3）实现代码" class="headerlink" title="（3）实现代码"></a>（3）实现代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fps,*fpd;</span><br><span class="line"><span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择模式为 r表示源文件一定要存在 ，否则报错</span></span><br><span class="line">fps = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fps == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标文件</span></span><br><span class="line">fpd = fopen(argv[<span class="number">2</span>],<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fpd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 从fps中读取数据</span></span><br><span class="line">ch = fgetc(fps);</span><br><span class="line"><span class="keyword">if</span>(ch == EOF) <span class="comment">// 读到文件末尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将原文件中读取的数据写入目标文件</span></span><br><span class="line">fputc(ch,fpd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(fpd);</span><br><span class="line">fclose(fps);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个<code>txt</code>文件分别文<code>src.txt</code>以及<code>dest.txt</code>,在<code>src.txt</code>下写入<code>123456</code>,<code>dest.txt</code>为空白</p><p>运行可执行文件<code>先在终端输入 (make mycpy)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mycpy src.txt dest.txt</span><br></pre></td></tr></table></figure><p>使用终端命令比较两个文件是否相同(Enter之后无任何输出表示两个文件是相同的)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diff src.txt dest.txt</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171019147.png" alt="image-20230717101947123"></p><h4 id="2-测试文件中存在有效字符数量"><a href="#2-测试文件中存在有效字符数量" class="headerlink" title="2.测试文件中存在有效字符数量"></a>2.测试文件中存在有效字符数量</h4><p>实现代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="comment">// 用于字符个数计数</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行参数数量出错</span></span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage ...\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fp = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件打开失败</span></span><br><span class="line"><span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环在fp文件中读取字符，直到文件的终止符</span></span><br><span class="line"><span class="keyword">while</span>(fgetc(fp) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count = %d \n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可执行文件</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171041612.png" alt="image-20230717104133589"></p><h4 id="3-字符串相关"><a href="#3-字符串相关" class="headerlink" title="3.字符串相关"></a>3.字符串相关</h4><h5 id="（1）fgets"><a href="#（1）fgets" class="headerlink" title="（1）fgets"></a>（1）fgets</h5><p>C 库函数 <strong>char *fgets(char *str, int n, FILE *stream)</strong> 从指定的流 stream 读取一行，并把它存储在 <strong>str</strong> 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span> ;</span><br></pre></td></tr></table></figure><ul><li><strong>str</strong> – 这是指向一个字符数组的指针，该数组存储了要读取的字符串</li><li><strong>n</strong> – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度</li><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流</li></ul><p>return</p><ul><li>该函数返回一个非负值，如果发生错误则返回 EOF</li></ul><h5 id="（2）fputs"><a href="#（2）fputs" class="headerlink" title="（2）fputs"></a>（2）fputs</h5><p>C 库函数 <strong>int fputs(const char *str, FILE *stream)</strong> 把字符串写入到指定的流 stream 中，但不包括空字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span></span><br></pre></td></tr></table></figure><ul><li><strong>str</strong> – 这是一个数组，包含了要写入的以空字符终止的字符序列</li><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流</li></ul><p>return</p><ul><li>该函数返回一个非负值，如果发生错误则返回 EOF</li></ul><h4 id="4-fread-和-fwrite"><a href="#4-fread-和-fwrite" class="headerlink" title="4.fread 和 fwrite"></a>4.fread 和 fwrite</h4><h5 id="（1）fread"><a href="#（1）fread" class="headerlink" title="（1）fread"></a>（1）fread</h5><p>注意:fread只能操作工整的数据</p><p>C 库函数 <strong>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure><ul><li><strong>ptr</strong> – 这是指向带有最小尺寸 <em>size*nmemb</em> 字节的内存块的指针</li><li><strong>size</strong> – 这是要读取的每个元素(<strong>这个元素可以是结构体等</strong>)的大小，以字节为单位</li><li><strong>nmemb</strong> – 这是元素的个数，每个元素的大小为 size 字节</li><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流</li></ul><p>return</p><ul><li>成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾<strong>（返回值则会小于等于0）</strong></li></ul><p><strong>使用事项:</strong></p><p>一般都是一个字节一个字节的读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fread(buf,<span class="number">1</span>,BUFSIZE,fps);</span><br><span class="line"><span class="comment">// BUFSIZE 为buf的字节数量，即大小</span></span><br></pre></td></tr></table></figure><h5 id="（2）fwrite"><a href="#（2）fwrite" class="headerlink" title="（2）fwrite"></a>（2）fwrite</h5><p>C 库函数 <strong>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure><ul><li><strong>ptr</strong> – 这是指向要被写入的元素数组的指针。</li><li><strong>size</strong> – 这是要被写入的每个元素的大小，以字节为单位。</li><li><strong>nmemb</strong> – 这是元素的个数，每个元素的大小为 size 字节。</li><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</li></ul><p>return</p><ul><li>如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误</li></ul><h4 id="5-printf与scanf函数族"><a href="#5-printf与scanf函数族" class="headerlink" title="5.printf与scanf函数族"></a>5.printf与scanf函数族</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171505832.png" alt="image-20230717150540800"></p><h5 id="（1）sprintf"><a href="#（1）sprintf" class="headerlink" title="（1）sprintf"></a>（1）sprintf</h5><p>C 库函数 <strong>int sprintf(char *str, const char *format, …)</strong> 发送格式化输出到 <strong>str</strong> 所指向的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>str</strong> – 这是指向一个字符数组的指针，该数组存储了 C 字符串。</li><li><strong>format</strong> – 这是字符串，包含了要被#写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</li></ul><h5 id="（2）snprintf"><a href="#（2）snprintf" class="headerlink" title="（2）snprintf"></a>（2）snprintf</h5><p>snprintf() 是一个 C 语言标准库函数，用于格式化输出字符串，并将结果写入到指定的缓冲区，与 sprintf() 不同的是，snprintf() 会限制输出的字符数，避免缓冲区溢出</p><p>C 库函数 <strong>int snprintf(char *str, size_t size, const char *format, …)</strong> 设将可变参数**(…)<strong>按照 <strong>format</strong> 格式化成字符串，并将字符串复制到 <strong>str</strong> 中，</strong>size** 为要写入的字符的最大数目，超过 <strong>size</strong> 会被截断，最多写入 size-1 个字符</p><p>与 <a href="https://www.runoob.com/cprogramming/c-function-sprintf.html">sprintf()</a> 函数不同的是，snprintf() 函数提供了一个参数 size，可以防止缓冲区溢出。如果格式化后的字符串长度超过了 size-1，则 snprintf() 只会写入 size-1 个字符，并在字符串的末尾添加一个空字符（\0）以表示字符串的结束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span> <span class="params">( <span class="type">char</span> * str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> * format, ... )</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>str</strong> – 目标字符串，用于存储格式化后的字符串的字符数组的指针</li><li><strong>size</strong> – 字符数组的大小</li><li><strong>format</strong> – 格式化字符串</li><li><strong>…</strong> – 可变参数，可变数量的参数根据 format 中的格式化指令进行格式化</li></ul><p>return </p><ul><li><p>snprintf() 函数的返回值是输出到 str 缓冲区中的字符数，不包括字符串结尾的空字符 \0。如果 snprintf() 输出的字符数超过了 size 参数指定的缓冲区大小，则输出的结果会被截断，只有 size - 1 个字符被写入缓冲区，最后一个字符为字符串结尾的空字符 \0</p></li><li><p>需要注意的是，snprintf() 函数返回的字符数并不包括字符串结尾的空字符 \0，因此如果需要将输出结果作为一个字符串使用，则需要在缓冲区的末尾添加一个空字符 \0</p></li></ul><h5 id="（3）fscanf"><a href="#（3）fscanf" class="headerlink" title="（3）fscanf"></a>（3）fscanf</h5><p>C 库函数 <strong>int fscanf(FILE *stream, const char *format, …)</strong> 从流 stream 读取格式化输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流</li><li><strong>format</strong> – 这是 C 字符串，包含了以下各项中的一个或多个：<em>空格字符、非空格字符</em> 和 <em>format 说明符</em></li></ul><h5 id="（4）sscanf"><a href="#（4）sscanf" class="headerlink" title="（4）sscanf"></a>（4）sscanf</h5><p>C 库函数 <strong>int sscanf(const char *str, const char *format, …)</strong> 从字符串读取格式化输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure><ul><li><strong>str</strong> – 这是 C 字符串，是函数检索数据的源</li><li><strong>format</strong> – 这是 C 字符串，包含了以下各项中的一个或多个：<em>空格字符、非空格字符</em> 和 <em>format 说明符</em></li></ul><h4 id="6-文件位置函数和缓冲区刷新函数"><a href="#6-文件位置函数和缓冲区刷新函数" class="headerlink" title="6.文件位置函数和缓冲区刷新函数"></a>6.文件位置函数和缓冲区刷新函数</h4><p>在读取与写入的时候，存在文件位置指针</p><h5 id="（1）fseek"><a href="#（1）fseek" class="headerlink" title="（1）fseek"></a>（1）fseek</h5><p>C 库函数 <strong>int fseek(FILE *stream, long int offset, int whence)</strong> 设置流 <strong>stream</strong> 的文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span></span><br></pre></td></tr></table></figure><ul><li>s<strong>tream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流</li><li><strong>offset</strong> – 这是相对 whence 的偏移量，以字节为单位</li><li><strong>whence</strong> – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一:</li></ul><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171555856.png" alt="image-20230717155519825"></p><p>return </p><ul><li>如果成功，则该函数返回零，否则返回非零值</li></ul><h5 id="（2）ftell"><a href="#（2）ftell" class="headerlink" title="（2）ftell"></a>（2）ftell</h5><p>C 库函数 <strong>long int ftell(FILE *stream)</strong> 返回给定流 stream 的当前文件位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span></span><br></pre></td></tr></table></figure><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流</li></ul><p>return </p><ul><li>该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值</li></ul><p><strong>使用实例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 判断命令行传递参数数量</span></span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Usage ...\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line">fp = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件位置指针值于文件末尾处</span></span><br><span class="line">fseek(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,ftell(fp));</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建src.txt文件其中内容:<code>123456\0</code> 表示七个字节</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171606742.png" alt="image-20230717160628708"></p><p>运行可执行文件</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171607897.png" alt="image-20230717160711855"></p><h5 id="（3）rewind"><a href="#（3）rewind" class="headerlink" title="（3）rewind"></a>（3）rewind</h5><p><strong>使用这个函数可以直接让文件位置指针达到文件内容的开头</strong></p><p>C 库函数 <strong>void rewind(FILE *stream)</strong> 设置文件位置为给定流 <strong>stream</strong> 的文件的开头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span></span><br></pre></td></tr></table></figure><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流</li></ul><h5 id="（4）fflush"><a href="#（4）fflush" class="headerlink" title="（4）fflush"></a>（4）fflush</h5><p>C 库函数 <strong>int fflush(FILE *stream)</strong> 刷新流 stream 的输出缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span></span><br></pre></td></tr></table></figure><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流</li></ul><p>return </p><p>如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）</p><p><strong>测试代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Before while(1)..&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After while(1)..&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述代码进行make,然后运行可执行文件，发现终端无输出</p><p><strong>原因</strong>: printf函数向标准终端进行输出时，是典型的行缓冲,是碰到换行符号或者一行满的时候以此来刷新缓冲区</p><p><strong>修正</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Before while(1)..\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After while(1)..\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码make之后运行会输出:<code>Before while(1)..</code></p><p><strong>使用fflush</strong>,强制刷新缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Before while(1)..&quot;</span>);</span><br><span class="line"><span class="comment">// 将输出缓冲区进行刷新</span></span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After while(1)..&quot;</span>);</span><br><span class="line"><span class="comment">// 将会刷新所有打开的流</span></span><br><span class="line">fflush(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>make之后终端运行</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307171629228.png" alt="image-20230717162950203"></p><h5 id="（5）缓冲区存在的作用"><a href="#（5）缓冲区存在的作用" class="headerlink" title="（5）缓冲区存在的作用"></a>（5）缓冲区存在的作用</h5><p><strong>优点</strong></p><ul><li>行缓冲：换行的时候刷新,满了的时候刷新，强制刷新（标准输出就是这样，因为是终端设备）</li><li>全缓冲：满了的时候刷新，强制刷新（默认是，只要不是终端设备）</li><li>无缓冲：如stderr,需要立即输出的内容</li></ul><p>一个文件的缓冲模式默认为全缓冲模式，但是缓冲模式是可以进行修改的</p><h4 id="7-getline"><a href="#7-getline" class="headerlink" title="7.getline"></a>7.getline</h4><p>完整的获取文件一行的内容</p><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=133&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a><br>完整的获取文件一行的内容</p><p><a href="https://www.bilibili.com/video/BV18p4y167Md?p=133&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频教程</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> GNU_SOURCE</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">getline</span><span class="params">(<span class="type">char</span> **lineptr, <span class="type">size_t</span> *n, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>lineptr</code>：指向一个字符指针的指针，用于存储读取到的行。如果 <code>*lineptr</code> 是 NULL 或 <code>n</code> 是零，函数将为您分配一个新的缓冲区。当您完成使用后，需要使用 <code>free</code> 函数来释放这块内存</li><li><code>n</code>：是指向已分配的内存大小的指针。它可能会被函数修改，表示新分配的大小</li><li><code>stream</code>：是一个文件指针，指示从哪里读取数据，例如 <code>stdin</code></li></ul><p>返回值：</p><ul><li>成功：返回读取的字符数量（不包括结尾的 null 字符）。</li><li>错误或读到文件结束：返回 <code>-1</code>。</li></ul><p>在编译程序时需要在CMakeLists.txt中添加该函数所需要的宏定义<code>_D_GNU_SOURCE</code></p><h5 id="（1）程序实例"><a href="#（1）程序实例" class="headerlink" title="（1）程序实例"></a>（1）程序实例</h5><p>读取文件内容</p><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        FILE *fp;</span><br><span class="line">        <span class="type">char</span> *linebuf;</span><br><span class="line">        <span class="type">size_t</span> linesize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;USage..\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fp = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*getline函数至关重要的初始化*/</span></span><br><span class="line">        linebuf = <span class="literal">NULL</span>;</span><br><span class="line">        linesize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(getline(&amp;linebuf,&amp;linesize,fp) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前行的字符数打印</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,<span class="built_in">strlen</span>(linebuf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,linesize);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用getline函数其参数的初始化是至关重要的，如果没有做好，会出现初始化</p><p>CMakeLists.txt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.16</span>)</span><br><span class="line">project(getline_test)    # 工程名字可以与可执行程序名不一样</span><br><span class="line">add_executable(main main.c)</span><br><span class="line">target_compile_definitions(main PRIVATE -D_GNU_SOURCE)</span><br></pre></td></tr></table></figure><p>创建src.txt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhouxuezhi</span><br><span class="line">comeno</span><br><span class="line">wanglei</span><br><span class="line">comeno</span><br></pre></td></tr></table></figure><p>CMake之后运行程序,查看结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p>需要注意的是，getline内部实际使用的malloc开辟动态的内存空间存储，读取到的内容（<code>linebuf</code>），并且当一行内容超过120字节时，则会使用realloc，在之前的malloc开辟的空间基础上继续增加120个字节的内容（类推）</p><p><strong>内存泄漏</strong>，getline存在可控的内存泄漏，因为函数内部使用malloc开辟动态内存空间，但是最后并没有使用free函数将开辟的内存空间自动释放</p><h5 id="（2）mygetline函数实现"><a href="#（2）mygetline函数实现" class="headerlink" title="（2）mygetline函数实现"></a>（2）mygetline函数实现</h5><p><a href="https://blog.csdn.net/lvlvituotuo/article/details/52832975">原文链接</a></p><p>返回类型ssize_t为有符号整形,其值为获取的字符数，文件结束则返回-1，包括换行符’\n’，但不包括字符串结束符’\0’。linepter用来存储获得的字符串，size_t为无符号整形表示linepter的字节数。当*linepter为空时函数则动态为其分配空间，注意要将size_t值赋0。当linepter的空间不足时，函数会通过realloc，重新分配更大的空间。stream为文件指针，用于读取文件<br>mygetline.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYGETLINE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYGETLINE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mygetline</span><span class="params">(<span class="type">char</span>** line,<span class="type">size_t</span> *n,FILE *fp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mygetline_free</span><span class="params">(<span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>mygetline.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mygetline.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mygetline</span><span class="params">(<span class="type">char</span>** line,<span class="type">size_t</span> *n,FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> *buf = *line;</span><br><span class="line">        <span class="comment">// i to record string length, c to store characters</span></span><br><span class="line">        <span class="type">ssize_t</span> c,i=<span class="number">0</span>,init_bufsize=<span class="number">120</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Opening up memory space</span></span><br><span class="line">        <span class="keyword">if</span>(buf == <span class="literal">NULL</span> || *n = <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                *line = <span class="built_in">malloc</span>(<span class="number">120</span>);</span><br><span class="line">                buf = *line;</span><br><span class="line">                *n = <span class="number">120</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read data</span></span><br><span class="line">        <span class="keyword">while</span>((c=getc(fp))!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Read to the end of the file</span></span><br><span class="line">                <span class="keyword">if</span>(c==EOF)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Two spaces need to be left for characters &#x27;\n&#x27; and &#x27;\0&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;(*n)<span class="number">-2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        *buf+i = c;</span><br><span class="line">                        i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// The number of bytes in a row exceeds 120</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        *n = *n + init_bufsize;</span><br><span class="line">                        <span class="comment">// Insufficient initial allocated space, reallocating memory space with 120 bytes added each time</span></span><br><span class="line">                        buf = <span class="built_in">realloc</span>(buf,*n)</span><br><span class="line">                        *buf+i = c;</span><br><span class="line">                        i++;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Fill in the characters &#x27;\0&#x27; and &#x27;\n&#x27; of the line in buf</span></span><br><span class="line">        *(buf+i++) = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        *(buf+i++) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mygetline_free</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mygetline.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        FILE *fp;</span><br><span class="line">        <span class="type">char</span> *linebuf;</span><br><span class="line">        <span class="type">size_t</span> linesize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;USage..\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fp = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*getline函数至关重要的初始化*/</span></span><br><span class="line">        linebuf = <span class="literal">NULL</span>;</span><br><span class="line">        linesize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(mygetline(&amp;linebuf,&amp;linesize,fp) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前行的字符数打印</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,<span class="built_in">strlen</span>(linebuf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,linesize);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        mygetline_free(linebuf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工程目录结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@ubuntu:~/Proj/C_C++/linux_c/sys/getline_test$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── mygetline.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">├── src</span><br><span class="line">│   └── mygetline.c</span><br><span class="line">└── src.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.16</span>)</span><br><span class="line">project(getline_test)</span><br><span class="line"># Output General Information</span><br><span class="line"><span class="title function_">message</span><span class="params">(<span class="string">&quot;PROJECT_SOURCE_DIR = $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span></span><br><span class="line"><span class="title function_">message</span><span class="params">(<span class="string">&quot;CMAKE_CURRENT_SOURCE_DIR = $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span></span><br><span class="line"># Define the output path <span class="keyword">for</span> executable files</span><br><span class="line"><span class="title function_">set</span><span class="params">(HOME $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span></span><br><span class="line"># Include header files</span><br><span class="line"><span class="title function_">include_directories</span><span class="params">($&#123;PROJECT_SOURCE_DIR&#125;/include)</span></span><br><span class="line"><span class="meta"># search for file</span></span><br><span class="line"><span class="title function_">file</span><span class="params">(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src<span class="comment">/*.c)</span></span></span><br><span class="line"><span class="comment"><span class="params"># Set the generation path for static libraries</span></span></span><br><span class="line"><span class="comment"><span class="params">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span></span></span><br><span class="line"><span class="comment"><span class="params"># Specify the output path of the executable file</span></span></span><br><span class="line"><span class="comment"><span class="params">set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;)</span></span></span><br><span class="line"><span class="comment"><span class="params"># Create a static library</span></span></span><br><span class="line"><span class="comment"><span class="params">add_library(calc STATIC $&#123;SRC_LIST&#125;)</span></span></span><br><span class="line"><span class="comment"><span class="params"># Generating Target Files</span></span></span><br><span class="line"><span class="comment"><span class="params">add_executable(main main.c)</span></span></span><br><span class="line"><span class="comment"><span class="params"># link static library</span></span></span><br><span class="line"><span class="comment"><span class="params">target_link_libraries(main calc)</span></span></span><br><span class="line"><span class="comment"><span class="params">target_compile_definitions(main PRIVATE -D_GNU_SOURCE)</span></span></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@ubuntu:~/Proj/C_C++/linux_c/sys/getline_test/bin$ ./main ../src.txt </span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p>运行结果与getline函数相同</p><h4 id="8-临时文件"><a href="#8-临时文件" class="headerlink" title="8.临时文件"></a>8.临时文件</h4><h5 id="（1）tmpfile"><a href="#（1）tmpfile" class="headerlink" title="（1）tmpfile"></a>（1）tmpfile</h5><p>C 库函数 <strong>FILE *tmpfile(void)</strong> 以二进制更新模式(wb+)创建临时文件。被创建的临时文件会在流关闭的时候或者在程序终止的时候自动删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure><p>return</p><p>如果成功，该函数返回一个指向被创建的临时文件的流指针。如果文件未被创建，则返回 NULL</p><p><strong>实例代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line"></span><br><span class="line">   fp = tmpfile();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;临时文件被创建\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 您可以在这里使用临时文件 */</span></span><br><span class="line"></span><br><span class="line">   fclose(fp);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，它将在 &#x2F;tmp 文件夹中创建一个临时文件，但是一旦程序退出，临时文件会被自动删除</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构部分（5）</title>
      <link href="/2023/07/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86%EF%BC%885%EF%BC%89/"/>
      <url>/2023/07/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86%EF%BC%885%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="一、-顺序存储的线性表"><a href="#一、-顺序存储的线性表" class="headerlink" title="一、 顺序存储的线性表"></a>一、 顺序存储的线性表</h3><p><strong><code>gcc</code>提供了许多的宏，如<code>printf(&quot;%d\n&quot;,__LINE__)</code>可用于打印出程序中的行，用于测试程序是那一部分出现了问题</strong></p><h4 id="1-sqlist-h"><a href="#1-sqlist-h" class="headerlink" title="1.sqlist.h"></a>1.<strong>sqlist.h</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATASIZE 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> datatype;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">datatype data[DATASIZE];</span><br><span class="line"><span class="type">int</span> last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> <span class="title">sqlist</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线性表</span></span><br><span class="line">sqlist *<span class="title function_">sqlist_create</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_insert</span><span class="params">(sqlist *me,<span class="type">int</span> i,datatype *data)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_delete</span><span class="params">(sqlist *me,<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁线性表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_destory</span><span class="params">(sqlist *me)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找数据 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_find</span><span class="params">(sqlist *me,datatype *data)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性表是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_isempty</span><span class="params">(sqlist *me)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将线性表设置为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_setempty</span><span class="params">(sqlist *me)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性表中有多少元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_getnum</span><span class="params">(sqlist *me)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性表合并</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_union</span><span class="params">(sqlist *list1, sqlist *list2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqlist_display</span><span class="params">(sqlist *me)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="2-sqlist-c"><a href="#2-sqlist-c" class="headerlink" title="2.sqlist.c"></a>2.<strong>sqlist.c</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线性表</span></span><br><span class="line">sqlist *<span class="title function_">sqlist_create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建一个sqlist 指针变量</span></span><br><span class="line">sqlist *me;</span><br><span class="line"></span><br><span class="line">me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(me == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性表创建开始的时，线性表中没有元素，因此me-&gt;last = 0或者-1</span></span><br><span class="line">me-&gt;last = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回线性表地址</span></span><br><span class="line"><span class="keyword">return</span> me;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_insert</span><span class="params">(sqlist *me,<span class="type">int</span> i,datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 满</span></span><br><span class="line"><span class="keyword">if</span>(me-&gt;last == DATASIZE<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法位置</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;me-&gt;last+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将i位置以及之后位置原来的值依次向后面移动一位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=me-&gt;last; i&lt;=j ; j--)</span><br><span class="line">me-&gt;data[j+<span class="number">1</span>] = me-&gt;data[j];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将i位置的值赋值为 *data</span></span><br><span class="line">me-&gt;data[i] = *data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素个数 +1   me-&gt;last从从索引0开始，即若me-&gt;last==0代表其中有一个元素</span></span><br><span class="line">me-&gt;last++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_delete</span><span class="params">(sqlist *me,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;me-&gt;last)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将表中数据上移，把删除位置的元素用后一个元素进行填充</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j&lt;=me-&gt;last;j++)</span><br><span class="line">me-&gt;data[j<span class="number">-1</span>] = me-&gt;data[j];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性表数据-1</span></span><br><span class="line">me-&gt;last--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁线性表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_destory</span><span class="params">(sqlist *me)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将线性表开辟的空间进行动态释放</span></span><br><span class="line"><span class="built_in">free</span>(me);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找数据 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_find</span><span class="params">(sqlist *me,datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sqlist_isempty(me) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历线性表，找到了则返回元素下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=me-&gt;last;i++)</span><br><span class="line"><span class="keyword">if</span>(me-&gt;data[i] == *data)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有找到，则返回-2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性表是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_isempty</span><span class="params">(sqlist *me)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(me-&gt;last == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将线性表设置为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_setempty</span><span class="params">(sqlist *me)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 若之后对线性表进行插入数据就会对之前的数据进行填充覆盖</span></span><br><span class="line">me-&gt;last = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性表中有多少元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_getnum</span><span class="params">(sqlist *me)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// me-&gt;last 代表同数组索引从0开始</span></span><br><span class="line"><span class="keyword">return</span> (me-&gt;last + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性表合并</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlist_union</span><span class="params">(sqlist *list1, sqlist *list2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// list1 -&gt; 12 23 34 45 56</span></span><br><span class="line"><span class="comment">// list2 -&gt; 78 89 56 23 10</span></span><br><span class="line"><span class="comment">// 将list2 中的数据插入到 list1 (前提list1中不存在list2中的该元素)</span></span><br><span class="line"><span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=list2-&gt;last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 遍历list2中的元素，若此时sqlist_find为&lt;0,则说明list1中无重复元素，则list1进行该元素的插入</span></span><br><span class="line"><span class="keyword">if</span>(sqlist_find(list1,&amp;list2-&gt;data[i]) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sqlist_insert(list1,i,&amp;list2-&gt;data[i]);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqlist_display</span><span class="params">(sqlist *me)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 若线性表为空</span></span><br><span class="line"><span class="keyword">if</span>(me-&gt;last == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历线性表进行输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=me-&gt;last; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,me-&gt;data[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-main-c"><a href="#3-main-c" class="headerlink" title="3.main.c"></a>3.<strong>main.c</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">sqlist *<span class="built_in">list</span>;</span><br><span class="line">sqlist *list1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>  = sqlist_create();</span><br><span class="line">list1 = sqlist_create();</span><br><span class="line"></span><br><span class="line">datatype arr[<span class="number">6</span>] = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>&#125;;</span><br><span class="line">datatype arr1[<span class="number">6</span>] = &#123;<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">1010</span>,<span class="number">1111</span>,<span class="number">2222</span>&#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sqlist_create() failed!\n&quot;</span>);</span><br><span class="line"><span class="comment">// 程序中止异常退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(list1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sqlist_create() failed!\n&quot;</span>);</span><br><span class="line"><span class="comment">// 程序中止异常退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将创建的数组 arr 按照数组顺序插入到线性表list中</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);i++)</span><br><span class="line">&#123;</span><br><span class="line">err = sqlist_insert(<span class="built_in">list</span>,i,&amp;arr[i]);</span><br><span class="line"><span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 线性表已满</span></span><br><span class="line"><span class="keyword">if</span>(err == <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;the arr is full!\n&quot;</span>);</span><br><span class="line"><span class="comment">// 插入的位置存在问题</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">-2</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;the pose you want to insert is wrong!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="comment">// 其他错误</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;ERROR!\n&quot;</span>);</span><br><span class="line"><span class="comment">// 程序异常，中止</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将创建的数组 arr1 按照数组顺序插入到线性表list1中</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(arr1)/<span class="keyword">sizeof</span>(*arr1);i++)</span><br><span class="line">&#123;</span><br><span class="line">err = sqlist_insert(list1,i,&amp;arr1[i]);</span><br><span class="line"><span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 线性表已满</span></span><br><span class="line"><span class="keyword">if</span>(err == <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;the arr is full!\n&quot;</span>);</span><br><span class="line"><span class="comment">// 插入的位置存在问题</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">-2</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;the pose you want to insert is wrong!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="comment">// 其他错误</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;ERROR!\n&quot;</span>);</span><br><span class="line"><span class="comment">// 程序异常，中止</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示list</span></span><br><span class="line">sqlist_display(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示list1</span></span><br><span class="line">sqlist_display(list1);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">// 删除选择(索引为1)下标处的元素</span></span><br><span class="line"><span class="keyword">if</span>(sqlist_delete(<span class="built_in">list</span>,<span class="number">1</span>)==<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;输入的参数出错!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出删除相应位置的元素后的线性表</span></span><br><span class="line">sqlist_display(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行列表合并</span></span><br><span class="line">sqlist_union(<span class="built_in">list</span>,list1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示合并后的list</span></span><br><span class="line">sqlist_display(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line">sqlist_destory(<span class="built_in">list</span>);</span><br><span class="line">sqlist_destory(list1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常的退出程序</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>makefile</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mytool:main.o sqlist.o</span><br><span class="line">gcc main.o sqlist.o -o mytool</span><br><span class="line"></span><br><span class="line">main.o:main.c</span><br><span class="line">gcc main.c -c -o main.o</span><br><span class="line"></span><br><span class="line">sqlist.o:sqlist.c</span><br><span class="line">gcc sqlist.c -c -o sqlist.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm *.o mytool -rf</span><br></pre></td></tr></table></figure><p><strong>makefile</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OBJS = main.o sqlist.o</span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line">mytool: $(OBJS)</span><br><span class="line">$(CC) $^ -o $@</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">$(CC) $^ -c  -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm *.o mytool -rf </span><br></pre></td></tr></table></figure><p><strong>CMakeLists.txt</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.16</span>)</span><br><span class="line">project(sqlist)</span><br><span class="line"></span><br><span class="line"># 添加可执行文件   直接编译</span><br><span class="line">add_executable(<span class="number">1</span>  sqlist.h  sqlist.c  main.c)</span><br></pre></td></tr></table></figure><h4 id="4-运行结果："><a href="#4-运行结果：" class="headerlink" title="4.运行结果："></a>4.<strong>运行结果：</strong></h4><p><code>make</code>或者<code>cmake(对应于写了CMakeLists.txt的情况)</code></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230316103749.png" alt="image-20230316103742574"></p><h3 id="二、链式存储"><a href="#二、链式存储" class="headerlink" title="二、链式存储"></a>二、链式存储</h3><h4 id="1-单向带头链表的实现"><a href="#1-单向带头链表的实现" class="headerlink" title="1.单向带头链表的实现"></a>1.单向带头链表的实现</h4><p><strong>有头链表的实现,插入元素从索引0开始</strong></p><p>在<code>if</code>的判断中，若判断条件的值小于0也为True，为0的时候才为False</p><p>链表形式如图所示:</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230319210422.png" alt="image-20230319210415010"></p><h5 id="1-list-h"><a href="#1-list-h" class="headerlink" title="(1) list.h"></a>(1) list.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> datatype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">datatype data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建链表</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">list_create</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在索引i处插入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_insert_at</span><span class="params">(<span class="built_in">list</span> *,<span class="type">int</span> i,datatype *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照顺序插入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_order_insert</span><span class="params">(<span class="built_in">list</span> *, datatype *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将索引i处的元素删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_delete_at</span><span class="params">(<span class="built_in">list</span> *,<span class="type">int</span> i,datatype *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_delete</span><span class="params">(<span class="built_in">list</span> *,datatype *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_isempty</span><span class="params">(<span class="built_in">list</span> *)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_destory</span><span class="params">(<span class="built_in">list</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_display</span><span class="params">(<span class="built_in">list</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="2-list-c"><a href="#2-list-c" class="headerlink" title="(2) list.c"></a>(2) list.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建链表(带头节点的)</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">list_create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span> *me;</span><br><span class="line"></span><br><span class="line">me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line"><span class="keyword">if</span>(me==<span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;create() failed!\n&quot;</span>);</span><br><span class="line">me-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在索引i处插入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_insert_at</span><span class="params">(<span class="built_in">list</span> *me,<span class="type">int</span> i,datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 让node 指向头节点的位置</span></span><br><span class="line"><span class="built_in">list</span> *node = me;</span><br><span class="line"><span class="built_in">list</span> *newnode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置不合法</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j&lt;i &amp;&amp; node != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">node = node -&gt; next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node)</span><br><span class="line">&#123;</span><br><span class="line">newnode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*newnode));</span><br><span class="line"><span class="keyword">if</span>(newnode == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">newnode-&gt;data = *data;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">newnode-&gt;next = node-&gt;next;</span><br><span class="line">node-&gt;next = newnode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照顺序插入(从小到大)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_order_insert</span><span class="params">(<span class="built_in">list</span> *me, datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span> *p = me;</span><br><span class="line"><span class="built_in">list</span> *q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入值 比前一个节点的数据大 比后一个节点数据小</span></span><br><span class="line"><span class="comment">// p-&gt;next 为 真即不为空</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;data &lt; *data)</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*q));</span><br><span class="line">q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 若分配空间失败则返回-1</span></span><br><span class="line"><span class="keyword">if</span>(q==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">q-&gt;data = *data;</span><br><span class="line"><span class="comment">// 开始插入</span></span><br><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将索引i处的元素删除，并且将值进行返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_delete_at</span><span class="params">(<span class="built_in">list</span> *me,<span class="type">int</span> i,datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">list</span> *p = me;</span><br><span class="line">*data = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置不合法</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j&lt;i &amp;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若p 不为空，则说明，此时的j==i成立，即索引i没有超过链表的长度</span></span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将需要删除的节点，用一个指针直线，便于释放</span></span><br><span class="line"><span class="built_in">list</span> *q = p-&gt;next;</span><br><span class="line"><span class="comment">// p的后继指针，指向下下个节点</span></span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"><span class="comment">// 将需要删除的值进行存储返回</span></span><br><span class="line">*data = q-&gt;data;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">q = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 索引i已经超过了链表长度，则找不到要删除的索引位置i</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表中节点值为*data的节点删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_delete</span><span class="params">(<span class="built_in">list</span> *me,datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span> *p = me;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前提是p的后继节点不为空，指针才能后移动</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;data!=*data)</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有找到</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 找到了</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将其用指针变量q去指向，这样可以将指针变量q用于释放</span></span><br><span class="line"><span class="built_in">list</span> *q = p-&gt;next;</span><br><span class="line"><span class="comment">// 将指针p的后驱指针指向下下个节点，跳过要删除的节点</span></span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"><span class="comment">// 释放指针q</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_isempty</span><span class="params">(<span class="built_in">list</span> *me)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(me-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_destory</span><span class="params">(<span class="built_in">list</span> *me)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span> *node,*next;</span><br><span class="line"><span class="keyword">for</span>(node = me-&gt;next;node!=<span class="literal">NULL</span>;node=next)</span><br><span class="line">&#123;</span><br><span class="line">next = node -&gt; next;</span><br><span class="line"><span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将头节点销毁</span></span><br><span class="line"><span class="built_in">free</span>(me);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_display</span><span class="params">(<span class="built_in">list</span> *me)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建一个指针，指向链表头节点的后一个节点</span></span><br><span class="line"><span class="built_in">list</span> *node = me-&gt;next;</span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span>(list_isempty(me) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;data);</span><br><span class="line">node = node -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-main-c-1"><a href="#3-main-c-1" class="headerlink" title="(3) main.c"></a>(3) main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span> *l;</span><br><span class="line">datatype delete_value;  <span class="comment">// 返回的删除元素</span></span><br><span class="line">datatype err;</span><br><span class="line"></span><br><span class="line">l = list_create();</span><br><span class="line">datatype arr[] = &#123;<span class="number">11</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 插入失败得到的值都是 小于 0 则进入 if </span></span><br><span class="line"><span class="keyword">if</span>(list_order_insert(l,&amp;arr[i]))</span><br><span class="line"><span class="comment">// 插入失败</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示</span></span><br><span class="line">list_display(l);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = <span class="number">22</span>;</span><br><span class="line"><span class="comment">// 删除节点元素</span></span><br><span class="line">list_delete(l,&amp;value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示</span></span><br><span class="line">list_display(l);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">err = list_delete_at(l,<span class="number">2</span>,&amp;delete_value);</span><br><span class="line"><span class="comment">// 删除出错，则异常中止程序</span></span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 显示</span></span><br><span class="line">list_display(l);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;detele:%d\n&quot;</span>,delete_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line">list_destory(l);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-makefile"><a href="#4-makefile" class="headerlink" title="(4) makefile"></a>(4) makefile</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OBJS = main.o <span class="built_in">list</span>.o</span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line">mytool: $(OBJS)</span><br><span class="line">$(CC) $^ -o $@</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">$(CC) $^ -c  -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm *.o mytool -rf </span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230319210731.png" alt="image-20230319210731217"></p><h4 id="2-二级指针"><a href="#2-二级指针" class="headerlink" title="2.二级指针"></a>2.二级指针</h4><ul><li>用于存储一级指针的地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 ** 指针变量名 = &amp;一级指针变量名</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;age;</span><br><span class="line"><span class="type">int</span> **pp = &amp;p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;age=%p  p=%p  *pp=%p  &amp;p=%p pp=%p  age=%d  *p =%d  **pp=%d  &amp;pp=%p\n&quot;</span>,&amp;age,p,*pp,&amp;p,pp,age,*p,**pp,&amp;pp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230327193605.png" alt="image-20230327193558781"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230327194144.png" alt="image-20230327194144436"></p><p>笔误：上图的<code>*pp</code>为为<code>**pp</code>二级指针</p><p><strong>指针<code>*p</code>指向<code>age</code>,则指针变量<code>p</code>存放的为整型变量<code>age</code>的地址，<code>*p</code>得到<code>age</code>的值。而二级指针变量<code>pp</code>存放的是一级指针变量<code>p</code>的地址，<code>*pp</code>得到为指针变量<code>p</code>内存放的值。<code>*pp</code>将得到<code>age</code>的值。</strong></p><h4 id="3-单向无头链表的实现"><a href="#3-单向无头链表的实现" class="headerlink" title="3.单向无头链表的实现"></a>3.单向无头链表的实现</h4><p><strong>使用二级指针传参数</strong></p><p>无头链表的实现必须使用二级指针进行传参数，进行链表的插入与删除</p><h5 id="（1）nohead-link-h"><a href="#（1）nohead-link-h" class="headerlink" title="（1）nohead_link.h"></a>（1）nohead_link.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NOHEAD_LINK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOHEAD_LINK_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[NAMESIZE];</span><br><span class="line"><span class="type">int</span> math;</span><br><span class="line"><span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> <span class="title">data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_insert</span><span class="params">(<span class="keyword">struct</span> node_st **,<span class="keyword">struct</span> score_st *data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_show</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">list_delete</span><span class="params">(<span class="keyword">struct</span> node_st **)</span>;</span><br><span class="line"><span class="keyword">struct</span> score_st *<span class="title function_">list_find</span><span class="params">(<span class="keyword">struct</span> node_st *,<span class="type">int</span> id)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_destory</span><span class="params">(<span class="keyword">struct</span> node_st *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="（2）nohead-link-c"><a href="#（2）nohead-link-c" class="headerlink" title="（2）nohead_link.c"></a>（2）<strong>nohead_link.c</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;nohead_link.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只完成首部的插入(使用二级指针进行操作)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_insert</span><span class="params">(<span class="keyword">struct</span> node_st **<span class="built_in">list</span>,<span class="keyword">struct</span> score_st *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new));</span><br><span class="line"><span class="keyword">if</span>(new == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">new-&gt;data = *data;</span><br><span class="line">new-&gt;next = *<span class="built_in">list</span>;</span><br><span class="line">*<span class="built_in">list</span> = new;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_show</span><span class="params">(<span class="keyword">struct</span> node_st *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(cur = <span class="built_in">list</span>; cur != <span class="literal">NULL</span>; cur = cur-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  %s  %d  %d\n&quot;</span>,cur-&gt;data.id,cur-&gt;data.name,cur-&gt;data.math,cur-&gt;data.chinese);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只进行第一个节点的删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">list_delete</span><span class="params">(<span class="keyword">struct</span> node_st **<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*<span class="built_in">list</span> == <span class="literal">NULL</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">cur = *<span class="built_in">list</span>;</span><br><span class="line">*<span class="built_in">list</span>  = (*<span class="built_in">list</span>)-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表中查找对应id的值，若找到则返回 对应id下的数据data的地址  若没有找到则返回一个NULL指针</span></span><br><span class="line"><span class="keyword">struct</span> score_st *<span class="title function_">list_find</span><span class="params">(<span class="keyword">struct</span> node_st *<span class="built_in">list</span>,<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(cur = <span class="built_in">list</span>; cur != <span class="literal">NULL</span>; cur = cur-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 找到了对应id的元素</span></span><br><span class="line"><span class="keyword">if</span>(cur-&gt;data.id == id)</span><br><span class="line"><span class="keyword">return</span> &amp;cur-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有找到</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对链表进行销毁操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_destory</span><span class="params">(<span class="keyword">struct</span> node_st *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"><span class="comment">// 当前链表为NULL 不需要进行销毁</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span> ==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(cur=<span class="built_in">list</span>;cur!=<span class="literal">NULL</span>;cur=<span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>  = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）main-c"><a href="#（3）main-c" class="headerlink" title="（3）main.c"></a>（3）main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nohead_link.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">list</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> <span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp.id = i;</span><br><span class="line"><span class="comment">// io函数 在tmp.name位置  可用内存大小为NAMESIZE 写入&quot;stu%d&quot; 其中%d 为 i</span></span><br><span class="line"><span class="built_in">snprintf</span>(tmp.name,NAMESIZE,<span class="string">&quot;stu%d&quot;</span>,i);</span><br><span class="line">tmp.math = rand() % <span class="number">100</span>;</span><br><span class="line">tmp.chinese = rand() % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">ret = list_insert(&amp;<span class="built_in">list</span>,&amp;tmp);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 异常中止</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_show(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">find_data</span>;</span></span><br><span class="line"><span class="type">int</span> id = <span class="number">8</span>;</span><br><span class="line">find_data = list_find(<span class="built_in">list</span>,id);</span><br><span class="line"><span class="keyword">if</span>(find_data != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the id = %d is exist!\n&quot;</span>,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the id = %d is not exist!\n&quot;</span>,id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list_delete(&amp;list);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// printf(&quot;after delete:\n&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list_show(list);</span></span><br><span class="line"></span><br><span class="line">list_destory(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）makefile"><a href="#（4）makefile" class="headerlink" title="（4）makefile"></a>（4）makefile</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OBJS = main.o nohead_link.o</span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line">mytool: $(OBJS)</span><br><span class="line">$(CC) $^ -o $@</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">$(CC) $^ -c  -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm *.o mytool -rf </span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230328122333.png" alt="image-20230328122326764"></p><h4 id="4-约瑟夫算法"><a href="#4-约瑟夫算法" class="headerlink" title="4.约瑟夫算法"></a>4.约瑟夫算法</h4><p><strong>使用无头环路链表进行实现</strong></p><p><strong>约瑟夫问题：</strong>n个人围成一圈，初始编号从1~n排列，从约定编号为x的人开始报数，数到第m个人出圈，接着又从1开始报数，报到第m个数的人又退出圈，以此类推，最后圈内只剩下一个人，这个人就是赢家，求出赢家的编号。</p><p>问题定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环路链表的长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOSE_NUM 10</span></span><br><span class="line"><span class="comment">// 数到 m 则出局</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> m 3</span></span><br></pre></td></tr></table></figure><p><strong><code>mian.c</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 环路链表的长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOSE_NUM 10</span></span><br><span class="line"><span class="comment">// 数到NUM则出局</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> m 3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建链表(环)</span></span><br><span class="line"><span class="keyword">struct</span> node_st *<span class="title function_">jose_create</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 创建第一个节点使其自己指向自己</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">me</span>;</span></span><br><span class="line">me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line"><span class="keyword">if</span>(me == <span class="literal">NULL</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">me-&gt;data = i;</span><br><span class="line">me-&gt;next = me;</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag节点用于保存指向首节点的节点位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">flag</span> =</span> me;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建新的节点然后插入之前的约瑟夫环</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">new</span>;</span></span><br><span class="line">new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new));</span><br><span class="line"><span class="comment">// 若申请失败了 返回 NULL</span></span><br><span class="line"><span class="keyword">if</span>(new == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">new-&gt;data = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入工作</span></span><br><span class="line"><span class="comment">// 新建的节点指向首节点</span></span><br><span class="line">new -&gt; next = me;</span><br><span class="line"><span class="comment">// 原来环路的最后一个节点指向新节点</span></span><br><span class="line">flag -&gt; next  = new;</span><br><span class="line"><span class="comment">// 重新定义新环路最后一个节点</span></span><br><span class="line">flag = new;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回环路的首节点</span></span><br><span class="line"><span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数到数字为n的人则出局</span></span><br><span class="line"><span class="comment">// 出局的节点则在环路中进行该节点的delete操作</span></span><br><span class="line"><span class="comment">// 在delete之前会将需要删除节点的data进行printf</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jose_kill</span><span class="params">(<span class="keyword">struct</span> node_st **me,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">cur</span> =</span> *me;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当链表中只剩下一个节点时，则停止while循环</span></span><br><span class="line"><span class="keyword">while</span>(cur != cur-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 当flag数到n-1时，cur指针已经指向了需要出局的节点</span></span><br><span class="line"><span class="keyword">while</span>(flag &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">node = cur;</span><br><span class="line">cur = cur -&gt; next;</span><br><span class="line">flag++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将需要删除节点的data进行打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,cur-&gt;data);</span><br><span class="line"><span class="comment">// 对cur节点进行delete操作</span></span><br><span class="line">node-&gt;next = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行后一轮数数</span></span><br><span class="line">cur = node-&gt;next;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 环路中还剩下最后一个节点不会进行delete</span></span><br><span class="line"><span class="comment">// 此时 cur指向 最后一个节点</span></span><br><span class="line">*me = cur; <span class="comment">// 此时的环路为只剩下一个节点的环路</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出环路元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jose_show</span><span class="params">(<span class="keyword">struct</span> node_st *me)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"><span class="comment">// 这个循环会少输出最后一个节点元素</span></span><br><span class="line"><span class="keyword">for</span>(cur=me;cur-&gt;next!=me;cur=cur-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,cur-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,cur-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将约瑟夫环的第一个位置的地址返回</span></span><br><span class="line"><span class="built_in">list</span> = jose_create(JOSE_NUM);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 显示</span></span><br><span class="line">jose_show(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行约瑟夫循环</span></span><br><span class="line">jose_kill(&amp;<span class="built_in">list</span>,m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示最后一个节点</span></span><br><span class="line">jose_show(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表中每个节点的结构如上的结构体</p><h5 id="（1）jose-create-创建无头的环路链表"><a href="#（1）jose-create-创建无头的环路链表" class="headerlink" title="（1）jose_create() 创建无头的环路链表"></a>（1）<code>jose_create()</code> 创建无头的环路链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node_st *<span class="title function_">jose_create</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 创建第一个节点使其自己指向自己</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">me</span>;</span></span><br><span class="line">me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line"><span class="keyword">if</span>(me == <span class="literal">NULL</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">me-&gt;data = i;</span><br><span class="line">me-&gt;next = me;</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag节点用于保存指向首节点的节点位置(环路中最后一个插入进来节点的位置)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">flag</span> =</span> me;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建新的节点然后插入之前的约瑟夫环</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">new</span>;</span></span><br><span class="line">new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new));</span><br><span class="line"><span class="comment">// 若申请失败了 返回 NULL</span></span><br><span class="line"><span class="keyword">if</span>(new == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">new-&gt;data = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入工作</span></span><br><span class="line"><span class="comment">// 新建的节点指向首节点</span></span><br><span class="line">new -&gt; next = me;</span><br><span class="line"><span class="comment">// 原来环路的最后一个节点指向新节点</span></span><br><span class="line">flag -&gt; next  = new;</span><br><span class="line"><span class="comment">// 重新定义新环路最后一个节点</span></span><br><span class="line">flag = new;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回环路的首节点</span></span><br><span class="line"><span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230401103903.png" alt="image-20230401103856676"></p><h5 id="（2）jose-kill-数数到n的人出局"><a href="#（2）jose-kill-数数到n的人出局" class="headerlink" title="（2）jose_kill() 数数到n的人出局"></a>（2）<code>jose_kill()</code> 数数到n的人出局</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数到数字为n的人则出局</span></span><br><span class="line"><span class="comment">// 出局的节点则在环路中进行该节点的delete操作</span></span><br><span class="line"><span class="comment">// 在delete之前会将需要删除节点的data进行printf</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jose_kill</span><span class="params">(<span class="keyword">struct</span> node_st **me,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">cur</span> =</span> *me;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当链表中只剩下一个节点时，则停止while循环</span></span><br><span class="line"><span class="keyword">while</span>(cur != cur-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 当flag数到n-1时，cur指针已经指向了需要出局的节点</span></span><br><span class="line"><span class="keyword">while</span>(flag &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">node = cur;</span><br><span class="line">cur = cur -&gt; next;</span><br><span class="line">flag++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将需要删除节点的data进行打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,cur-&gt;data);</span><br><span class="line"><span class="comment">// 对cur节点进行delete操作</span></span><br><span class="line">node-&gt;next = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行后一轮数数</span></span><br><span class="line">cur = node-&gt;next;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 环路中还剩下最后一个节点不会进行delete</span></span><br><span class="line"><span class="comment">// 此时 cur指向 最后一个节点</span></span><br><span class="line">*me = cur; <span class="comment">// 此时的环路为只剩下一个节点的环路</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230401104002.png" alt="image-20230401104002141"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230401104015.png" alt="image-20230401104015002"></p><h4 id="5-双向循环链表"><a href="#5-双向循环链表" class="headerlink" title="5.双向循环链表"></a>5.双向循环链表</h4><p><strong><code>io</code>函数 在<code>tmp.name</code>位置  可用内存大小为<code>NAMESIZE</code> 写入<code>&quot;stu%d&quot; </code>其中<code>%d </code>为<code> i</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(tmp.name,NAME_SIZE,<span class="string">&quot;std%d&quot;</span>,i);</span><br></pre></td></tr></table></figure><p><code>memcpy()</code></p><p>从存储区 <strong><code>str2</code></strong> 复制 <strong><code>n</code></strong> 个字节到存储区 <strong><code>str1</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure><p><code>typedef</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// llist_op 被定义为 返回值为void 类型 参数为 const void *的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">llist_op</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure><p><strong>项目结构目录:</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── doubleLinklist</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   └── llist.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libd_link.so</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">    └── llist.c</span><br></pre></td></tr></table></figure><h5 id="（1）llist-h"><a href="#（1）llist-h" class="headerlink" title="（1）llist.h"></a>（1）llist.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入模式的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_FORWARD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_BACKWARD 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// llist_op 被定义为 返回值为void 类型 参数为 const void *的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">llist_op</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">llist_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">pre</span>;</span>  <span class="comment">// 四个字节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">next</span>;</span> <span class="comment">// 四个字节</span></span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 此处的head 只是一个结构体对象，不是指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> <span class="title">head</span>;</span></span><br><span class="line">&#125;LLIST;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> initsize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llistt_find</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *,llist_op *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * list_head)</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： </p><ul><li><code>const void *a</code>定义一个指针a,a可以指向任意类型的值，且它指向的值必须是<strong>常量</strong>。在这种情况下，我们不能修改被指向的对象，但可以使指针指向其他对象。</li><li><code>void* const a</code>定义了一个<code>const</code>指针a，a可以指向任意类型的值，但a是指向某个对象的常量指针。我们不能修改指针中存储的地址，但可以修改指针指向的对象。</li></ul><p><code>const void *a</code>；中<code>const</code>修饰的是<code>*a</code>。在<code>void* const a</code>中，<code>const </code>修饰的是<code>a</code></p><h5 id="（2）llist-c"><a href="#（2）llist-c" class="headerlink" title="（2）llist.c"></a>（2）llist.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/llist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 创建链表</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          init_size: 节点的data内存大小</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> init_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    LLIST *new;</span><br><span class="line"></span><br><span class="line">    new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new));</span><br><span class="line">    <span class="keyword">if</span>(new==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点不存储数据</span></span><br><span class="line">    new-&gt;size = init_size;</span><br><span class="line">    new-&gt;head.data=<span class="literal">NULL</span>;</span><br><span class="line">    new-&gt;head.pre = &amp;new-&gt;head;</span><br><span class="line">    new-&gt;head.next = &amp;new-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 节点数据的插入</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          data:插入的数据，传入数据的地址</span></span><br><span class="line"><span class="comment"> *          mode:选择插入模式(首部or尾部)</span></span><br><span class="line"><span class="comment"> * return:</span></span><br><span class="line"><span class="comment"> *          是否插入成功</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">new_node</span>;</span></span><br><span class="line"></span><br><span class="line">    new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new_node));</span><br><span class="line">    <span class="keyword">if</span>(new_node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    new_node-&gt;data = <span class="built_in">malloc</span>(ptr-&gt;size);</span><br><span class="line">    <span class="keyword">if</span>(new_node-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="comment">// 将存储区 data 复制ptr_size个字节数据到存储区 new_node-&gt;data</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_node-&gt;data, data, ptr-&gt;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode == LLIST_FORWARD)&#123;</span><br><span class="line">        <span class="comment">// 首部插入</span></span><br><span class="line">        new_node-&gt;pre = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;next = ptr-&gt;head.next;</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mode == LLIST_BACKWARD)&#123;</span><br><span class="line">        <span class="comment">// 尾部插入</span></span><br><span class="line">        new_node-&gt;pre = ptr-&gt;head.pre;</span><br><span class="line">        new_node-&gt;next = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//ERROR</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当前函数使用static修饰，只在当前c文件可见（作用范围）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> llist_node_st *<span class="title function_">find_</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(key,cur-&gt;data) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回该节点 ，若最后没有找到 cur 当前为ptr-&gt;head,head.data==NULL</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中根据 key 进行查找节点</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          key:链表中查找的key  可以是id 也可以是 name 等，但是要与对应的cmp函数匹配</span></span><br><span class="line"><span class="comment"> *          cmp:比较函数（若为id查找，则在当前迭代的节点中的id 与key相同时，就返回当前节点中的data域）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llistt_find</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将该节点中的data域取出</span></span><br><span class="line">    <span class="keyword">return</span> find_(ptr,key,cmp)-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 删除链表中的节点</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    <span class="comment">// 在llist_insert()函数中 对new_node以及new_node-&gt;data都使用了动态内存的开辟</span></span><br><span class="line">    <span class="built_in">free</span>(node-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中按照key进行查找，并且返回删除的节点数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若给的data指针为NULL，则表示不需要进行data回填</span></span><br><span class="line">    <span class="keyword">if</span>(data!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">memcpy</span>(data,node-&gt;data,ptr-&gt;size);</span><br><span class="line">    <span class="built_in">free</span>(node-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 遍历链表</span></span><br><span class="line"><span class="comment"> * Note:此处用回调函数(函数指针)实现一个通用型的接口(并不清楚用户定义的数据类型的内部结构)</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr: 链表头节点</span></span><br><span class="line"><span class="comment"> *          llist_op *: 函数指针，指向一个函数，当运行到该段代码时，则运行该函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *ptr,llist_op *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用回调函数</span></span><br><span class="line">        op(cur-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>,*<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = next)</span><br><span class="line">    &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur-&gt;data);</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头节点destory</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>static</code>修饰函数</strong>:函数的返回类型前加上关键字static，函数就被定义成为<strong>静态函数</strong>.函数的定义和声明默认情况下是<code>extern</code>的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用</p><h5 id="（3）main-c-1"><a href="#（3）main-c-1" class="headerlink" title="（3）main.c"></a>（3）main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/llist.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_SIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自定义的结构体数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[NAME_SIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，用户根据自己定义的数据类型进行函数功能定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_s</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d \n&quot;</span>,r-&gt;id,r-&gt;name,r-&gt;math,r-&gt;chinese);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照id 相等则查找成功</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">id_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key,<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *k = key;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (*k - r-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">name_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key,<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *k = key;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(k,r-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建链表</span></span><br><span class="line">    LLIST *handler;</span><br><span class="line">    <span class="keyword">if</span>(handler == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">// 结束当前进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    handler = llist_create(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> score_st));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建插入数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        tmp.id = i;</span><br><span class="line">        <span class="built_in">snprintf</span>(tmp.name,NAME_SIZE,<span class="string">&quot;std%d&quot;</span>,i);</span><br><span class="line">        tmp.math = rand()%<span class="number">100</span>;</span><br><span class="line">        tmp.chinese = rand()%<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = llist_insert(handler,&amp;tmp,LLIST_FORWARD);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">            <span class="comment">// ERROR 不为0  结束当前进程</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    llist_travel(handler,print_s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id_delete = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> ret = llist_delete(handler,&amp;id_delete, id_cmp);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;delete failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    llist_travel(handler,print_s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 查找id为3</span></span><br><span class="line">    <span class="type">int</span> id = <span class="number">4</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">score_st</span> *<span class="title">data</span>;</span></span><br><span class="line">    data = llistt_find(handler,&amp;id,id_cmp);</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not find!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print_s(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    llist_destory(handler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）CMakeLists-txt"><a href="#（4）CMakeLists-txt" class="headerlink" title="（4）CMakeLists.txt"></a>（4）CMakeLists.txt</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(doubleLinklist C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(HOME <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置动态(静态)库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line">datatype</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(d_link SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(doubleLinklist main.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(doubleLinklist d_link)</span><br></pre></td></tr></table></figure><h5 id="（5）运行结果"><a href="#（5）运行结果" class="headerlink" title="（5）运行结果"></a>（5）运行结果</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> std6 <span class="number">90</span> <span class="number">59</span> </span><br><span class="line"><span class="number">5</span> std5 <span class="number">62</span> <span class="number">27</span> </span><br><span class="line"><span class="number">4</span> std4 <span class="number">49</span> <span class="number">21</span> </span><br><span class="line"><span class="number">3</span> std3 <span class="number">86</span> <span class="number">92</span> </span><br><span class="line"><span class="number">2</span> std2 <span class="number">93</span> <span class="number">35</span> </span><br><span class="line"><span class="number">1</span> std1 <span class="number">77</span> <span class="number">15</span> </span><br><span class="line"><span class="number">0</span> std0 <span class="number">83</span> <span class="number">86</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6</span> std6 <span class="number">90</span> <span class="number">59</span> </span><br><span class="line"><span class="number">5</span> std5 <span class="number">62</span> <span class="number">27</span> </span><br><span class="line"><span class="number">4</span> std4 <span class="number">49</span> <span class="number">21</span> </span><br><span class="line"><span class="number">2</span> std2 <span class="number">93</span> <span class="number">35</span> </span><br><span class="line"><span class="number">1</span> std1 <span class="number">77</span> <span class="number">15</span> </span><br><span class="line"><span class="number">0</span> std0 <span class="number">83</span> <span class="number">86</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> std4 <span class="number">49</span> <span class="number">21</span> </span><br></pre></td></tr></table></figure><p><strong>重点:</strong> 当前的程序<code>llist.h</code>中，每一个一般节点中均存在一个指向数据域的指针<code>*data</code>,用户可以在<code>main.c</code>中对<code>data</code>指针所指向的数据类型进行自主的定义，但是在一般节点中，<code>void *data</code>指针实际也是占用了四个字节的内存，如何避免这多余的四个字节的内存的浪费？下面的第6节进行解答</p><h5 id="6-双向循环链表-一般节点的变长结构体实现"><a href="#6-双向循环链表-一般节点的变长结构体实现" class="headerlink" title="6.双向循环链表(一般节点的变长结构体实现)"></a>6.双向循环链表(一般节点的变长结构体实现)</h5><p>在第5小节中，<code>llist.h</code>中的双向环链中一般节点<code>struct llist_node_st</code>中的<code>void *data</code>指针不是必要的，可以进行变化，将整个<code>struct llist_node_st</code>变为一个<strong>变长的数据结构体</strong></p><p><code>c99</code>标准才支持长度为0的数组</p><p>将上述的<code>struct llist_node_st</code>变为一个<strong>变长的数据结构体</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">pre</span>;</span> <span class="comment">// 四字节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">next</span>;</span><span class="comment">// 四字节</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];   <span class="comment">// 这是一地址的占位符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将第5小节代码中的<code>free(cur-&gt;data)</code>进行注释，因为这不是一个动态开辟的内存了，是一个数组</p><p>将<code>llist_inseert.c</code>中的<code>new_node-&gt;data = malloc(ptr-&gt;size)</code>注释</p><h5 id="（1）llist-h-1"><a href="#（1）llist-h-1" class="headerlink" title="（1）llist.h"></a>（1）llist.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入模式的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_FORWARD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_BACKWARD 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// llist_op 被定义为 返回值为void 类型 参数为 const void *的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">llist_op</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">llist_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 此处的head 只是一个结构体对象，不是指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> <span class="title">head</span>;</span></span><br><span class="line">&#125;LLIST;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> initsize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llist_find</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *,llist_op *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * list_head)</span>;</span><br></pre></td></tr></table></figure><h5 id="（2）llist-c-1"><a href="#（2）llist-c-1" class="headerlink" title="（2）llist.c"></a>（2）llist.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/llist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 创建链表</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          init_size: 节点的data内存大小</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> init_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    LLIST *new;</span><br><span class="line"></span><br><span class="line">    new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new));</span><br><span class="line">    <span class="keyword">if</span>(new==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点不存储数据/</span></span><br><span class="line">    new-&gt;size = init_size;</span><br><span class="line">    <span class="comment">// new-&gt;head.data=NULL;</span></span><br><span class="line">    new-&gt;head.pre = &amp;new-&gt;head;</span><br><span class="line">    new-&gt;head.next = &amp;new-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 节点数据的插入</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          data:插入的数据，传入数据的地址</span></span><br><span class="line"><span class="comment"> *          mode:选择插入模式(首部or尾部)</span></span><br><span class="line"><span class="comment"> * return:</span></span><br><span class="line"><span class="comment"> *          是否插入成功</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">new_node</span>;</span></span><br><span class="line"></span><br><span class="line">    new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new_node) + ptr-&gt;size);</span><br><span class="line">    <span class="keyword">if</span>(new_node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new_node-&gt;data = malloc(ptr-&gt;size);</span></span><br><span class="line">    <span class="keyword">if</span>(new_node-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="comment">// 将存储区 data 复制ptr_size个字节数据到存储区 new_node-&gt;data</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_node-&gt;data, data, ptr-&gt;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode == LLIST_FORWARD)&#123;</span><br><span class="line">        <span class="comment">// 首部插入</span></span><br><span class="line">        new_node-&gt;pre = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;next = ptr-&gt;head.next;</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mode == LLIST_BACKWARD)&#123;</span><br><span class="line">        <span class="comment">// 尾部插入</span></span><br><span class="line">        new_node-&gt;pre = ptr-&gt;head.pre;</span><br><span class="line">        new_node-&gt;next = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//ERROR</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> llist_node_st *<span class="title function_">find_</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(key,cur-&gt;data) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回该节点 ，若最后没有找到 cur 当前为ptr-&gt;head,head.data==NULL</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中根据 key 进行查找节点</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          key:链表中查找的key  可以是id 也可以是 name 等，但是要与对应的cmp函数匹配</span></span><br><span class="line"><span class="comment"> *          cmp:比较函数（若为id查找，则在当前迭代的节点中的id 与key相同时，就返回当前节点中的data域）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llistt_find</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将该节点中的data域取出</span></span><br><span class="line">    <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 删除链表中的节点</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    <span class="comment">// free(node-&gt;data);</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中按照key进行查找，并且返回删除的节点数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若给的data指针为NULL，则表示不需要进行data回填</span></span><br><span class="line">    <span class="keyword">if</span>(data!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">memcpy</span>(data,node-&gt;data,ptr-&gt;size);</span><br><span class="line">    <span class="comment">// free(node-&gt;data);</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 遍历链表</span></span><br><span class="line"><span class="comment"> * Note:此处用回调函数(函数指针)实现一个通用型的接口(并不清楚用户定义的数据类型的内部结构)</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr: 链表头节点</span></span><br><span class="line"><span class="comment"> *          llist_op *: 函数指针，指向一个函数，当运行到该段代码时，则运行该函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *ptr,llist_op *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用回调函数</span></span><br><span class="line">        op(cur-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>,*<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = next)</span><br><span class="line">    &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        <span class="comment">// free(cur-&gt;data);</span></span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头节点destory</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）main-c-2"><a href="#（3）main-c-2" class="headerlink" title="（3）main.c"></a>（3）main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/llist.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_SIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自定义的结构体数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[NAME_SIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，用户根据自己定义的数据类型进行函数功能定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_s</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d \n&quot;</span>,r-&gt;id,r-&gt;name,r-&gt;math,r-&gt;chinese);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照id 相等则查找成功</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">id_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key,<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *k = key;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (*k - r-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">name_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key,<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *k = key;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(k,r-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建链表</span></span><br><span class="line">    LLIST *handler;</span><br><span class="line">    <span class="keyword">if</span>(handler == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">// 结束当前进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    handler = llist_create(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> score_st));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建插入数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        tmp.id = i;</span><br><span class="line">        <span class="built_in">snprintf</span>(tmp.name,NAME_SIZE,<span class="string">&quot;std%d&quot;</span>,i);</span><br><span class="line">        tmp.math = rand()%<span class="number">100</span>;</span><br><span class="line">        tmp.chinese = rand()%<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = llist_insert(handler,&amp;tmp,LLIST_FORWARD);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">            <span class="comment">// ERROR 不为0  结束当前进程</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    llist_travel(handler,print_s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id_delete = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> ret = llist_delete(handler,&amp;id_delete, id_cmp);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;delete failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    llist_travel(handler,print_s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 查找id为3</span></span><br><span class="line">    <span class="type">int</span> id = <span class="number">4</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">score_st</span> *<span class="title">data</span>;</span></span><br><span class="line">    data = llistt_find(handler,&amp;id,id_cmp);</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not find!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print_s(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    llist_destory(handler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-双向循环链表-封装为类"><a href="#7-双向循环链表-封装为类" class="headerlink" title="7.双向循环链表(封装为类)"></a>7.双向循环链表(封装为类)</h4><h5 id="（1）llist-h-2"><a href="#（1）llist-h-2" class="headerlink" title="（1）llist.h"></a>（1）llist.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入模式的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_FORWARD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_BACKWARD 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// llist_op 被定义为 返回值为void 类型 参数为 const void *的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">llist_op</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">llist_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">llist_head</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 此处的head 只是一个结构体对象，不是指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// 定义函数指针</span></span><br><span class="line">    <span class="type">int</span> (*insert)(<span class="keyword">struct</span> llist_head *,<span class="type">const</span> <span class="type">void</span> *,<span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span> * (*find)(<span class="keyword">struct</span> llist_head *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *);</span><br><span class="line">    <span class="type">int</span> (*delete)(<span class="keyword">struct</span> llist_head *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp);</span><br><span class="line">    <span class="type">int</span> (*fetch)(<span class="keyword">struct</span> llist_head *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*travel)(<span class="keyword">struct</span> llist_head *,llist_op *);</span><br><span class="line">    <span class="type">int</span> (*destory)(<span class="keyword">struct</span> llist_head * list_head);</span><br><span class="line">&#125;LLIST;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> initsize)</span>;</span><br></pre></td></tr></table></figure><h5 id="（2）llist-c-2"><a href="#（2）llist-c-2" class="headerlink" title="（2）llist.c"></a>（2）llist.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/llist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">llistt_find</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *,llist_op *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * list_head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 创建链表</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          init_size: 节点的data内存大小</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> init_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    LLIST *new;</span><br><span class="line"></span><br><span class="line">    new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new));</span><br><span class="line">    <span class="keyword">if</span>(new==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点不存储数据/</span></span><br><span class="line">    new-&gt;size = init_size;</span><br><span class="line">    <span class="comment">// new-&gt;head.data=NULL;</span></span><br><span class="line">    new-&gt;head.pre = &amp;new-&gt;head;</span><br><span class="line">    new-&gt;head.next = &amp;new-&gt;head;</span><br><span class="line"></span><br><span class="line">    new-&gt;insert = llist_insert;</span><br><span class="line">    new-&gt;find = llistt_find;</span><br><span class="line">    new-&gt;delete = llist_delete;</span><br><span class="line">    new-&gt;fetch = llist_fetch;</span><br><span class="line">    new-&gt;travel = llist_travel;</span><br><span class="line">    new-&gt;destory = llist_destory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 节点数据的插入</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          data:插入的数据，传入数据的地址</span></span><br><span class="line"><span class="comment"> *          mode:选择插入模式(首部or尾部)</span></span><br><span class="line"><span class="comment"> * return:</span></span><br><span class="line"><span class="comment"> *          是否插入成功</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">new_node</span>;</span></span><br><span class="line"></span><br><span class="line">    new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new_node) + ptr-&gt;size);</span><br><span class="line">    <span class="keyword">if</span>(new_node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new_node-&gt;data = malloc(ptr-&gt;size);</span></span><br><span class="line">    <span class="keyword">if</span>(new_node-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="comment">// 将存储区 data 复制ptr_size个字节数据到存储区 new_node-&gt;data</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_node-&gt;data, data, ptr-&gt;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode == LLIST_FORWARD)&#123;</span><br><span class="line">        <span class="comment">// 首部插入</span></span><br><span class="line">        new_node-&gt;pre = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;next = ptr-&gt;head.next;</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mode == LLIST_BACKWARD)&#123;</span><br><span class="line">        <span class="comment">// 尾部插入</span></span><br><span class="line">        new_node-&gt;pre = ptr-&gt;head.pre;</span><br><span class="line">        new_node-&gt;next = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//ERROR</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> llist_node_st *<span class="title function_">find_</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(key,cur-&gt;data) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回该节点 ，若最后没有找到 cur 当前为ptr-&gt;head,head.data==NULL</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中根据 key 进行查找节点</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          key:链表中查找的key  可以是id 也可以是 name 等，但是要与对应的cmp函数匹配</span></span><br><span class="line"><span class="comment"> *          cmp:比较函数（若为id查找，则在当前迭代的节点中的id 与key相同时，就返回当前节点中的data域）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llistt_find</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将该节点中的data域取出</span></span><br><span class="line">    <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 删除链表中的节点</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    <span class="comment">// free(node-&gt;data);</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中按照key进行查找，并且返回删除的节点数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若给的data指针为NULL，则表示不需要进行data回填</span></span><br><span class="line">    <span class="keyword">if</span>(data!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">memcpy</span>(data,node-&gt;data,ptr-&gt;size);</span><br><span class="line">    <span class="comment">// free(node-&gt;data);</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 遍历链表</span></span><br><span class="line"><span class="comment"> * Note:此处用回调函数(函数指针)实现一个通用型的接口(并不清楚用户定义的数据类型的内部结构)</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr: 链表头节点</span></span><br><span class="line"><span class="comment"> *          llist_op *: 函数指针，指向一个函数，当运行到该段代码时，则运行该函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *ptr,llist_op *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用回调函数</span></span><br><span class="line">        op(cur-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>,*<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = next)</span><br><span class="line">    &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        <span class="comment">// free(cur-&gt;data);</span></span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头节点destory</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）main-c-3"><a href="#（3）main-c-3" class="headerlink" title="（3）main.c"></a>（3）main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/llist.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_SIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自定义的结构体数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[NAME_SIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，用户根据自己定义的数据类型进行函数功能定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_s</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d \n&quot;</span>,r-&gt;id,r-&gt;name,r-&gt;math,r-&gt;chinese);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照id 相等则查找成功</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">id_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key,<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *k = key;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (*k - r-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">name_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key,<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *k = key;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(k,r-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建链表</span></span><br><span class="line">    LLIST *handler;</span><br><span class="line">    <span class="keyword">if</span>(handler == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">// 结束当前进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    handler = llist_create(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> score_st));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建插入数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        tmp.id = i;</span><br><span class="line">        <span class="built_in">snprintf</span>(tmp.name,NAME_SIZE,<span class="string">&quot;std%d&quot;</span>,i);</span><br><span class="line">        tmp.math = rand()%<span class="number">100</span>;</span><br><span class="line">        tmp.chinese = rand()%<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = handler-&gt;insert(handler,&amp;tmp,LLIST_FORWARD);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">            <span class="comment">// ERROR 不为0  结束当前进程</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    handler-&gt;travel(handler,print_s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id_delete = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> ret = handler-&gt;delete(handler,&amp;id_delete, id_cmp);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;delete failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    handler-&gt;travel(handler,print_s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 查找id为3</span></span><br><span class="line">    <span class="type">int</span> id = <span class="number">4</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">score_st</span> *<span class="title">data</span>;</span></span><br><span class="line">    data = handler-&gt;find(handler,&amp;id,id_cmp);</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not find!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print_s(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    handler-&gt;destory(handler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-双向循环链表-封装为类-将来使用llist-c作为动态库使用"><a href="#8-双向循环链表-封装为类-将来使用llist-c作为动态库使用" class="headerlink" title="8.双向循环链表(封装为类-将来使用llist.c作为动态库使用)"></a>8.双向循环链表(封装为类-将来使用<code>llist.c</code>作为动态库使用)</h4><p>将真正的数据结构进行隐藏，之后直接可以链接<code>llist.c</code>动态库使用其函数，更加保护源码</p><h5 id="（1）llist-h-3"><a href="#（1）llist-h-3" class="headerlink" title="（1）llist.h"></a>（1）llist.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入模式的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_FORWARD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_BACKWARD 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> LLIST;</span><br><span class="line"></span><br><span class="line"><span class="comment">// llist_op 被定义为 返回值为void 类型 参数为 const void *的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">llist_op</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">llist_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> initsize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llistt_find</span><span class="params">(LLIST *p,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *p,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *p,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *,llist_op *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * list_head)</span>;</span><br></pre></td></tr></table></figure><h5 id="（2）llist-c-3"><a href="#（2）llist-c-3" class="headerlink" title="（2）llist.c"></a>（2）llist.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/llist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_head_st</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 此处的head 只是一个结构体对象，不是指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> <span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 创建链表</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          init_size: 节点的data内存大小</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> init_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_head_st</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new));</span><br><span class="line">    <span class="keyword">if</span>(new==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点不存储数据/</span></span><br><span class="line">    new-&gt;size = init_size;</span><br><span class="line">    <span class="comment">// new-&gt;head.data=NULL;</span></span><br><span class="line">    new-&gt;head.pre = &amp;new-&gt;head;</span><br><span class="line">    new-&gt;head.next = &amp;new-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 节点数据的插入</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          data:插入的数据，传入数据的地址</span></span><br><span class="line"><span class="comment"> *          mode:选择插入模式(首部or尾部)</span></span><br><span class="line"><span class="comment"> * return:</span></span><br><span class="line"><span class="comment"> *          是否插入成功</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *p,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">new_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_head_st</span> *<span class="title">ptr</span> =</span> p; <span class="comment">// 类型强转</span></span><br><span class="line"></span><br><span class="line">    new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new_node) + ptr-&gt;size);</span><br><span class="line">    <span class="keyword">if</span>(new_node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new_node-&gt;data = malloc(ptr-&gt;size);</span></span><br><span class="line">    <span class="keyword">if</span>(new_node-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="comment">// 将存储区 data 复制ptr_size个字节数据到存储区 new_node-&gt;data</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_node-&gt;data, data, ptr-&gt;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode == LLIST_FORWARD)&#123;</span><br><span class="line">        <span class="comment">// 首部插入</span></span><br><span class="line">        new_node-&gt;pre = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;next = ptr-&gt;head.next;</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mode == LLIST_BACKWARD)&#123;</span><br><span class="line">        <span class="comment">// 尾部插入</span></span><br><span class="line">        new_node-&gt;pre = ptr-&gt;head.pre;</span><br><span class="line">        new_node-&gt;next = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//ERROR</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> llist_node_st *<span class="title function_">find_</span><span class="params">(<span class="keyword">struct</span> llist_head_st *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(key,cur-&gt;data) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回该节点 ，若最后没有找到 cur 当前为ptr-&gt;head,head.data==NULL</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中根据 key 进行查找节点</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          key:链表中查找的key  可以是id 也可以是 name 等，但是要与对应的cmp函数匹配</span></span><br><span class="line"><span class="comment"> *          cmp:比较函数（若为id查找，则在当前迭代的节点中的id 与key相同时，就返回当前节点中的data域）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llistt_find</span><span class="params">(LLIST *p,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_head_st</span> *<span class="title">ptr</span> =</span> p;</span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将该节点中的data域取出</span></span><br><span class="line">    <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 删除链表中的节点</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *p,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_head_st</span> *<span class="title">ptr</span> =</span> p;</span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    <span class="comment">// free(node-&gt;data);</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中按照key进行查找，并且返回删除的节点数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *p,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_head_st</span> *<span class="title">ptr</span> =</span> p;</span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若给的data指针为NULL，则表示不需要进行data回填</span></span><br><span class="line">    <span class="keyword">if</span>(data!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">memcpy</span>(data,node-&gt;data,ptr-&gt;size);</span><br><span class="line">    <span class="comment">// free(node-&gt;data);</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 遍历链表</span></span><br><span class="line"><span class="comment"> * Note:此处用回调函数(函数指针)实现一个通用型的接口(并不清楚用户定义的数据类型的内部结构)</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr: 链表头节点</span></span><br><span class="line"><span class="comment"> *          llist_op *: 函数指针，指向一个函数，当运行到该段代码时，则运行该函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *p,llist_op *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_head_st</span> *<span class="title">ptr</span> =</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用回调函数</span></span><br><span class="line">        op(cur-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>,*<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_head_st</span> *<span class="title">ptr</span> =</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = next)</span><br><span class="line">    &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        <span class="comment">// free(cur-&gt;data);</span></span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头节点destory</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）main-c-4"><a href="#（3）main-c-4" class="headerlink" title="（3）main.c"></a>（3）main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/llist.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_SIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自定义的结构体数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[NAME_SIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，用户根据自己定义的数据类型进行函数功能定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_s</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d \n&quot;</span>,r-&gt;id,r-&gt;name,r-&gt;math,r-&gt;chinese);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照id 相等则查找成功</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">id_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key,<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *k = key;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (*k - r-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">name_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key,<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *k = key;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(k,r-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建链表</span></span><br><span class="line">    LLIST *handler;</span><br><span class="line">    <span class="keyword">if</span>(handler == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">// 结束当前进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    handler = llist_create(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> score_st));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建插入数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        tmp.id = i;</span><br><span class="line">        <span class="built_in">snprintf</span>(tmp.name,NAME_SIZE,<span class="string">&quot;std%d&quot;</span>,i);</span><br><span class="line">        tmp.math = rand()%<span class="number">100</span>;</span><br><span class="line">        tmp.chinese = rand()%<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = llist_insert(handler,&amp;tmp,LLIST_FORWARD);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">            <span class="comment">// ERROR 不为0  结束当前进程</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    llist_travel(handler,print_s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id_delete = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> ret = llist_delete(handler,&amp;id_delete, id_cmp);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;delete failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    llist_travel(handler,print_s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 查找id为3</span></span><br><span class="line">    <span class="type">int</span> id = <span class="number">4</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">score_st</span> *<span class="title">data</span>;</span></span><br><span class="line">    data = llistt_find(handler,&amp;id,id_cmp);</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not find!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print_s(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    llist_destory(handler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）CMakeLists-txt-1"><a href="#（4）CMakeLists-txt-1" class="headerlink" title="（4）CMakeLists.txt"></a>（4）CMakeLists.txt</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(doubleLinklist_5 C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(HOME <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 告知程序链接的动态库路径（至关重要）</span></span><br><span class="line"><span class="keyword">link_directories</span>(./lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(doubleLinklist main.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(doubleLinklist libd_link.so)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-顺序栈的实现"><a href="#9-顺序栈的实现" class="headerlink" title="9.顺序栈的实现"></a>9.顺序栈的实现</h4><p>栈 数据结构，先入后出，顺序栈使用数组作为数据区域的存储结构，其 数据结构如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> datatype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 栈的容量</span></span><br><span class="line">    datatype data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;sqstack;</span><br></pre></td></tr></table></figure><p>项目结构目录:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── sqstack</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── sqstack.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libstack_arr.so</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">    └── sqstack.c</span><br></pre></td></tr></table></figure><h5 id="（1）sqstack-h"><a href="#（1）sqstack-h" class="headerlink" title="（1）sqstack.h"></a>（1）sqstack.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> datatype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 栈的容量</span></span><br><span class="line">    datatype data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;sqstack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line">sqstack *<span class="title function_">st_create</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">st_push</span><span class="params">(sqstack *,datatype *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">st_pop</span><span class="params">(sqstack *,datatype *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">st_top</span><span class="params">(sqstack *,datatype *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_travel</span><span class="params">(sqstack *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_destory</span><span class="params">(sqstack *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">st_isempty</span><span class="params">(sqstack *)</span>;</span><br></pre></td></tr></table></figure><h5 id="（2）sqstack-c"><a href="#（2）sqstack-c" class="headerlink" title="（2）sqstack.c"></a>（2）sqstack.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqstack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建栈</span></span><br><span class="line"><span class="comment"> * 成功返回 指向栈的指针  失败 返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sqstack *<span class="title function_">st_create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sqstack *st;</span><br><span class="line">    st = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*st));</span><br><span class="line">    <span class="keyword">if</span>(st == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数据*data 放入栈中</span></span><br><span class="line"><span class="comment"> * 栈满return -1   正常入栈return 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">st_push</span><span class="params">(sqstack *st,datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 栈满</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;top == MAXSIZE <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    st-&gt;data[++st-&gt;top] = *data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈顶元素出栈，并存储 *data中</span></span><br><span class="line"><span class="comment"> * 失败返回-1  成功返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">st_pop</span><span class="params">(sqstack *st,datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (st_isempty(st))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    *data = st-&gt;data[st-&gt;top];</span><br><span class="line">    st-&gt;top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看栈顶元素，并存储 *data中</span></span><br><span class="line"><span class="comment"> * 失败返回-1  成功返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">st_top</span><span class="params">(sqstack *st,datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!st_isempty(st))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    *data = st-&gt;data[st-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从栈底到栈顶 遍历栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_travel</span><span class="params">(sqstack *st)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (st_isempty(st))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=st-&gt;top;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,st-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁 栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_destory</span><span class="params">(sqstack *st)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  若栈为空 return 1  否则 return 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">st_isempty</span><span class="params">(sqstack *st)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）main-c-5"><a href="#（3）main-c-5" class="headerlink" title="（3）main.c"></a>（3）main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqstack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    datatype arr[] = &#123;<span class="number">15</span>,<span class="number">45</span>,<span class="number">20</span>,<span class="number">36</span>&#125;;</span><br><span class="line"></span><br><span class="line">    sqstack *st = st_create();</span><br><span class="line">    <span class="keyword">if</span>(st == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">// 创建失败 中止</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr)<span class="number">-1</span>;i++)</span><br><span class="line">        st_push(st,&amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    st_travel(st);</span><br><span class="line"></span><br><span class="line">    datatype tmp = <span class="number">22</span>;</span><br><span class="line">    <span class="type">int</span> ret = st_push(st,&amp;tmp);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st_push failed. \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        st_travel(st);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    datatype tmp_1;</span><br><span class="line">    <span class="keyword">while</span>(st_pop(st,&amp;tmp_1) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tmp_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    st_destory(st);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）CMakeLists-txt-2"><a href="#（4）CMakeLists-txt-2" class="headerlink" title="（4）CMakeLists.txt"></a>（4）CMakeLists.txt</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.16</span>)</span><br><span class="line">project(arr C)</span><br><span class="line"></span><br><span class="line"># 设置编译标准</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"># 定义可执行文件的输出路径</span><br><span class="line"><span class="built_in">set</span>(HOME $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"># 指定可执行文件的输出路径</span><br><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;)</span><br><span class="line"></span><br><span class="line"># 包含头文件</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line"></span><br><span class="line"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src<span class="comment">/*.c)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置动态(静态)库生成路径</span></span><br><span class="line"><span class="comment">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">add_library(stack_arr SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="comment">add_executable(sqstack main.c)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="comment">target_link_libraries(sqstack stack_arr)</span></span><br></pre></td></tr></table></figure><h4 id="10-链式栈的实现"><a href="#10-链式栈的实现" class="headerlink" title="10.链式栈的实现"></a>10.链式栈的实现</h4><p>链式栈，从之前的变长结构体的双向循环链表进行二次封装</p><p>使用变长结构体的双向循环链表 作为链式栈的底层实现</p><p><strong>项目结构目录:</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── list_stack</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   └── stack.h</span><br><span class="line">│   └── llist.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── liblink_stack.so</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">    └── sqstack.c</span><br><span class="line">    └── llist.c</span><br></pre></td></tr></table></figure><h5 id="（1）llist-h-amp-stack-h"><a href="#（1）llist-h-amp-stack-h" class="headerlink" title="（1）llist.h &amp; stack.h"></a>（1）llist.h &amp; stack.h</h5><p><code>llist.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入模式的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_FORWARD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_BACKWARD 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// llist_op 被定义为 返回值为void 类型 参数为 const void *的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">llist_op</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">llist_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 此处的head 只是一个结构体对象，不是指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> <span class="title">head</span>;</span></span><br><span class="line">&#125;LLIST;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> initsize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llistt_find</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *,llist_op *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * list_head)</span>;</span><br></pre></td></tr></table></figure><p><code>stack.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LLIST STACK;</span><br><span class="line"></span><br><span class="line">STACK  *<span class="title function_">stack_create</span><span class="params">(<span class="type">int</span> initsize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stack_push</span><span class="params">(STACK *ptr,<span class="type">const</span> <span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stack_pop</span><span class="params">(STACK *ptr,<span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stack_destory</span><span class="params">(STACK *ptr)</span>;</span><br></pre></td></tr></table></figure><h5 id="（2）llist-c-amp-stack-c"><a href="#（2）llist-c-amp-stack-c" class="headerlink" title="（2）llist.c &amp; stack.c"></a>（2）llist.c &amp; stack.c</h5><p><code>llist.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/llist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 创建链表</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          init_size: 节点的data内存大小</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> init_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    LLIST *new;</span><br><span class="line"></span><br><span class="line">    new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new));</span><br><span class="line">    <span class="keyword">if</span>(new==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点不存储数据/</span></span><br><span class="line">    new-&gt;size = init_size;</span><br><span class="line">    <span class="comment">// new-&gt;head.data=NULL;</span></span><br><span class="line">    new-&gt;head.pre = &amp;new-&gt;head;</span><br><span class="line">    new-&gt;head.next = &amp;new-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 节点数据的插入</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          data:插入的数据，传入数据的地址</span></span><br><span class="line"><span class="comment"> *          mode:选择插入模式(首部or尾部)</span></span><br><span class="line"><span class="comment"> * return:</span></span><br><span class="line"><span class="comment"> *          是否插入成功</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">new_node</span>;</span></span><br><span class="line"></span><br><span class="line">    new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new_node) + ptr-&gt;size);</span><br><span class="line">    <span class="keyword">if</span>(new_node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new_node-&gt;data = malloc(ptr-&gt;size);</span></span><br><span class="line">    <span class="keyword">if</span>(new_node-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="comment">// 将存储区 data 复制ptr_size个字节数据到存储区 new_node-&gt;data</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_node-&gt;data, data, ptr-&gt;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode == LLIST_FORWARD)&#123;</span><br><span class="line">        <span class="comment">// 首部插入</span></span><br><span class="line">        new_node-&gt;pre = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;next = ptr-&gt;head.next;</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mode == LLIST_BACKWARD)&#123;</span><br><span class="line">        <span class="comment">// 尾部插入</span></span><br><span class="line">        new_node-&gt;pre = ptr-&gt;head.pre;</span><br><span class="line">        new_node-&gt;next = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//ERROR</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> llist_node_st *<span class="title function_">find_</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(key,cur-&gt;data) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回该节点 ，若最后没有找到 cur 当前为ptr-&gt;head,head.data==NULL</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中根据 key 进行查找节点</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          key:链表中查找的key  可以是id 也可以是 name 等，但是要与对应的cmp函数匹配</span></span><br><span class="line"><span class="comment"> *          cmp:比较函数（若为id查找，则在当前迭代的节点中的id 与key相同时，就返回当前节点中的data域）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llistt_find</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将该节点中的data域取出</span></span><br><span class="line">    <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 删除链表中的节点</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    <span class="comment">// free(node-&gt;data);</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中按照key进行查找，并且返回删除的节点数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若给的data指针为NULL，则表示不需要进行data回填</span></span><br><span class="line">    <span class="keyword">if</span>(data!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">memcpy</span>(data,node-&gt;data,ptr-&gt;size);</span><br><span class="line">    <span class="comment">// free(node-&gt;data);</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 遍历链表</span></span><br><span class="line"><span class="comment"> * Note:此处用回调函数(函数指针)实现一个通用型的接口(并不清楚用户定义的数据类型的内部结构)</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr: 链表头节点</span></span><br><span class="line"><span class="comment"> *          llist_op *: 函数指针，指向一个函数，当运行到该段代码时，则运行该函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *ptr,llist_op *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用回调函数</span></span><br><span class="line">        op(cur-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>,*<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = next)</span><br><span class="line">    &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        <span class="comment">// free(cur-&gt;data);</span></span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头节点destory</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stack.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建栈</span></span><br><span class="line"><span class="comment"> * 创建失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">STACK  *<span class="title function_">stack_create</span><span class="params">(<span class="type">int</span> initsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> llist_create(initsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压入栈</span></span><br><span class="line"><span class="comment"> * 压入成功 返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stack_push</span><span class="params">(STACK *ptr,<span class="type">const</span> <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> llist_insert(ptr,data,LLIST_FORWARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">always_match</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p1,<span class="type">const</span> <span class="type">void</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stack_pop</span><span class="params">(STACK *ptr,<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> llist_fetch(ptr,(<span class="type">void</span> *)<span class="number">0</span>,always_match,data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stack_destory</span><span class="params">(STACK *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    llist_destory(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:<code>(void *)0</code>通常可以视作为<code>NULL</code></p><h5 id="（3）main-c-6"><a href="#（3）main-c-6" class="headerlink" title="（3）main.c"></a>（3）main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/llist.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_SIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自定义的结构体数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[NAME_SIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，用户根据自己定义的数据类型进行函数功能定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_s</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d \n&quot;</span>,r-&gt;id,r-&gt;name,r-&gt;math,r-&gt;chinese);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    STACK *st;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建栈</span></span><br><span class="line">    st = stack_create(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> score_st));</span><br><span class="line">    <span class="keyword">if</span> (st == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入栈</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp.id = i;</span><br><span class="line">        <span class="built_in">snprintf</span>(tmp.name,NAME_SIZE,<span class="string">&quot;stu%d&quot;</span>,i);</span><br><span class="line">        tmp.chinese = rand()%<span class="number">100</span>;</span><br><span class="line">        tmp.math = rand()%<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack_push(st,&amp;tmp))</span><br><span class="line">            <span class="comment">// 判断入栈是否成功，失败则中止</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = stack_pop(st,&amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        print_s(&amp;tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）CMakeLists-txt-3"><a href="#（4）CMakeLists-txt-3" class="headerlink" title="（4）CMakeLists.txt"></a>（4）CMakeLists.txt</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.20</span>)</span><br><span class="line">project(list_stack C)</span><br><span class="line"></span><br><span class="line"># 设置编译标准</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"># 定义可执行文件的输出路径</span><br><span class="line"><span class="built_in">set</span>(HOME $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"># 指定可执行文件的输出路径</span><br><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;)</span><br><span class="line"></span><br><span class="line"># 包含头文件</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line"></span><br><span class="line"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src<span class="comment">/*.c)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置动态(静态)库生成路径</span></span><br><span class="line"><span class="comment">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">add_library(link_stack SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="comment">add_executable(list_stack main.c)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="comment">target_link_libraries(list_stack link_stack)</span></span><br></pre></td></tr></table></figure><h4 id="11-顺序存储队列的实现"><a href="#11-顺序存储队列的实现" class="headerlink" title="11.顺序存储队列的实现"></a>11.顺序存储队列的实现</h4><p>队列先入先出</p><p>存在一个队头指针  队尾指针</p><p>每次增加一个元素 入队 队尾指针向后移动一次</p><p>每次减少一个元素 出队 队首指针向后移动一次</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202306251102183.png" alt="image-20230625110219108"></p><p>项目结构目录:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── arr_quene</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── <span class="built_in">queue</span>.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── liba_queue.so</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">    └── sqeue.c</span><br></pre></td></tr></table></figure><h5 id="（1）quene-h"><a href="#（1）quene-h" class="headerlink" title="（1）quene.h"></a>（1）quene.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>  datatype;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    datatype data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> head,tail;</span><br><span class="line">&#125;<span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> * <span class="title function_">qu_create</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">qu_isempty</span><span class="params">(<span class="built_in">queue</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">qu_enqueue</span><span class="params">(<span class="built_in">queue</span> *,datatype *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">qu_dequeue</span><span class="params">(<span class="built_in">queue</span> *,datatype *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qu_travel</span><span class="params">(<span class="built_in">queue</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空队列里面的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qu_clear</span><span class="params">(<span class="built_in">queue</span> * )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qu_destroy</span><span class="params">(<span class="built_in">queue</span> *)</span>;</span><br></pre></td></tr></table></figure><h5 id="（2）quene-c"><a href="#（2）quene-c" class="headerlink" title="（2）quene.c"></a>（2）quene.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> * <span class="title function_">qu_create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span> *sq;</span><br><span class="line"></span><br><span class="line">    sq = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*sq));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sq == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    sq-&gt;head = <span class="number">0</span>;</span><br><span class="line">    sq-&gt;tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列是否为空</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> *  sq:操作的队列指针</span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> *  1:队列为空</span></span><br><span class="line"><span class="comment"> *  0:队列不为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qu_isempty</span><span class="params">(<span class="built_in">queue</span> *sq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq-&gt;head == sq-&gt;tail)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  入队</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> *  sq:操作的队列指针</span></span><br><span class="line"><span class="comment"> *  data:入队的数据指针</span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> *  -1:队满-入队失败</span></span><br><span class="line"><span class="comment"> *  0:入队成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qu_enqueue</span><span class="params">(<span class="built_in">queue</span> *sq,datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 队列满,不允许继续进行入队操作</span></span><br><span class="line">    <span class="keyword">if</span> ((sq-&gt;tail + <span class="number">1</span>) % MAXSIZE == sq-&gt;head)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 循环队列需要取模</span></span><br><span class="line">    sq-&gt;tail = (sq-&gt;tail + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    sq-&gt;data[sq-&gt;tail] = *data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  出队</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> *  sq:操作的队列指针</span></span><br><span class="line"><span class="comment"> *  data:出队回传的数据指针</span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> *  -1:队空-出队失败</span></span><br><span class="line"><span class="comment"> *  0:出队成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qu_dequeue</span><span class="params">(<span class="built_in">queue</span> *sq,datatype *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 队空 出队失败</span></span><br><span class="line">    <span class="keyword">if</span> (qu_isempty(sq))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    sq-&gt;head = (sq-&gt;head + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    *data = sq-&gt;data[sq-&gt;head];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历队列</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> *  sq:操作的队列指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qu_travel</span><span class="params">(<span class="built_in">queue</span> *sq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 队列为空不进行遍历</span></span><br><span class="line">    <span class="keyword">if</span> (qu_isempty(sq))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    i = (sq-&gt;head + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    <span class="keyword">while</span> (i != sq-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sq-&gt;data[i]);</span><br><span class="line">        i = (i+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队尾 存在数据 打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sq-&gt;data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空队列里面的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qu_clear</span><span class="params">(<span class="built_in">queue</span> *sq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将队列首尾进行对等处理（队列就为空）</span></span><br><span class="line">    sq-&gt;head = sq-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qu_destroy</span><span class="params">(<span class="built_in">queue</span> *sq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(sq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）main-c-7"><a href="#（3）main-c-7" class="headerlink" title="（3）main.c"></a>（3）main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建</span></span><br><span class="line">    <span class="built_in">queue</span> *sq;</span><br><span class="line">    datatype arr[<span class="number">6</span>] = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">98</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i,ret;</span><br><span class="line"></span><br><span class="line">    sq = qu_create();</span><br><span class="line">    <span class="keyword">if</span>(sq==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 入队操作</span></span><br><span class="line">        qu_enqueue(sq,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历输出测试</span></span><br><span class="line">    qu_travel(sq);</span><br><span class="line">    <span class="comment">// 再一次遍历测试</span></span><br><span class="line">    datatype tmp = <span class="number">100</span>;</span><br><span class="line">    ret = qu_enqueue(sq,&amp;tmp);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is full!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        qu_travel(sq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队测试</span></span><br><span class="line">    datatype de_tmp;</span><br><span class="line">    ret = qu_dequeue(sq,&amp;de_tmp);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is empty!dequeue failed!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DEQUEUE:%d\n&quot;</span>,de_tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队后 遍历测试</span></span><br><span class="line">    qu_travel(sq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    qu_destroy(sq);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）CMakeLists-txt-4"><a href="#（4）CMakeLists-txt-4" class="headerlink" title="（4）CMakeLists.txt"></a>（4）CMakeLists.txt</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.16</span>)</span><br><span class="line">project(arr_queue C)</span><br><span class="line"></span><br><span class="line"># 设置编译标准</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"># 定义可执行文件的输出路径</span><br><span class="line"><span class="built_in">set</span>(HOME $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"># 指定可执行文件的输出路径</span><br><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;)</span><br><span class="line"></span><br><span class="line"># 包含头文件</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line"></span><br><span class="line"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src<span class="comment">/*.c)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置动态(静态)库生成路径</span></span><br><span class="line"><span class="comment">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">add_library(a_queue SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="comment">add_executable(arr_queue main.c)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="comment">target_link_libraries(arr_queue a_queue)</span></span><br></pre></td></tr></table></figure><h4 id="12-链式存储队列的实现"><a href="#12-链式存储队列的实现" class="headerlink" title="12.链式存储队列的实现"></a>12.链式存储队列的实现</h4><p>链式队列，从之前的变长结构体的双向循环链表进行二次封装</p><p>使用变长结构体的双向循环链表 作为链式队列的底层实现</p><p><strong>项目结构目录:</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── link_queue</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   └── stack.h</span><br><span class="line">│   └── queue.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libl_queue.so</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">    └── queue.c</span><br><span class="line">    └── llist.c</span><br></pre></td></tr></table></figure><h5 id="（1）llist-h-amp-queue-h"><a href="#（1）llist-h-amp-queue-h" class="headerlink" title="（1）llist.h &amp; queue.h"></a>（1）llist.h &amp; queue.h</h5><p><code>llist.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入模式的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_FORWARD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLIST_BACKWARD 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// llist_op 被定义为 返回值为void 类型 参数为 const void *的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">llist_op</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">llist_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 此处的head 只是一个结构体对象，不是指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> <span class="title">head</span>;</span></span><br><span class="line">&#125;LLIST;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> initsize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llistt_find</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *,llist_op *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * list_head)</span>;</span><br></pre></td></tr></table></figure><p><code>queue.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LLIST QUEUE;</span><br><span class="line"></span><br><span class="line">QUEUE *<span class="title function_">qu_create</span><span class="params">(<span class="type">int</span> initsize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">qu_en</span><span class="params">(QUEUE *ptr,<span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">qu_de</span><span class="params">(QUEUE *ptr,<span class="type">void</span> *data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qu_destroy</span><span class="params">(QUEUE *ptr)</span>;</span><br></pre></td></tr></table></figure><h5 id="（2）llist-c-amp-queue-c"><a href="#（2）llist-c-amp-queue-c" class="headerlink" title="（2）llist.c &amp; queue.c"></a>（2）llist.c &amp; queue.c</h5><p><code>llist.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/llist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 创建链表</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          init_size: 节点的data内存大小</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">LLIST * <span class="title function_">llist_create</span><span class="params">(<span class="type">int</span> init_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    LLIST *new;</span><br><span class="line"></span><br><span class="line">    new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new));</span><br><span class="line">    <span class="keyword">if</span>(new==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点不存储数据/</span></span><br><span class="line">    new-&gt;size = init_size;</span><br><span class="line">    <span class="comment">// new-&gt;head.data=NULL;</span></span><br><span class="line">    new-&gt;head.pre = &amp;new-&gt;head;</span><br><span class="line">    new-&gt;head.next = &amp;new-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 节点数据的插入</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          data:插入的数据，传入数据的地址</span></span><br><span class="line"><span class="comment"> *          mode:选择插入模式(首部or尾部)</span></span><br><span class="line"><span class="comment"> * return:</span></span><br><span class="line"><span class="comment"> *          是否插入成功</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_insert</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">new_node</span>;</span></span><br><span class="line"></span><br><span class="line">    new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*new_node) + ptr-&gt;size);</span><br><span class="line">    <span class="keyword">if</span>(new_node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new_node-&gt;data = malloc(ptr-&gt;size);</span></span><br><span class="line">    <span class="keyword">if</span>(new_node-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="comment">// 将存储区 data 复制ptr_size个字节数据到存储区 new_node-&gt;data</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_node-&gt;data, data, ptr-&gt;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode == LLIST_FORWARD)&#123;</span><br><span class="line">        <span class="comment">// 首部插入</span></span><br><span class="line">        new_node-&gt;pre = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;next = ptr-&gt;head.next;</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mode == LLIST_BACKWARD)&#123;</span><br><span class="line">        <span class="comment">// 尾部插入</span></span><br><span class="line">        new_node-&gt;pre = ptr-&gt;head.pre;</span><br><span class="line">        new_node-&gt;next = &amp;(ptr-&gt;head);</span><br><span class="line">        new_node-&gt;pre-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next-&gt;pre = new_node;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//ERROR</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> llist_node_st *<span class="title function_">find_</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(key,cur-&gt;data) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回该节点 ，若最后没有找到 cur 当前为ptr-&gt;head,head.data==NULL</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中根据 key 进行查找节点</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr:链表头节点</span></span><br><span class="line"><span class="comment"> *          key:链表中查找的key  可以是id 也可以是 name 等，但是要与对应的cmp函数匹配</span></span><br><span class="line"><span class="comment"> *          cmp:比较函数（若为id查找，则在当前迭代的节点中的id 与key相同时，就返回当前节点中的data域）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">llistt_find</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将该节点中的data域取出</span></span><br><span class="line">    <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 删除链表中的节点</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_delete</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    <span class="comment">// free(node-&gt;data);</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 在链表中按照key进行查找，并且返回删除的节点数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">llist_fetch</span><span class="params">(LLIST *ptr,<span class="type">const</span> <span class="type">void</span> *key,llist_cmp *cmp,<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    node = find_(ptr,key,cmp);</span><br><span class="line">    <span class="keyword">if</span>(node == &amp;(ptr-&gt;head))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    node -&gt; pre -&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若给的data指针为NULL，则表示不需要进行data回填</span></span><br><span class="line">    <span class="keyword">if</span>(data!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">memcpy</span>(data,node-&gt;data,ptr-&gt;size);</span><br><span class="line">    <span class="comment">// free(node-&gt;data);</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function: 遍历链表</span></span><br><span class="line"><span class="comment"> * Note:此处用回调函数(函数指针)实现一个通用型的接口(并不清楚用户定义的数据类型的内部结构)</span></span><br><span class="line"><span class="comment"> * parameter:</span></span><br><span class="line"><span class="comment"> *          ptr: 链表头节点</span></span><br><span class="line"><span class="comment"> *          llist_op *: 函数指针，指向一个函数，当运行到该段代码时，则运行该函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_travel</span><span class="params">(LLIST *ptr,llist_op *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用回调函数</span></span><br><span class="line">        op(cur-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">llist_destory</span><span class="params">(LLIST * ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node_st</span> *<span class="title">cur</span>,*<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cur = ptr-&gt;head.next; cur != &amp;(ptr-&gt;head); cur = next)</span><br><span class="line">    &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        <span class="comment">// free(cur-&gt;data);</span></span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头节点destory</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>queue.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建队列</span></span><br><span class="line"><span class="comment"> * 创建失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QUEUE *<span class="title function_">qu_create</span><span class="params">(<span class="type">int</span> initsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> llist_create(initsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队</span></span><br><span class="line"><span class="comment"> * 队列尾部插入</span></span><br><span class="line"><span class="comment"> * 返回:</span></span><br><span class="line"><span class="comment"> *  0 则入队成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qu_en</span><span class="params">(QUEUE *ptr,<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 尾部插入</span></span><br><span class="line">    <span class="keyword">return</span> llist_insert(ptr,data,LLIST_BACKWARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">always_match</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p1,<span class="type">const</span> <span class="type">void</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队</span></span><br><span class="line"><span class="comment"> * 队列首部出队</span></span><br><span class="line"><span class="comment"> * 返回:</span></span><br><span class="line"><span class="comment"> *  0 则插入成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qu_de</span><span class="params">(QUEUE *ptr,<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> llist_fetch(ptr,(<span class="type">void</span> *)<span class="number">0</span>,always_match,data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qu_destroy</span><span class="params">(QUEUE *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    llist_destory(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:<code>(void *)0</code>通常可以视作为<code>NULL</code></p><h5 id="（3）main-c-8"><a href="#（3）main-c-8" class="headerlink" title="（3）main.c"></a>（3）main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自定义的结构体数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[NAME_SIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，用户根据自己定义的数据类型进行函数功能定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_s</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *record)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">r</span> =</span> record;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d \n&quot;</span>,r-&gt;id,r-&gt;name,r-&gt;math,r-&gt;chinese);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建</span></span><br><span class="line">    QUEUE *qu;</span><br><span class="line">    qu = qu_create(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> score_st));</span><br><span class="line">    <span class="keyword">if</span>(qu ==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入栈</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp.id = i;</span><br><span class="line">        <span class="built_in">snprintf</span>(tmp.name,NAME_SIZE,<span class="string">&quot;stu%d&quot;</span>,i);</span><br><span class="line">        tmp.chinese = rand()%<span class="number">100</span>;</span><br><span class="line">        tmp.math = rand()%<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qu_en(qu,&amp;tmp))</span><br><span class="line">            <span class="comment">// 判断入栈是否成功，失败则中止</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = qu_de(qu,&amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        print_s(&amp;tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（4）CMakeLists-txt-5"><a href="#（4）CMakeLists-txt-5" class="headerlink" title="（4）CMakeLists.txt"></a>（4）CMakeLists.txt</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.20</span>)</span><br><span class="line">project(list_stack C)</span><br><span class="line"></span><br><span class="line"># 设置编译标准</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"># 定义可执行文件的输出路径</span><br><span class="line"><span class="built_in">set</span>(HOME $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"># 指定可执行文件的输出路径</span><br><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;)</span><br><span class="line"></span><br><span class="line"># 包含头文件</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line"></span><br><span class="line"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src<span class="comment">/*.c)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置动态(静态)库生成路径</span></span><br><span class="line"><span class="comment">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">add_library(l_queue SHARED $&#123;SRC_LIST&#125; )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="comment">add_executable(link_queue main.c)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="comment">target_link_libraries(link_queue l_queue)</span></span><br></pre></td></tr></table></figure><h4 id="13-动态库以及静态库"><a href="#13-动态库以及静态库" class="headerlink" title="13.动态库以及静态库"></a>13.动态库以及静态库</h4><h5 id="（1）静态库"><a href="#（1）静态库" class="headerlink" title="（1）静态库"></a>（1）静态库</h5><p><code>libxx.a</code></p><p>xx 指代库名</p><p>可是使用<code>gcc</code>命令将.o（目标文件<code>gcc -c xx.c -o xx.o</code>）文件编译为静态库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -cr libxx.a  yyy.o</span><br></pre></td></tr></table></figure><p>发布到<code>linux</code>系统下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp xx.h /usr/local/include    # 头文件</span><br><span class="line">cp libxx.a /usr/local/lib     # 静态库</span><br></pre></td></tr></table></figure><p><code>gcc</code>命令行链接静态库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -lxx   <span class="meta"># main 生成的目标文件名字  main.c为生成main所依赖的文件  -lxx  -l 为链接的意思 xx 为库名</span></span><br><span class="line">    或者</span><br><span class="line">gcc -L /usr/local/lib -o main main.c -lxx   # -L /usr/local/li 为链接库文件的路径</span><br></pre></td></tr></table></figure><p>此时可以通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd ./xx   # 查看xx目标文件所依赖的库</span><br></pre></td></tr></table></figure><h5 id="（2）动态库"><a href="#（2）动态库" class="headerlink" title="（2）动态库"></a>（2）动态库</h5><p><code>libxx.so</code></p><p>使用<code>gcc</code> 生成动态库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libxx.so yyy.c    # -yyy.c 为动态库所依赖的c文件</span><br></pre></td></tr></table></figure><p><code>-fpic</code>为<strong>位置无关代码</strong></p><p>发布到<code>linux</code>系统下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp xx.h /usr/local/include    # 头文件</span><br><span class="line">cp libxx.so /usr/local/lib     # 动态库</span><br></pre></td></tr></table></figure><p><strong>动态库需要在<code>/etc/lb.so.confg</code>中添加路径</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /etc/lib.so.confg 文件下添加动态库路径</span><br><span class="line">/usr/local/lib/</span><br></pre></td></tr></table></figure><p>添加路径之后，需要在终端中使用命令<strong>重读刚刚修改的配置文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /sbin/ldconfg  # /etc/lib.so.confg 配置文件</span><br></pre></td></tr></table></figure><p>编译调用链接库的<code>.c</code>文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -I /usr/local/include/ -L /usr/local/lib -o main main.c -lxx</span><br><span class="line"># -I 后引出动态库所需要的头文件路径</span><br><span class="line"># -L 后引出动态库所需要的库文件路径</span><br><span class="line"><span class="meta"># main 为main.c所生成的目标文件 -lxx xx文件为动态库库名</span></span><br></pre></td></tr></table></figure><p>当一个目录下存在<strong>重名</strong>的动态库以及静态库则会<strong>优先链接动态库</strong></p><p>非<code>root</code>用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp xx.so ~/lib </span><br><span class="line">export LD_LIBRARY_PATH = ~/lib</span><br></pre></td></tr></table></figure><p><strong>当链接的多个库彼此之间存在链接关系时</strong>，如 生成main目标文件时，需要依赖<code>libx.a</code> 但是<code>libx.a</code>有需要依赖 <code>liby.a</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -lx -ly   # 被依赖的库写在后面</span><br></pre></td></tr></table></figure><h4 id="14-树状存储"><a href="#14-树状存储" class="headerlink" title="14.树状存储"></a>14.树状存储</h4><h5 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h5><p>二叉树的顺序存储非常浪费空间</p><p>二叉树链式存储，包含左孩子指针与右孩子指针</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307021546252.png" alt="image-20230702154614221"></p><p><strong>遍历方式</strong></p><p>按层序遍历、先序、后序 、中序</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307021626325.png" alt="image-20230702162603276"></p><h5 id="（2）二叉树的链式存储实现"><a href="#（2）二叉树的链式存储实现" class="headerlink" title="（2）二叉树的链式存储实现"></a>（2）二叉树的链式存储实现</h5><p>插入数据方式：遍历数组，小的数字放在左节点 大的节点放在右节点</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202307021630455.png" alt="image-20230702163004396"></p><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[NAMESIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span>  <span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">l</span>,*<span class="title">r</span>;</span> <span class="comment">// 左孩子指针，右孩子指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入数据方式：遍历数组，比较data中的id,小的数字放在左节点 大的节点放在右节点</span></span><br><span class="line"><span class="comment"> * 递归插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="keyword">struct</span> node_st **root,<span class="keyword">struct</span> score_st *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="comment">// 当其递归到的叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (*root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">        <span class="keyword">if</span>(node ==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        node-&gt;data = *data;</span><br><span class="line">        node-&gt;l = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当其创建的节点 地址赋值给 根节点指针</span></span><br><span class="line">        *root = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(data-&gt;id &lt;= (*root)-&gt;data.id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归插入</span></span><br><span class="line">        <span class="keyword">return</span> insert(&amp;((*root)-&gt;l),data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> insert(&amp;((*root)-&gt;r),data);;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> score_st *<span class="title function_">find</span><span class="params">(<span class="keyword">struct</span> node_st *root,<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 若当前递归到的叶子节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="keyword">if</span> (id == root-&gt;data.id)</span><br><span class="line">        <span class="keyword">return</span> &amp;(root-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若id比当前节点的id小的话，就在左子树去找</span></span><br><span class="line">    <span class="keyword">if</span>(id &lt; root-&gt;data.id)</span><br><span class="line">        <span class="keyword">return</span> find(root-&gt;l,id);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> find(root-&gt;r,id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，用户根据自己定义的数据类型进行函数功能定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_s</span><span class="params">(<span class="keyword">struct</span> score_st *d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d \n&quot;</span>,d-&gt;id,d-&gt;name,d-&gt;math,d-&gt;chinese);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">tree</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">score_st</span> *<span class="title">datap</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp.id = arr[i];</span><br><span class="line">        <span class="built_in">snprintf</span>(tmp.name,NAMESIZE,<span class="string">&quot;stu%d&quot;</span>,arr[i]);</span><br><span class="line">        tmp.math = rand()%<span class="number">100</span>;</span><br><span class="line">        tmp.chinese = rand()%<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入数据</span></span><br><span class="line">        insert(&amp;tree,&amp;tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmpid = <span class="number">2</span>;</span><br><span class="line">    datap = find(tree,tmpid);</span><br><span class="line">    <span class="keyword">if</span> (datap == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not find the id %d\n&quot;</span>,tmpid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print_s(datap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(Btree C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(Btree main.c)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake保姆级编程</title>
      <link href="/2023/06/11/%E5%B5%8C%E5%85%A5%E5%BC%8F/C%E5%8A%A0%E5%8A%A0/CMake%E4%BF%9D%E5%A7%86%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/06/11/%E5%B5%8C%E5%85%A5%E5%BC%8F/C%E5%8A%A0%E5%8A%A0/CMake%E4%BF%9D%E5%A7%86%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="CMake保姆级编程"><a href="#CMake保姆级编程" class="headerlink" title="CMake保姆级编程"></a>CMake保姆级编程</h2><p>文档来源：爱编程的大丙</p><p><a href="https://www.bilibili.com/video/BV14s4y1g7Zj/?p=5&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=067ebd6dc341bd1510dcebb3d63bb5bd">视频链接</a></p><p><a href="https://subingwen.cn/cmake/CMake-primer/"><code>CMake</code>保姆级变成(上)</a></p><p><a href="https://subingwen.cn/cmake/CMake-advanced/"><code>CMake</code>保姆级变成(下)</a></p><p><code>ubuntu</code>下查看<code>cmake</code>版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 终端输入</span><br><span class="line">cmake --version</span><br></pre></td></tr></table></figure><h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><h4 id="1-源文件与CmakeLists-txt均在一个目录下"><a href="#1-源文件与CmakeLists-txt均在一个目录下" class="headerlink" title="1.源文件与CmakeLists.txt均在一个目录下"></a>1.源文件与<code>CmakeLists.txt</code>均在一个目录下</h4><p>文件下的目录结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── head.h</span><br><span class="line">├── a.c</span><br><span class="line">├── b.c</span><br><span class="line">└── main.c</span><br></pre></td></tr></table></figure><p>所有源码全部放在一个文件夹下,在该目录下编写<code>CmakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)    <span class="comment"># 工程名字可以与可执行程序名不一样</span></span><br><span class="line"><span class="keyword">add_executable</span>(app a.c b.c main.c)</span><br></pre></td></tr></table></figure><ul><li><p><code>cmake_minimum_required</code>：指定使用的 <code>cmake</code> 的最低版本</p></li><li><p><code>project</code>：定义工程名称</p></li><li><p><code>add_executable</code>：定义工程会生成一个可执行程序</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行程序名 源文件名称)</span><br></pre></td></tr></table></figure><p>在<code>CMakeLists.txt</code>同级目录下终端打开输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure><p>当执行<code>cmake</code>命令之后，<code>CMakeLists.txt </code>中的命令就会被执行，所以一定要注意给<code> cmake</code> 命令指定路径的时候一定不能出错</p><p>执行命令之后，看一下源文件所在目录中是否多了一些文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── CMakeCache.txt         # new add file</span><br><span class="line">├── CMakeFiles             # new add dir</span><br><span class="line">├── cmake_install.cmake    # new add file</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── head.h</span><br><span class="line">├── a.c</span><br><span class="line">├── b.c</span><br><span class="line">├── main.c</span><br><span class="line">└── Makefile               # new add file</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 可以通过创建一个<code>build</code>目录，在<code>build</code>目录与<code>CmakeLists.txt</code>文件同级，在build目录下终端输入<code>cmake ..</code>,则<code>cmake</code>产生的中间文件均会放在<code>build</code>目录下</p><p>我们可以看到在对应的目录下生成了一个<code> makefile</code> 文件，此时再执行<code> make</code> 命令，就可以对项目进行构建得到所需的可执行程序了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">Scanning dependencies of target app</span><br><span class="line">[ 16%] Building C object CMakeFiles/app.dir/add.c.o</span><br><span class="line">[ 33%] Building C object CMakeFiles/app.dir/div.c.o</span><br><span class="line">[ 50%] Building C object CMakeFiles/app.dir/main.c.o</span><br><span class="line">[ 66%] Building C object CMakeFiles/app.dir/mult.c.o</span><br><span class="line">[ 83%] Building C object CMakeFiles/app.dir/sub.c.o</span><br><span class="line">[100%] Linking C executable app</span><br><span class="line">[100%] Built target app</span><br></pre></td></tr></table></figure><h4 id="2-定义变量set"><a href="#2-定义变量set" class="headerlink" title="2.定义变量set"></a>2.定义变量set</h4><p>假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在 <code>cmake</code> 里定义变量需要使用 <code>set</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SET 指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项, 如不需要可以不写</span></span><br><span class="line"><span class="keyword">SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])<span class="comment"># SET 指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项, 如不需要可以不写</span></span><br><span class="line"><span class="keyword">SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br></pre></td></tr></table></figure><ul><li>VAR：变量名</li><li>VALUE：变量值</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如下实例</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST ac  B.c   main.c)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h5 id="（1）使用c-标准"><a href="#（1）使用c-标准" class="headerlink" title="（1）使用c++标准"></a>（1）使用c++标准</h5><p>在编写 C++ 程序的时候，可能会用到<code> C++11、C++14、C++17、C++20</code> 等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准,终端命令行直接输入：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ *.cpp -std=c++<span class="number">11</span> -o app</span><br></pre></td></tr></table></figure><p>上面的例子中通过参数 <code>-std=c++11</code> 指定出要使用<code>c++11</code>标准编译程序，<code>C++ </code>标准对应有一宏叫做<code> DCMAKE_CXX_STANDARD</code>。在<code> CMake</code> 中想要指定<code> C++</code> 标准有两种方式：</p><ul><li>在 <code>CMakeLists.txt</code> 中通过<code>set</code>命令指定</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加-std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">#增加-std=c++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="comment">#增加-std=c++17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br></pre></td></tr></table></figure><ul><li>在执行 <code>cmake </code>命令的时候指定出这个宏的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#增加-<span class="built_in">std</span>=c++<span class="number">11</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">11</span></span><br><span class="line">#增加-<span class="built_in">std</span>=c++<span class="number">14</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">14</span></span><br><span class="line">#增加-<span class="built_in">std</span>=c++<span class="number">17</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">17</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># c99 标准  CMakeLists.txt 在上一级目录下</span><br><span class="line">cmake .. -DCMAKE_C_STANDARD=<span class="number">99</span></span><br></pre></td></tr></table></figure><h5 id="（2）指定输出的路径"><a href="#（2）指定输出的路径" class="headerlink" title="（2）指定输出的路径"></a>（2）指定输出的路径</h5><p>在<code> CMake</code> 中指定可执行程序输出的路径，也对应一个宏，叫做 <code>EXECUTABLE_OUTPUT_PATH</code>，它的值还是通过 <code>set </code>命令进行设置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(HOME /home/zxz/Proj/CLionProj/Linux_C/Point/bin)</span><br><span class="line"># set(HOME ../bin)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;)</span><br></pre></td></tr></table></figure><ul><li>第一行：定义一个变量用于存储一个绝对路径（也可以创建相对路径，<code>bin，build</code>目录与<code>CMakeLists.txt</code>同级，在build目录下执行<code>cmake ..</code>）</li><li>第二行：将拼接好的路径值设置给 EXECUTABLE_OUTPUT_PATH 宏<ul><li>如果这个路径中的子目录不存在，会自动生成，无需自己手动创建</li></ul></li></ul><p>由于可执行程序是基于<code> cmake</code> 命令生成的 makefile 文件然后再执行<code> make</code> 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径<code> ./xxx/xxx</code>，那么这个路径中的<code>./</code>对应的就是<code>makefile</code>文件所在的那个目录。</p><h4 id="3-搜索文件"><a href="#3-搜索文件" class="headerlink" title="3.搜索文件"></a>3.搜索文件</h4><p>如果一个项目里边的源文件很多，在编写<code>CMakeLists.txt</code>文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在<code>CMake</code>中为我们提供了搜索文件的命令，可以使用<code>aux_source_directory</code>命令或者 <code>file </code>命令。</p><h5 id="（1）aux-source-directory"><a href="#（1）aux-source-directory" class="headerlink" title="（1）aux_source_directory"></a>（1）<code>aux_source_directory</code></h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt; dir &gt; &lt; variable &gt;)</span><br></pre></td></tr></table></figure><ul><li><p><code>dir</code>：要搜索的目录</p></li><li><p><code>variable</code>：将从 <code>dir </code>目录下搜索到的源文件列表存储到该变量中</p></li></ul><p><strong>实例项目</strong>:</p><p>项目目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/CMake_Demo/De2$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── De2</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   └── head.h</span><br><span class="line">└── src</span><br><span class="line">    ├── a.cpp</span><br><span class="line">    ├── b.cpp</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p><code>head.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DE1_HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DE1_HEAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//DE1_HEAD_H</span></span></span><br></pre></td></tr></table></figure><p><code>a.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>b.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>,b=<span class="number">15</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;the sum = &quot;</span> &lt;&lt; <span class="built_in">add</span>(a,b) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;the sub = &quot;</span> &lt;&lt; <span class="built_in">sub</span>(a,b) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>CMakeLists.txt</code></strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">PROJECT</span>(De2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(HOME <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake 是输出一般信息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_SOURCE_DIR = $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_CURRENT_SOURCE_DIR = $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(De2 <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>$&#123;PROJECT_SOURCE_DIR&#125;</code>是指最近包含<code>PROJECT()</code>语句的<code>CMakeLists.txt</code>所在的目录，如上的<code>CMakeLists.txt</code>中不包含了<code>PROJECT(De2)</code>语句，而<code>CMakeLists.txt</code>所在的目录是<code>~/Proj/CLionProj/CMake_Demo/De2</code></li><li><code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</code>这是<code>cmake</code>当前正在处理的源目录的完整路径,在该程序中，在<code>build</code>目录下终端输入<code>cmake ..</code>处理的是<code>build</code>的上级目录下的<code>CMakeLists.txt</code>文件，则此处的<code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</code>也是和而<code>CMakeLists.txt</code>所在的目录一致</li></ul><p>在build目录下终端输入:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cmake ..</span><br><span class="line">PROJECT_SOURCE_DIR = /home/zxz/Proj/CLionProj/CMake_Demo/De2</span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR = /home/zxz/Proj/CLionProj/CMake_Demo/De2</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/zxz/Proj/CLionProj/CMake_Demo/De2/build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ make </span><br><span class="line">[ <span class="number">25</span>%] Building CXX object CMakeFiles/De2.dir/src/a.cpp.o</span><br><span class="line">[ <span class="number">50</span>%] Building CXX object CMakeFiles/De2.dir/src/b.cpp.o</span><br><span class="line">[ <span class="number">75</span>%] Building CXX object CMakeFiles/De2.dir/src/main.cpp.o</span><br><span class="line">[<span class="number">100</span>%] Linking CXX executable ../bin/De2</span><br><span class="line">[<span class="number">100</span>%] Built <span class="keyword">target</span> De2</span><br></pre></td></tr></table></figure><p>在<code>bin</code>目录下可以找到可执行文件<code>De2</code></p><h5 id="（2）file"><a href="#（2）file" class="headerlink" title="（2）file"></a>（2）<code>file</code></h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br></pre></td></tr></table></figure><ul><li><code>GLOB</code>: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中</li><li><code>GLOB_RECURSE</code>：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中</li></ul><p>搜索当前目录的 src 目录下所有的源文件，并存储到变量中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure><ul><li><p><code>CMAKE_CURRENT_SOURCE_DIR </code>宏表示当前访问的 <code>CMakeLists.txt </code>文件所在的路径</p></li><li><p>关于要搜索的文件路径和类型可加双引号，也可不加:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB MAIN_HEAD &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h&quot;)</span><br></pre></td></tr></table></figure><h4 id="4-包含头文件"><a href="#4-包含头文件" class="headerlink" title="4.包含头文件"></a>4.包含头文件</h4><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在<code>CMake</code>中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是 <code>include_directories</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(headpath)</span><br></pre></td></tr></table></figure><p><strong>实例项目</strong></p><p>项目目录结构：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/CMake_Demo/De2$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── De2</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   └── head.h</span><br><span class="line">└── src</span><br><span class="line">    ├── a.cpp</span><br><span class="line">    ├── b.cpp</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>需要在<code>CMakeLists.txt</code>中添加语句，指定头文件路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><ul><li><code>$&#123;PROJECT_SOURCE_DIR&#125;</code>是指最近包含<code>PROJECT()</code>语句的<code>CMakeLists.txt</code>所在的目录</li></ul><h4 id="5-制作动态库或静态库"><a href="#5-制作动态库或静态库" class="headerlink" title="5.制作动态库或静态库"></a>5.制作动态库或静态库</h4><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在<code>cmake</code>中生成这两类库文件的方法</p><h5 id="（1）制作静态库"><a href="#（1）制作静态库" class="headerlink" title="（1）制作静态库"></a>（1）制作静态库</h5><p>在<code>cmake</code>中，如果要制作静态库，需要使用的命令如下,关键字<code>STATIC</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(库名称 STATIC 源文件1 [源文件2] ...) </span><br></pre></td></tr></table></figure><p>在Linux中，静态库名字分为三部分：<code>lib</code>+<code>库名字</code>+<code>.a</code>，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充</p><p><strong>实例项目</strong>:将<code>src</code>中的源文件编译成静态库</p><p><strong>项目目录结构</strong>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/CMake_Demo/De4$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp</span><br><span class="line">└── src</span><br><span class="line">    ├── a.cpp</span><br><span class="line">    └── b.cpp</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> directories, <span class="number">5</span> files</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将SRC_LIST中的源文件制作为 静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>这样最终就会生成对应的静态库文件<code>libcalc.a</code></p><h5 id="（2）制作动态库"><a href="#（2）制作动态库" class="headerlink" title="（2）制作动态库"></a>（2）制作动态库</h5><p>在<code>cmake</code>中，如果要制作动态库，需要使用的命令如下,关键字<code>SHARED</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 SHARED 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br></pre></td></tr></table></figure><p>在Linux中，动态库名字分为三部分：<code>lib</code>+<code>库名字</code>+<code>.so</code>，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充</p><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h5 id="（3）指定输出路径"><a href="#（3）指定输出路径" class="headerlink" title="（3）指定输出路径"></a>（3）指定输出路径</h5><h6 id="方式1-适用动态库"><a href="#方式1-适用动态库" class="headerlink" title="方式1-适用动态库"></a>方式1-适用动态库</h6><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。<code>由于在Linux下生成的动态库默认是有执行权限的</code>，所以可以按照生成可执行程序的方式去指定它生成的目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置动态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>通过<code>set</code>命令给<code>EXECUTABLE_OUTPUT_PATH</code>宏设置了一个路径，这个路径就是可执行文件生成的路径</p><h6 id="方式2-动静态库均适用-一般用这个"><a href="#方式2-动静态库均适用-一般用这个" class="headerlink" title="方式2-动静态库均适用(一般用这个)"></a>方式2-动静态库均适用(一般用这个)</h6><p>由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用<code>EXECUTABLE_OUTPUT_PATH</code>宏了，而应该使用<code>LIBRARY_OUTPUT_PATH</code>，这个宏对应静态库文件和动态库文件都适用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置动态(静态)库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="6-包含库文件"><a href="#6-包含库文件" class="headerlink" title="6.包含库文件"></a>6.包含库文件</h4><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，<code>cmake</code>中也为我们提供了相关的加载动态库的命令</p><h5 id="（1）链接静态库"><a href="#（1）链接静态库" class="headerlink" title="（1）链接静态库"></a>（1）链接静态库</h5><p><strong>项目目录结构</strong>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) zxz@zxz-B660M-GAMING-X-AX-DDR4:~/Proj/CLionProj/CMake_Demo/De4$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp</span><br><span class="line">└── src</span><br><span class="line">    ├── a.cpp</span><br><span class="line">    └── b.cpp</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> directories, <span class="number">5</span> files</span><br></pre></td></tr></table></figure><p>将<code>src</code>目录下的<code>a.cpp</code>、<code>b.cpp</code>编译成静态库文件</p><p>链接静态库命令如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br></pre></td></tr></table></figure><ul><li><strong>参数1</strong>：指定出要链接的静态库的名字<ul><li>可以是全名 <code>libxxx.a</code></li><li>也可以是掐头（<code>lib</code>）去尾（<code>.a</code>）之后的名字 <code>xxx</code></li></ul></li><li><strong>参数2-N</strong>：要链接的其它静态库的名字</li></ul><p><strong>或者</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种方式需要 放到 add_executable(De3 main.cpp) 之后 </span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(可执行文件名 静态库名)</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数2</strong>：指定出要链接的静态库的名字</p><ul><li><p>可以是全名 <code>libxxx.a</code></p></li><li><p>也可以是掐头（<code>lib</code>）去尾（<code>.a</code>）之后的名字 <code>xxx</code></p></li></ul></li></ul><p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(De3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(HOME <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake 是输出一般信息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_SOURCE_DIR = $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_CURRENT_SOURCE_DIR = $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将SRC_LIST中的源文件制作为 静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(do STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 包含静态库路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 为最后生成的可执行文件链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(do)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(De3 main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="comment">#target_link_libraries(De3 do)</span></span><br></pre></td></tr></table></figure><p>在<code>build</code>目录下打开终端，输入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cmake ..</span><br><span class="line">PROJECT_SOURCE_DIR = /home/zxz/Proj/CLionProj/CMake_Demo/De4</span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR = /home/zxz/Proj/CLionProj/CMake_Demo/De4</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/zxz/Proj/CLionProj/CMake_Demo/De4/build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ make</span><br><span class="line">Scanning dependencies of <span class="keyword">target</span> do</span><br><span class="line">[ <span class="number">20</span>%] Building CXX object CMakeFiles/do.dir/src/a.cpp.o</span><br><span class="line">[ <span class="number">40</span>%] Building CXX object CMakeFiles/do.dir/src/b.cpp.o</span><br><span class="line">[ <span class="number">60</span>%] Linking CXX static library ../lib/libdo.a</span><br><span class="line">[ <span class="number">60</span>%] Built <span class="keyword">target</span> do</span><br><span class="line">Scanning dependencies of <span class="keyword">target</span> De3</span><br><span class="line">[ <span class="number">80</span>%] Building CXX object CMakeFiles/De3.dir/main.cpp.o</span><br><span class="line">[<span class="number">100</span>%] Linking CXX executable ../bin/De3</span><br><span class="line">[<span class="number">100</span>%] Built <span class="keyword">target</span> De3</span><br></pre></td></tr></table></figure><p><strong>此时的项目目录结构</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── De3</span><br><span class="line">├── build</span><br><span class="line">│  └── .....(此处省略)</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libdo.a</span><br><span class="line">├── main.cpp</span><br><span class="line">└── src</span><br><span class="line">    ├── a.cpp</span><br><span class="line">    └── b.cpp</span><br></pre></td></tr></table></figure><h5 id="（2）链接动态库"><a href="#（2）链接动态库" class="headerlink" title="（2）链接动态库"></a>（2）链接动态库</h5><p>在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库，关于动态库的制作、使用以及在内存中的加载方式和静态库都是不同的</p><p><a href="https://subingwen.cn/linux/library/">Linux静态库与动态库</a></p><p>在<code>CMake</code>中链接动态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    &lt;<span class="keyword">target</span>&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure><ul><li><p><code>target</code>：指定要加载动态库的文件的名字</p><ul><li>该文件可能是一个源文件</li><li>该文件可能是一个动态库文件</li><li>该文件可能是一个可执行文件</li></ul></li><li><p><code>PRIVATE|PUBLIC|INTERFACE</code>：动态库的访问权限，默认为 <code>PUBLIC</code></p><ul><li><p>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可</p></li><li><p>动态库的链接具有传递性，如果动态库 A 链接了动态库 B、C，动态库 D 链接了动态库 A，此时动态库 D 相当于也链接了动态库 B、C，并可以使用动态库 B、C 中定义的方法</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(A B C)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(D A)</span><br></pre></td></tr></table></figure><ul><li><p><code>PUBLIC</code>：在 <code>public</code> 后面的库会被 Link 到前面的<code>target </code>中，并且里面的符号也会被导出，提供给第三方使用</p></li><li><p><code>PRIVATE</code>：在 <code>private </code>后面的库仅被 link 到前面的 <code>target</code> 中，并且终结掉，第三方不能感知你调了啥库</p></li><li><p><code>INTERFACE</code>：在 <code>interface </code>后面引入的库不会被链接到前面的 <code>target </code>中，只会导出符号</p></li></ul></li></ul><h6 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h6><p>动态库的链接和静态库是完全不同的：</p><ul><li><strong>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了</strong></li><li>动态库在生成可执行程序的链接阶段<strong>不会</strong>被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</li><li>静态库的扩展名一般为<code>.a</code>或<code>.lib</code>；动态库的扩展名一般为<code>.so</code>或<code>.dll</code></li><li>动态库（共享库）在编译时不会放到连接的目标程序中，即<strong>可执行文件无法单独运行</strong>。(缺少动态库生成的可执行文件无法运行)</li></ul><p>因此，在<code>cmake</code>中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(De5)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(HOME <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake 是输出一般信息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_SOURCE_DIR = $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_CURRENT_SOURCE_DIR = $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件,并且存储值SRC_LIST中(数组)</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将SRC_LIST中的源文件制作为 动态库  关键词 SHARED</span></span><br><span class="line"><span class="keyword">add_library</span>(do SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 包含静态库路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(De5 main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接动态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(De5 do)</span><br></pre></td></tr></table></figure><p>在 <code>target_link_libraries(De5 do) </code>中：</p><ul><li><code>app</code>: 对应的是最终生成的可执行程序的名字</li><li><code>do</code>：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为 libdo.so，在指定的时候一般会掐头（lib）去尾（.so）。</li></ul><p>在<code>build</code>目录下终端输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cmake ..</span><br><span class="line">PROJECT_SOURCE_DIR = /home/zxz/Proj/CLionProj/CMake_Demo/De5</span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR = /home/zxz/Proj/CLionProj/CMake_Demo/De5</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/zxz/Proj/CLionProj/CMake_Demo/De5/build</span><br><span class="line"></span><br><span class="line">$ make</span><br><span class="line">Scanning dependencies of target <span class="keyword">do</span></span><br><span class="line">[ <span class="number">20</span>%] Building CXX object CMakeFiles/<span class="keyword">do</span>.dir/src/a.cpp.o</span><br><span class="line">[ <span class="number">40</span>%] Building CXX object CMakeFiles/<span class="keyword">do</span>.dir/src/b.cpp.o</span><br><span class="line">[ <span class="number">60</span>%] Linking CXX shared library ../lib/libdo.so</span><br><span class="line">[ <span class="number">60</span>%] Built target <span class="keyword">do</span></span><br><span class="line">Scanning dependencies of target De5</span><br><span class="line">[ <span class="number">80</span>%] Building CXX object CMakeFiles/De5.dir/main.cpp.o</span><br><span class="line">[<span class="number">100</span>%] Linking CXX executable ../bin/De5</span><br><span class="line">[<span class="number">100</span>%] Built target De5</span><br></pre></td></tr></table></figure><p><strong>此时的项目目录结构</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   ├── De4</span><br><span class="line">│   └── De5</span><br><span class="line">├── build</span><br><span class="line">│  └── .....(此处省略)</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libdo.so</span><br><span class="line">├── main.cpp</span><br><span class="line">└── src</span><br><span class="line">    ├── a.cpp</span><br><span class="line">    └── b.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（3）链接第三方库"><a href="#（3）链接第三方库" class="headerlink" title="（3）链接第三方库"></a>（3）链接第三方库</h5><p>可以同时链接 自己编写的动态库以及第三方库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(De5 pthread)</span><br></pre></td></tr></table></figure><p>上面的可执行文件<code>De5</code>链接了第三方的动态库 <code>pthread</code>线程库</p><p>但是当我们运行可执行文件时 <code>./De5</code>,可能回报错，具体情况百度即可</p><p>有一些情况是因为我们没有将链接的动态库路径告知我们的程序，下面的语句可以在<code>CMake</code>中导入动态(静态)库路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(path)</span><br></pre></td></tr></table></figure><h4 id="7-日志"><a href="#7-日志" class="headerlink" title="7.日志"></a>7.日志</h4><p>在<code>CMakeLists.txt</code>中可以添加消息（日志）输出语句，在<code>cmake</code>是会输出在控制台</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure><ul><li><code>(无) </code>：重要消息</li><li><code>STATUS</code> ：非重要消息</li><li><code>WARNING：CMake</code> 警告，会继续执行</li><li><code>AUTHOR_WARNING：CMake</code> 警告 (<code>dev</code>), 会继续执行</li><li><code>SEND_ERROR</code>：<code>CMake </code>错误，继续执行，但是会跳过生成的步骤</li><li><code>FATAL_ERROR</code>：<code>CMake</code> 错误，终止所有处理过程</li></ul><p><code>CMake </code>的命令行工具会在<code>stdout</code>上显示 <code>STATUS</code> 消息，在 <code>stderr </code>上显示其他所有消息。<code>CMake</code> 的 GUI 会在它的 log 区域显示所有消息。</p><p><code>CMake</code> 警告和错误消息的文本显示使用的是一种简单的标记语言,文本没有缩进,段落之间以新行做为分隔符</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出一般日志信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出警告信息</span></span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出错误信息</span></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="8-变量操作"><a href="#8-变量操作" class="headerlink" title="8.变量操作"></a>8.变量操作</h4><p>有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过<code> file</code> 命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用<code> set</code> 命令也可以使用 <code>list </code>命令</p><h5 id="（1）使用set进行拼接"><a href="#（1）使用set进行拼接" class="headerlink" title="（1）使用set进行拼接"></a>（1）使用set进行拼接</h5><p>使用<code>set</code>对变量名进行拼接，如下语句</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(变量名<span class="number">1</span> <span class="variable">$&#123;变量名1&#125;</span> <span class="variable">$&#123;变量名2&#125;</span> ...)</span><br></pre></td></tr></table></figure><p>关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">set</span>(SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span>)</span><br></pre></td></tr></table></figure><h5 id="（2）使用list进行拼接"><a href="#（2）使用list进行拼接" class="headerlink" title="（2）使用list进行拼接"></a>（2）使用list进行拼接</h5><p>使用<code>list</code>对变量名进行拼接，如下语句</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure><p><code>list </code>命令的功能比<code>set</code>要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，<code>APPEND </code>表示进行数据追加，后边的参数和 <code>set</code> 就一样了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/src1/*.cpp)</span><br><span class="line">file(GLOB SRC_2 $&#123;PROJECT_SOURCE_DIR&#125;/src2/*.cpp)</span><br><span class="line"># 追加(拼接)</span><br><span class="line">list(APPEND SRC_1 $&#123;SRC_1&#125; $&#123;SRC_2&#125;)</span><br></pre></td></tr></table></figure><p>在<code>CMake</code>中，使用 <code>set </code>命令可以创建一个<code> list</code>。<code>set(var a b c d e) </code>命令将会创建一个<code> list a b c d e</code>，但是最终打印变量值的时候得到的是 <code>abcde</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(tmp1 a b c d e)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;tmp1&#125;</span>)</span><br></pre></td></tr></table></figure><p><strong>控制台输出</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br></pre></td></tr></table></figure><h5 id="（3）list字符串移除"><a href="#（3）list字符串移除" class="headerlink" title="（3）list字符串移除"></a>（3）list字符串移除</h5><p>我们在通过 file 搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的，比如</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── a.cpp</span><br><span class="line">├── b.cpp</span><br><span class="line">└── main.cpp</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> directories, <span class="number">3</span> files</span><br></pre></td></tr></table></figure><p>在当前这么目录有五个源文件，其中<code> main.cpp</code> 是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要<code> a.cpp</code>、<code>b.cpp</code> 这两个源文件就可以了。此时，就需要将<code>main.cpp</code>搜索到的数据中剔除出去，想要实现这个功能，也可以使用 <code>list</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure><p>通过上面的命令原型可以看到删除和追加数据类似，只不过是第一个参数变成了 <code>REMOVE_ITEM</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 移除 main.cpp</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)</span><br></pre></td></tr></table></figure><p>移除的文件的名字指定给<code>list</code>就可以了。<strong>但是一定要注意通过<code> file</code> 命令搜索源文件的时候得到的是文件的绝对路径（在<code> list</code> 中每个文件对应的路径都是一个<code> item</code>，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以</strong>，否则移除操作不会成功</p><h5 id="（4）list的其他操作"><a href="#（4）list的其他操作" class="headerlink" title="（4）list的其他操作"></a>（4）list的其他操作</h5><p>获取<code>list</code>列表的长度、读取列表中指定索引的的元素，可以指定多个索引、将列表中的元素用连接符（字符串）连接起来组成一个字符串等…</p><p><a href="https://subingwen.cn/cmake/CMake-primer/">CMake保姆级教程</a></p><h4 id="9-宏定义"><a href="#9-宏定义" class="headerlink" title="9.宏定义"></a>9.宏定义</h4><p>在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER  3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是一个程序猿, 我不会爬树...\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;NUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, GCC!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">    printf(<span class="string">&quot;我是一个程序猿, 我不会爬树...\n&quot;</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><p>对 <code>DEBU</code>G 宏进行了判断，如果该宏被定义了，那么就会进行日志输出，如果没有定义这个宏，该段代码就相当于被注释掉了，因此最终无法看到日志输出（上述代码中并没有定义这个宏）</p><p>输出为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候去把它定义出来，其中一种方式就是在 <code>gcc/g++ </code>命令中去指定，如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc <span class="keyword">test</span>.c -DDEBUG -o app</span><br></pre></td></tr></table></figure><p>在 <code>gcc/g++</code> 命令中通过参数 -D 指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为 <code>DEBUG</code></p><p>在<code>CMakeLists.txt</code>中可以进行类似的定义</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-D宏名称)</span><br></pre></td></tr></table></figure><p>如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="comment"># 自定义 DEBUG 宏</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">add_executable</span>(app ./<span class="keyword">test</span>.c)</span><br></pre></td></tr></table></figure><p>这样定义宏之后，上面的<code>c++</code>代码中的注释部分会在编译的时候 在日志中输出</p><h4 id="10-预定义宏"><a href="#10-预定义宏" class="headerlink" title="10.预定义宏"></a>10.预定义宏</h4><Table>   <tr>    <th>宏</th>    <th>功能</th>  </tr>   <tr>    <th>PROJECT_SOURCE_DIR</th>    <th>使用 cmake 命令后紧跟的目录，一般是工程的根目录</th>  </tr>   <tr>    <th>PROJECT_BINARY_DIR</th>    <th>执行 cmake 命令的目录</th>  </tr>   <tr>    <th>CMAKE_CURRENT_SOURCE_DIR</th>    <th>当前处理的 CMakeLists.txt 所在的路径</th>  </tr>   <tr>    <th>CMAKE_CURRENT_BINARY_DIR</th>    <th>target 编译目录</th>  </tr>     <tr>    <th>EXECUTABLE_OUTPUT_PATH</th>    <th>重新定义目标二进制可执行文件的存放位置</th>  </tr>   <tr>    <th>LIBRARY_OUTPUT_PATH</th>    <th>重新定义目标链接库文件的存放位置</th>  </tr>   <tr>    <th>PROJECT_NAME</th>    <th>返回通过 PROJECT 指令定义的项目名称</th>  </tr>   <tr>    <th>CMAKE_BINARY_DIR</th>    <th>项目实际构建路径，假设在 build 目录进行的构建，那么得到的就是这个目录的路径</th>  </tr></table><h4 id="11-关键词"><a href="#11-关键词" class="headerlink" title="11.关键词"></a>11.关键词</h4><h5 id="（1）PROJECT"><a href="#（1）PROJECT" class="headerlink" title="（1）PROJECT()"></a>（1）PROJECT()</h5><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p><code>PROJECT (HELLO) </code>  指定了工程的名字，并且支持所有语言—建议</p><p><code>PROJECT (HELLO CXX)  </code>    指定了工程的名字，并且支持语言是C++</p><p><code>PROJECT (HELLO C CXX) </code>     指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个<code>CMAKE</code>的变量</p><p><code>&lt;projectname&gt;_BINARY_DIR</code>，本例中是<code> HELLO_BINARY_DIR</code></p><p><code>&lt;projectname&gt;_SOURCE_DIR</code>，本例中是<code> HELLO_SOURCE_DIR</code></p><p>MESSAGE关键字就可以直接使用者两个变量，都指向当前的工作目录</p><p><strong>注意</strong>：如果改了工程名，这两个变量名也会改变，但是<code>CMAKE</code>给出了解决方案，又定义两个预定义变量：<code>PROJECT_BINARY_DIR</code>和<code>PROJECT_SOURCE_DIR</code>，这两个变量和<code>HELLO_BINARY_DIR</code>，<code>HELLO_SOURCE_DIR</code>是一致的。所以改了工程名也没有关系</p><h5 id="（2）MESSAGE"><a href="#（2）MESSAGE" class="headerlink" title="（2）MESSAGE()"></a>（2）MESSAGE()</h5><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li><code>SEND_ERROR</code>，产生错误，生成过程被跳过。</li><li><code>SATUS</code>，输出前缀为—的信息。</li><li><code>FATAL_ERROR</code>，立即终止所有<code>cmake</code>过程.</li></ul><h5 id="（3）add-subdirecroty指令"><a href="#（3）add-subdirecroty指令" class="headerlink" title="（3）add_subdirecroty指令"></a>（3）add_subdirecroty指令</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure><ul><li>这个指令用于向当前工程添加存放源文件的子目录<code>（src）</code>，并可以<strong>指定中间二进制和目标二进制存放</strong>的位置<code>（bin）</code></li><li><code>EXCLUDE_FROM_ALL</code>函数是将写的目录从编译中排除，如程序中的example</li><li><code>ADD_SUBDIRECTORY(src bin)</code><ul><li>将<code>src</code>子目录加入工程并指定编译输出(包含编译中间结果)路径为<code>bin </code>目录</li><li>如果不进行 <code>bin </code>目录的指定，那么编译结果(包括中间结果)都将存放在<code>build/src </code>目录</li></ul></li></ul><h5 id="（4）link-directories"><a href="#（4）link-directories" class="headerlink" title="（4）link_directories"></a>（4）link_directories</h5><p>向工程添加多个特定的库文件搜索路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(dir1 dir2 ...)</span><br><span class="line">如:</span><br><span class="line"><span class="comment"># 将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(/usr/lib/mylibfolder ./lib) </span><br></pre></td></tr></table></figure><h5 id="（5）add-compile-options"><a href="#（5）add-compile-options" class="headerlink" title="（5）add_compile_options"></a>（5）add_compile_options</h5><p>添加编译参数</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(exename source1 source2 ... sourceN)</span><br><span class="line">如:</span><br><span class="line"><span class="comment"># 添加编译参数 -Wall -std=c++11 -O2</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-Wall -std=c++<span class="number">11</span> -O2)</span><br></pre></td></tr></table></figure><h5 id="（6）CMAKE-C-FLAGS"><a href="#（6）CMAKE-C-FLAGS" class="headerlink" title="（6）CMAKE_C_FLAGS"></a>（6）CMAKE_C_FLAGS</h5><p><code>gcc</code>编译选项</p><h5 id="（7）CMAKE-CXX-FLAGS"><a href="#（7）CMAKE-CXX-FLAGS" class="headerlink" title="（7）CMAKE_CXX_FLAGS"></a>（7）CMAKE_CXX_FLAGS</h5><p>g++编译选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11</span></span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="（8）CMAKE-BUILD-TYPE"><a href="#（8）CMAKE-BUILD-TYPE" class="headerlink" title="（8）CMAKE_BUILD_TYPE"></a>（8）CMAKE_BUILD_TYPE</h5><p>编译类型(Debug, Release)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定编译类型为debug，调试时需要选择debug</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 设定编译类型为release，发布时需要选择release</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debug：用于在没有优化的情况下，使用带有调试符号构建库或可执行文件。</span></span><br><span class="line"><span class="comment"># Release：用于构建的优化的库或可执行文件，不包含调试符号。</span></span><br></pre></td></tr></table></figure><h4 id="12-更改二进制保存路径"><a href="#12-更改二进制保存路径" class="headerlink" title="12.更改二进制保存路径"></a>12.更改二进制保存路径</h4><p><code>SET </code>指令重新定义 <code>EXECUTABLE_OUTPUT_PATH </code>和 <code>LIBRARY_OUTPUT_PATH </code>变量 来指定最终的目标二进制的位置</p><p><code>SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</code><br><code>SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)</code></p><p><strong>哪里要改变目标存放路径，就在哪里加入上述的定义</strong>，所以应该在<code>src</code>下的<code>CMakeLists.txt</code>下写</p><h4 id="13-安装"><a href="#13-安装" class="headerlink" title="13.安装"></a>13.安装</h4><ul><li>一种是从代码编译后直接<code>make install</code>安装</li><li>一种是打包时的指定 目录安装<ul><li>简单的可以这样指定目录：<code>make install DESTDIR=/tmp/test</code></li><li>稍微复杂一点可以这样指定目录：<code>./configure –prefix=/usr</code></li></ul></li></ul><h3 id="二、嵌套CMAKE"><a href="#二、嵌套CMAKE" class="headerlink" title="二、嵌套CMAKE"></a>二、嵌套<code>CMAKE</code></h3><p>如果项目很大，或者项目中有很多的源码目录，在通过 <code>CMake</code> 管理项目的时候如果只使用一个 <code>CMakeLists.txt</code>，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个 <code>CMakeLists.txt </code>文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护</p><p><strong>项目目录结构</strong>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── calc</span><br><span class="line">│   ├── add.cpp</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── sub.cpp</span><br><span class="line">├── CMakeLists.txt    <span class="comment"># 根目录下的 CMakeLists.txt</span></span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   ├── calc.h</span><br><span class="line">│   └── sort.h</span><br><span class="line">├── sort</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── insert.cpp</span><br><span class="line">│   └── select.cpp</span><br><span class="line">├── test1</span><br><span class="line">│   ├── calc.cpp</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── test2</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── sort.cpp</span><br></pre></td></tr></table></figure><h4 id="1-预备"><a href="#1-预备" class="headerlink" title="1.预备"></a>1.预备</h4><h5 id="（1）节点关系"><a href="#（1）节点关系" class="headerlink" title="（1）节点关系"></a>（1）节点关系</h5><p><code>Linux</code> 的目录是树状结构，所以嵌套的 <code>CMake</code> 也是一个树状结构，最顶层的 <code>CMakeLists.txt </code>是根节点，其次都是子节点。因此，我们需要了解一些关于 <code>CMakeLists.txt</code> 文件变量作用域的一些信息：</p><ul><li>根节点<code>CMakeLists.txt</code>中的变量全局有效</li><li>父节点<code>CMakeLists.txt</code>中的变量可以在子节点中使用</li><li>子节点<code>CMakeLists.txt</code>中的变量只能在当前节点中使用</li></ul><h5 id="（2）添加子目录"><a href="#（2）添加子目录" class="headerlink" title="（2）添加子目录"></a>（2）添加子目录</h5><p>在<code>CMake</code>中父子节点之间的关系是如何建立的，这里需要用到一个 <code>CMake</code> 命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure><ul><li><code>source_dir</code>：指定了<code> CMakeLists.txt</code>源文件和代码文件的位置，其实就是指定子目录</li><li><code>binary_dir</code>：指定了输出文件的路径，一般不需要指定，忽略即可</li><li><code>EXCLUDE_FROM_ALL</code>：在子路径下的目标默认不会被包含到父路径的 <code>ALL</code> 目标里，并且也会被排除在<code> IDE</code> 工程文件之外。用户必须显式构建在子路径下的目标</li></ul><h4 id="2-实施"><a href="#2-实施" class="headerlink" title="2.实施"></a>2.实施</h4><p>在上面的目录中我们要做如下事情：</p><ul><li><p>通过 <code>test1</code> 目录中的测试文件进行计算器相关的测试</p></li><li><p>通过<code>test2</code>目录中的测试文件进行排序相关的测试</p></li></ul><p>现在相当于是要进行模块化测试，对于<code> calc</code> 和 <code>sort </code>目录中的源文件来说，可以将它们先编译成库文件（可以是静态库也可以是动态库）然后在提供给测试文件使用即可。库文件的本质其实还是代码，只不过是从文本格式变成了二进制格式。</p><h5 id="（1）根目录"><a href="#（1）根目录" class="headerlink" title="（1）根目录"></a>（1）根目录</h5><p>根目录（最外层的）中的 <code>CMakeLists.txt </code>文件内容如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"><span class="comment"># 静态库生成的路径</span></span><br><span class="line"><span class="keyword">set</span>(LIB_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line"><span class="keyword">set</span>(HEAD_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 静态库的名字</span></span><br><span class="line"><span class="keyword">set</span>(CALC_LIB calc)</span><br><span class="line"><span class="keyword">set</span>(SORT_LIB sort)</span><br><span class="line"><span class="comment"># 可执行程序的名字</span></span><br><span class="line"><span class="keyword">set</span>(APP_NAME_1 test1)</span><br><span class="line"><span class="keyword">set</span>(APP_NAME_2 test2)</span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(calc)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(sort)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(test1)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(test2)</span><br></pre></td></tr></table></figure><p>在根节点对应的文件中主要做了两件事情：<code>定义全局变量</code>和<code>添加子目录</code></p><ul><li>定义的全局变量主要是给子节点使用，目的是为了提高子节点中的 <code>CMakeLists.txt </code>文件的可读性和可维护性，避免冗余并降低出差的概率</li><li>一共添加了四个子目录，每个子目录中都有一个 <code>CMakeLists.txt </code>文件，这样它们的父子关系就被确定下来了</li></ul><h5 id="（2）calc目录"><a href="#（2）calc目录" class="headerlink" title="（2）calc目录"></a>（2）calc目录</h5><p><code>calc</code> 目录中的<code>CMakeLists.txt</code>文件内容如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCLIB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录下文件全部作为变量存储之 SRC 中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC ./)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新定义目标链接库文件的存放位置</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态的库文件</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CALC_LIB&#125;</span> STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>file(GLOB SRC ./)</code> 可以使用<code>aux_source_directory(./ SRC)</code>进行代替，搜索当前目录(<code>calc</code>)下的所有源文件，并且存储至 SRC变量中</li><li><code>include_directories($&#123;HEAD_PATH&#125;)</code>，包含头文件路径，<code>HEAD_PATH</code>是在根节点（最外层的<code>CMakeLists.txt</code>）文件中定义的</li><li><code>set(LIBRARY_OUTPUT_PATH $&#123;LIB_PATH&#125;)</code>中重新定义生成的库文件存放在的位置<code>LIBRARY_OUTPUT_PATH</code>，该程序中是生成静态库，<code>LIB_PATH</code>是在根节点（最外层的<code>CMakeLists.txt</code>）文件中定义的</li><li><code>add_library($&#123;CALC_LIB&#125; STATIC $&#123;SRC&#125;)</code>：生成静态库，静态库名字<code>CALC_LIB</code>是在根节点文件中定义的</li></ul><h5 id="（3）sort目录"><a href="#（3）sort目录" class="headerlink" title="（3）sort目录"></a>（3）sort目录</h5><p><code>sort</code> 目录中的 <code>CMakeLists.txt </code>文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(SORTLIB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索该目录下的源文件 并将其存储之 SRC变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 重新定义目标链接库文件的存放位置</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;SORT_LIB&#125;</span> SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>add_library($&#123;SORT_LIB&#125; SHARED $&#123;SRC&#125;)</code>：生成动态库，动态库名字<code>SORT_LIB</code>是在根节点文件中定义的</p></li><li><p><strong>注意:</strong> 在生成库文件的时候，这个库可以是静态库也可以是动态库，一般需要根据实际情况来确定。<strong>如果生成的库比较大，建议将其制作成动态库</strong></p></li></ul><h5 id="（4）test1目录"><a href="#（4）test1目录" class="headerlink" title="（4）test1目录"></a>（4）test1目录</h5><p><code>test1</code> 目录中的<code>CMakeLists.txt</code>文件内容如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(CALCTEST)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索该目录下的源文件 并将其存储之 SRC变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接静态库 </span></span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">$&#123;CALC_LIB&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新定义目标二进制可执行文件的存放位置</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_1&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>link_libraries($&#123;CALC_LIB&#125;)</code>链接静态库，其实对于静态库的链接也可以<code>target_link_libraries(可执行文件名 静态库名)</code>当然需要放到<code>add_executable($&#123;APP_NAME_1&#125; $&#123;SRC&#125;)</code>之后</li><li><code>add_executable</code>：生成可执行程序，<code>APP_NAME_1</code> 变量是在根节点文件中定义的</li><li><code>set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;)</code>重新定义目标二进制可执行文件的存放位置</li></ul><p><strong>注意</strong>: 此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了</p><h5 id="（5）test2目录"><a href="#（5）test2目录" class="headerlink" title="（5）test2目录"></a>（5）test2目录</h5><p><code>test2</code> 目录中的<code> CMakeLists.txt</code> 文件内容如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(SORTTEST)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索该目录下的源文件 并将其存储之 SRC变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新定义目标二进制可执行文件的存放位置</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="comment"># link_directories($&#123;LIB_PATH&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接动态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SORT_LIB&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>link_directorie</code>s：指定可执行程序要链接的动态库的路径，<code>LIB_PATH </code>变量是在根节点文件中定义的</li><li><code>add_executable</code>：生成可执行程序，<code>APP_NAME_2 </code>变量是在根节点文件中定义的</li><li><code>target_link_libraries</code>：指定可执行程序要链接的动态库的名字</li></ul><p><strong>注意</strong>： 在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且<strong>多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库</strong></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C加加 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo魔改教程</title>
      <link href="/2023/05/31/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/Web/Hexo%E9%AD%94%E6%94%B9%E6%95%99%E7%A8%8B/"/>
      <url>/2023/05/31/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/Web/Hexo%E9%AD%94%E6%94%B9%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Hexo魔改教程"><a href="#Hexo魔改教程" class="headerlink" title="Hexo魔改教程"></a>Hexo魔改教程</h2><p><a href="https://www.fomal.cc/posts/e593433d.html">大佬教程点这里</a></p><p>每次加入新的文章之后，在本地的项目文件下（工作目录下）,<code>git bash</code>输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h3 id="一、社交图标"><a href="#一、社交图标" class="headerlink" title="一、社交图标"></a>一、社交图标</h3><p><a href="https://www.wzhecnu.cn/2021/07/22/blog/hexo-02-zhu-ti-mei-hua/">魔改教程</a></p><p>第一：需要进行修改的是，将<code>icofont</code>下载的代码，复制到<code>&quot;source/css/iconfont.css&quot;</code></p><p>第二：在<code>_config.butterfly.yml</code>文件下进行的</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230603170455.png" alt="image-20230603170448249"></p><p>添加代码：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/iconfont.css&quot;&gt;</code></p><p> 第三：在<code>_config.butterfly.yml</code>文件的社交图标部分，添加你需要的代码</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230603170727.png" alt="image-20230603170727859"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconfont  icon-gitee: https:<span class="comment">//gitee.com/zhou-xuezhi || Gitee || &#x27;#24292e&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用教程</title>
      <link href="/2023/05/31/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/Git/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2023/05/31/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/Git/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Git使用教程"><a href="#Git使用教程" class="headerlink" title="Git使用教程"></a>Git使用教程</h2><p><a href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">文档来源</a></p><h3 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h3><h4 id="1-Git配置"><a href="#1-Git配置" class="headerlink" title="1.Git配置"></a>1.Git配置</h4><h5 id="（1）所有配置（系统-用户）"><a href="#（1）所有配置（系统-用户）" class="headerlink" title="（1）所有配置（系统\用户）"></a>（1）所有配置（系统\用户）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cnfig -l</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531105332.png" alt="image-20230531105325132"></p><h5 id="（2）系统配置"><a href="#（2）系统配置" class="headerlink" title="（2）系统配置"></a>（2）系统配置</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --<span class="built_in">list</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531105519.png" alt="image-20230531105519567"></p><h5 id="（3）当前用户配置"><a href="#（3）当前用户配置" class="headerlink" title="（3）当前用户配置"></a>（3）当前用户配置</h5><p>这是必须配置的（相当于告诉github你的身份，用户标识）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global  --<span class="built_in">list</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531105604.png"></p><p><strong>设置用户名以及邮箱</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;kuangshen&quot;</span>  #名称</span><br><span class="line">git config --global user.email <span class="number">24736743</span>@qq.com   #邮箱</span><br></pre></td></tr></table></figure><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中</p><h5 id="（4）git相关配置文件"><a href="#（4）git相关配置文件" class="headerlink" title="（4）git相关配置文件"></a>（4）git相关配置文件</h5><p><strong>所有的配置文件，其实都保存在本地</strong></p><ul><li><p><code>Git\etc\gitconfog</code> :该目录位于 Git安装目录下 —-为系统级（System）别的配置文件</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531111253.png" alt="image-20230531111253609"></p></li><li><p>C:\Users\PC(Administrator)\ .gitconfig    只适用于当前登录用户的配置  –global 全局</p></li></ul><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531110928.png" alt="image-20230531110928554"></p><p>可以将用户本地文件进行清空，然后重新按照<code>设置用户名以及邮箱</code>的指令进行设置</p><h3 id="二、GIT相关理论"><a href="#二、GIT相关理论" class="headerlink" title="二、GIT相关理论"></a>二、GIT相关理论</h3><p>Git本地有三个工作区域：**工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)<strong>。如果在加上远程的</strong>git仓库(Remote Directory)**就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531111613.png" alt="image-20230531111613688"></p><ul><li><p>Workspace：工作区，就是你平时存放项目代码的地方（<strong>一般是本地的项目目录</strong>）</p></li><li><p>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</p></li><li><p>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p></li><li><p>Remote：远程仓库（<code>Github/Gitee</code>），托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p></li></ul><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531112426.png" alt="image-20230531112426685"></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li><code>WorkSpace</code>：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，<strong>初始化仓库的时候自动创建</strong>。(隐藏文件夹)</li><li>Index&#x2F;Stage：暂存区，或者叫待提交更新区，在提交进入<code>repo</code>之前，我们可以把所有的更新放在暂存区。</li><li><code>Local Repo</code>：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存&#x2F;恢复<code>WorkSpace</code>中的临时状态。</li></ul><h4 id="1-工作流程"><a href="#1-工作流程" class="headerlink" title="1.工作流程"></a>1.工作流程</h4><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；(本地的工作目录)</p><p>２、将需要进行版本管理的文件放入暂存区域；（<code>git add .</code>）</p><p>３、将暂存区域的文件提交到(<strong>本地</strong>)git仓库。(<code>git commit</code>)</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531112950.png" alt="image-20230531112950463"></p><p>如上图如果最后需要推送到远程的 <code>github</code> 或者 <code>gitee</code> 仓库需要 <code>pull</code></p><h3 id="三、Git项目搭建"><a href="#三、Git项目搭建" class="headerlink" title="三、Git项目搭建"></a>三、Git项目搭建</h3><p>工作目录（<code>WorkSpace</code>)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，<strong>建议不要有中文</strong></p><p>日常使用只要记住下图6个命令：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531121824.png" alt="image-20230531121824834"></p><h4 id="1-本地仓库搭建"><a href="#1-本地仓库搭建" class="headerlink" title="1.本地仓库搭建"></a>1.本地仓库搭建</h4><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库</p><h5 id="（1）新仓库"><a href="#（1）新仓库" class="headerlink" title="（1）新仓库"></a>（1）新仓库</h5><p>在项目目录下，<code>git bash</code>输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><p>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面（隐藏文件夹）</p><h5 id="（2）克隆远程仓库"><a href="#（2）克隆远程仓库" class="headerlink" title="（2）克隆远程仓库"></a>（2）克隆远程仓库</h5><p>将远程服务器上的仓库完全镜像一份至本地</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">git clone [url]  <span class="meta"># https:<span class="comment">//gitee.com/kuangstudy/openclass.git</span></span></span><br></pre></td></tr></table></figure><h4 id="2-Git文件操作"><a href="#2-Git文件操作" class="headerlink" title="2.Git文件操作"></a>2.Git文件操作</h4><p><strong>文件的四种状态</strong></p><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上</p><ul><li><code>Untracked</code>: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为<code>Staged</code></li><li><code>Unmodify</code>: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为<code>Modified</code>. 如果使用<code>git rm</code>移出版本库, 则成为<code>Untracked</code>文件</li><li><code>Modified</code>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过<code>git add</code>可进入暂存<code>staged</code>状态, 使用<code>git checkout</code> 则丢弃修改过, 返回到<code>unmodify</code>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改</li></ul><ul><li><code>Staged</code>: 暂存状态. 执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为<code>Unmodify</code>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<code>Modified</code></li></ul><h5 id="（1）操作"><a href="#（1）操作" class="headerlink" title="（1）操作"></a>（1）操作</h5><p>在本地项目目录下,<code>git bash</code>,输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531123649.png" alt="image-20230531123649256"></p><p>当前目录下为空，没有文件待提交</p><p>在目录下创建一个<code>hello.txt</code>,使用<code>git status</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531123852.png" alt="image-20230531123852493"></p><p>出现一个没有被跟踪（<code>Unstracked</code>）的文件</p><p>使用<code>git add .</code>将文件添加至暂存区里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531124052.png" alt="image-20230531124052028"></p><p>在使用<code>git status</code>,出现</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531124126.png" alt="image-20230531124126932"></p><p>存在一个文件，为<strong>待提交</strong>的状态了，暂存去有一个新文件了</p><p>提交暂存区的内容到，本地的<code>git</code>仓库,输入<code>git commit -m &quot;消息内容&quot;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;new file hello.txt&quot;</span>   # -m 表示提交信息</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531124729.png" alt="image-20230531124728984"></p><p>使用<code>git status</code>,继续查看当前状态</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531124814.png" alt="image-20230531124814244"></p><p>没有文件待提交</p><p><strong>总结</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看指定文件状态</span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line">#查看所有文件状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="meta"># git add .                  添加所有文件到暂存区</span></span><br><span class="line"><span class="meta"># git commit -m <span class="string">&quot;消息内容&quot;</span>    提交暂存区中的内容到本地仓库 -m 提交信息</span></span><br></pre></td></tr></table></figure><h4 id="3-忽略文件"><a href="#3-忽略文件" class="headerlink" title="3.忽略文件"></a>3.忽略文件</h4><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立<code>.gitignore</code>文件，此文件有如下规则：</p><ul><li><p>忽略文件中的空行或以井号（#）开始的行将会被忽略。</p></li><li><p>可以使用Linux通配符。例如：星号<code>（*）</code>代表任意多个字符，问号<code>（？）</code>代表一个字符，方括号<code>（[abc]）</code>代表可选字符范围，大括号<code>（&#123;string1,string2,...&#125;）</code>代表可选的字符串等。</p></li><li><p>如果名称的最前面有一个感叹号<code>（!）</code>，表示例外规则，将不被忽略。</p></li><li><p>如果名称的最前面是一个路径分隔符<code>（/）</code>，表示要忽略的文件在此目录下，而子目录中的文件不忽略。</p></li><li><p>如果名称的最后面是一个路径分隔符<code>（/）</code>，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       #忽略build/目录下的所有文件</span><br><span class="line">doc<span class="comment">/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.t</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531125831.png" alt="image-20230531125831364"></p><h4 id="4-使用gitee进行托管"><a href="#4-使用gitee进行托管" class="headerlink" title="4.使用gitee进行托管"></a>4.使用<code>gitee</code>进行托管</h4><h5 id="（1）本机绑定SSH公钥"><a href="#（1）本机绑定SSH公钥" class="headerlink" title="（1）本机绑定SSH公钥"></a>（1）本机绑定SSH公钥</h5><p>设置本机绑定SSH公钥，实现免密码登录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 进入 C:\Users\Administrator\.ssh 目录</span><br><span class="line"># 生成公钥</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>若你的机器上面已经有了<code>SSH-Key</code>,你可以继续创建 只要重新设置不同的公钥文件名就可以不将之前的覆盖了</p><p>下图将名字设置为了 <code>gitee_lab.rsa</code>不至于覆盖值的rsa文件，密码可以不进行设置，否则每次进行<code>git</code>提交都需要输入密码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 进入 C:\Users\Administrator\.ssh 目录</span><br><span class="line"># 生成公钥</span><br><span class="line"> ssh-keygen -t rsa -C <span class="string">&quot;XXXXX@XXX.com&quot;</span>    #用户邮箱</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531140441.png" alt="image-20230531140441285"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531140941.png" alt="image-20230531140941636"></p><p><a href="https://blog.csdn.net/jiangyu1013/article/details/103559435">参考</a></p><p>在<code>Gitee</code>上面进行公钥绑定</p><p>设置—&gt;安全设置—-&gt;SSH公钥</p><p>将上述的<code>gitee_lab.rsa.pub</code>用记事本打开，将其复制到SHH公钥的文本框内</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531141207.png" alt="image-20230531141207971"></p><p>也可以不进行重新创建别的<code>SSH-Key</code>,使用一个<code>SSH-Key</code>同时链接<code>github以及gitee</code>.<a href="https://blog.csdn.net/weixin_43197640/article/details/113465872">参考</a></p><p>在<code>gitee</code>添加公钥之后，在<code>.ssh</code>文件下创建<code>1.txt</code>文件在将整个文件包含<code>txt</code>重命名为<code>config</code>文件，写入以下内容：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531152450.png" alt="image-20230531152450832"></p><p>使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com   # 查看是否链接成功</span><br></pre></td></tr></table></figure><p><strong>在<code>Gitee</code>进行仓库创建</strong></p><h5 id="（2）上传本地文件"><a href="#（2）上传本地文件" class="headerlink" title="（2）上传本地文件"></a>（2）上传本地文件</h5><p>在本地创建一个工作目录（项目文件目录），在目录中打开<code>git bash</code></p><p>将当前文件夹初始化为git本地仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>将本地仓库与远程创建的<code>gitee</code>仓库建立链接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># git remote add origin &#123;仓库地址&#125;</span></span><br><span class="line">git remote add origin https:<span class="comment">//gitee.com/zhou-xuezhi/test.git</span></span><br></pre></td></tr></table></figure><p>将码云上的仓库pull到本地文件夹</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>对本地工作目录，进行添加你需要修改的文件</p><p>将当前文件夹添加至暂存区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>将暂存的文件提交到本地仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m ‘第一次提交’</span><br></pre></td></tr></table></figure><p>将本地仓库的文件推送到远程仓库中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>如果本地工作目录（项目目录）中的文件有修改，只需要进行本地项目目录<code>git bash</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br><span class="line">git commit -m <span class="string">&#x27;再次提交&#x27;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><strong>注意：需要在gitee的个人管理中的邮箱管理添加你的个人邮箱，gitee才可以进行代码托管</strong></p><p>之后在将本地仓库中的文件推送到远程仓库中时，会弹出以下界面：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531154239.png" alt="image-20230531154239888"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230531154258.png" alt="image-20230531154258578"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username <span class="keyword">for</span> ‘https:<span class="comment">//gitee.com’: 输入的是gitee上你的邮箱账号,</span></span><br><span class="line">Password <span class="keyword">for</span> ‘https:<span class="comment">//gitee.com’’: 输入gitee的登录密码</span></span><br></pre></td></tr></table></figure><h4 id="5-使用github进行托管"><a href="#5-使用github进行托管" class="headerlink" title="5.使用github进行托管"></a>5.使用<code>github</code>进行托管</h4><p>在<code>github</code>上面创建一个<code>CLion_Cracking</code>的仓库</p><p>新建一个<code>README.md</code>文件</p><p>使用以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:maxswordsman/CLion_Crakcing.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h3 id="三、git分支"><a href="#三、git分支" class="headerlink" title="三、git分支"></a>三、git分支</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line">    </span><br><span class="line"># 重命名分支</span><br><span class="line">git branch -M &#123;branch_name&#125;</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><p><code>master</code>主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说<code>dev</code>分支代码稳定后可以合并到主分支<code>master</code>上来。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tonic.utils.plot.grid()</title>
      <link href="/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/SNN/Tonic.utils.plot.grid()/"/>
      <url>/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/SNN/Tonic.utils.plot.grid()/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Tonic-utils-plot-grid"><a href="#Tonic-utils-plot-grid" class="headerlink" title="Tonic.utils.plot.grid()"></a>Tonic.utils.plot.grid()</h2><p>将事件可视化，绘制成帧</p><p><a href="https://tonic.readthedocs.io/en/latest/how-tos/visualizing-data.html">函数链接</a></p><h3 id="一、函数原型"><a href="#一、函数原型" class="headerlink" title="一、函数原型"></a>一、<strong>函数原型</strong></h3><p><strong>函数作用：</strong>将事件累积成等于轴的乘积的帧，以供视觉检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">import tonic.transforms as transforms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="title function_">plot_event_grid</span><span class="params">(events, axis_array=(<span class="number">1</span>, <span class="number">3</span>), plot_frame_number=False)</span>:</span><br><span class="line">    &quot;&quot;&quot;Plot events accumulated as frames equal to the product of axes <span class="keyword">for</span> visual inspection.</span><br><span class="line"></span><br><span class="line">    Parameters:</span><br><span class="line">        events: Structured numpy <span class="built_in">array</span> of shape [num_events, num_event_channels].</span><br><span class="line">            事件流，numpy数组</span><br><span class="line">            </span><br><span class="line">        axis_array: dimensions of plotting grid. The larger the grid,</span><br><span class="line">                    the more fine-grained the events will be sliced in time.</span><br><span class="line">                    将事件流，绘制成帧，并用网格形式表示出来，此处可设定帧的数量，以axis_array=(<span class="number">2</span>,<span class="number">3</span>)为例，则帧的数量为<span class="number">2</span>*<span class="number">3</span>=<span class="number">6</span>，以<span class="number">2</span>行<span class="number">3</span>列的网格显示出                     来</span><br><span class="line">                        </span><br><span class="line">        plot_frame_number: optional index of frame when plotting</span><br><span class="line">            绘图时帧的可选索引</span><br><span class="line"></span><br><span class="line">    Example:</span><br><span class="line">        &gt;&gt;&gt; import tonic</span><br><span class="line">        &gt;&gt;&gt; dataset = tonic.datasets.NMNIST(save_to=<span class="string">&#x27;./data&#x27;</span>)</span><br><span class="line">        &gt;&gt;&gt; events, target = dataset[<span class="number">100</span>]</span><br><span class="line">        &gt;&gt;&gt; tonic.utils.plot_event_grid(events)</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        None</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        import matplotlib.pyplot as plt</span></span><br><span class="line"><span class="string">    except ImportError:</span></span><br><span class="line"><span class="string">        raise ImportError(</span></span><br><span class="line"><span class="string">            &quot;</span>Please install the matplotlib package to plot events. This is an optional<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &quot;</span> dependency.<span class="string">&quot;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 事件流events是一个numpy列表，其中dtype为 [(&#x27;x&#x27;, &#x27;&lt;i8&#x27;), (&#x27;y&#x27;, &#x27;&lt;i8&#x27;), (&#x27;t&#x27;, &#x27;&lt;i8&#x27;), (&#x27;p&#x27;, &#x27;&lt;i8&#x27;)]</span></span><br><span class="line"><span class="string">        # events.dtype.names 为 (&#x27;x&#x27;, &#x27;y&#x27;, &#x27;t&#x27;, &#x27;p&#x27;) 表示一个事件的坐标x,y（像素坐标系） 时间辍，极性</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">    if &quot;</span>y<span class="string">&quot; in events.dtype.names:</span></span><br><span class="line"><span class="string"># 得到了 events 事件流中事件在像素坐标系中横坐标与纵坐标的最大值，用于绘制帧的尺寸</span></span><br><span class="line"><span class="string">        sensor_size_x = int(events[&quot;</span>x<span class="string">&quot;].max() + 1)</span></span><br><span class="line"><span class="string">        sensor_size_y = int(events[&quot;</span>y<span class="string">&quot;].max() + 1)</span></span><br><span class="line"><span class="string">        # np.unique(events[&quot;</span>p<span class="string">&quot;]) 对于一个以为列表或者数组，去除重复元素,并按照元素从小到大返回一个新的列表或者元组</span></span><br><span class="line"><span class="string">        # 此处得到了，事件有机种极性，也代表着之后的事件帧有几个通道</span></span><br><span class="line"><span class="string">        sensor_size_p = len(np.unique(events[&quot;</span>p<span class="string">&quot;]))</span></span><br><span class="line"><span class="string">        # 此处为帧的尺寸，长、宽、通道数</span></span><br><span class="line"><span class="string">        sensor_size = (sensor_size_x, sensor_size_y, sensor_size_p)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 将事件转化为事件帧，sensor_size为事件帧的尺寸，n_time_bins为按照时间箱得到固定的帧数</span></span><br><span class="line"><span class="string">            # np.product(axis_array) 返回数组或者元组 axis_array中元素的乘积。即时间流通过切片方式得到的事件帧的数量</span></span><br><span class="line"><span class="string">        transform = transforms.ToFrame(</span></span><br><span class="line"><span class="string">            sensor_size=sensor_size, n_time_bins=np.product(axis_array)</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 将事件流转化为事件帧</span></span><br><span class="line"><span class="string">        frames = transform(events)</span></span><br><span class="line"><span class="string">        # *axis_array在python中表示 将数组或者元组解开成几个独立的参数，传入函数，如axis_array=(2,3),则*axis_array = 2 3</span></span><br><span class="line"><span class="string">        # plt.subplots(m,n) 绘制 m*n个子图，字图在一个大图中以m行n列的方式显示</span></span><br><span class="line"><span class="string">        # 函数的返回值是一个元组，包括一个图形对象和所有的 axes_array 对象。</span></span><br><span class="line"><span class="string">        # 其中 axes_array 对象（含所有子图的一个数组）的数量等于 nrows * ncols，且每个 axes_array 对象均可通过索引值访问</span></span><br><span class="line"><span class="string">            # fig 的类型就是一个大的画布，所有子图均显示在上面（&lt;class &#x27;matplotlib.figure.Figure&#x27;&gt;）</span></span><br><span class="line"><span class="string">        fig, axes_array = plt.subplots(*axis_array)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if 1 in axis_array:</span></span><br><span class="line"><span class="string">            axes_array = axes_array.reshape(1, -1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        for i in range(axis_array[0]):</span></span><br><span class="line"><span class="string">            for j in range(axis_array[1]):</span></span><br><span class="line"><span class="string"># 按照索引得到一帧图像</span></span><br><span class="line"><span class="string">                frame = frames[i * axis_array[1] + j]</span></span><br><span class="line"><span class="string">                # 将事件帧的两个通道的像素值进行作差---并在子图中显示出来，可以简单的看出事件相机在录制数据时的移动方向</span></span><br><span class="line"><span class="string">                axes_array[i, j].imshow(frame[1] - frame[0])</span></span><br><span class="line"><span class="string">                # 关闭子图中所有坐标轴线、刻度标记和标签</span></span><br><span class="line"><span class="string">                axes_array[i, j].axis(&quot;</span>off<span class="string">&quot;)</span></span><br><span class="line"><span class="string">                # 是否给每张子图设置一个标题 title</span></span><br><span class="line"><span class="string">                if plot_frame_number:</span></span><br><span class="line"><span class="string">                    axes_array[i, j].title.set_text(str(i * axis_array[1] + j))</span></span><br><span class="line"><span class="string">        # 自动调整子图参数，使之填充整个图像区域</span></span><br><span class="line"><span class="string">        plt.tight_layout()</span></span><br><span class="line"><span class="string">        # 显示所有的figure，这是必要的，若没有则会出现，只出现一张子图的情况</span></span><br><span class="line"><span class="string">        plt.show()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        sensor_size_x = int(events[&quot;</span>x<span class="string">&quot;].max() + 1)</span></span><br><span class="line"><span class="string">        frame_transform = transforms.ToFrame(</span></span><br><span class="line"><span class="string">            sensor_size=(sensor_size_x, 1, 1), n_time_bins=sensor_size_x * 2</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        frames = frame_transform(events)</span></span><br><span class="line"><span class="string">        plt.imshow(frames.squeeze().T)</span></span><br><span class="line"><span class="string">        plt.xlabel(&quot;</span>Time<span class="string">&quot;)</span></span><br><span class="line"><span class="string">        plt.ylabel(&quot;</span>Channels<span class="string">&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="1-实例程序："><a href="#1-实例程序：" class="headerlink" title="1.实例程序："></a>1.实例程序：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    将事件数据转换为帧</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import tonic</span><br><span class="line">import tonic.transforms as transforms</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line"># 下载 NMINST 数据</span><br><span class="line">dataset = tonic.datasets.NMNIST(save_to=<span class="string">&quot;/home/zxz/Proj/DP/Do/demo_03/Tonic_dir/tutorials/data&quot;</span>,train=False)</span><br><span class="line"></span><br><span class="line">print(len(dataset))  # <span class="number">10000</span></span><br><span class="line">events,target = dataset[<span class="number">1000</span>]</span><br><span class="line">print(events)  <span class="meta"># numpy数组</span></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    每行对应一个事件，由四个参数组成:(x坐标、y坐标、时间戳、极性)</span></span><br><span class="line"><span class="string">        x和y坐标对应34*34网格中的地址</span></span><br><span class="line"><span class="string">        事件的时间戳以微秒为单位记录</span></span><br><span class="line"><span class="string">        极性指的是是否发生了峰上(+1)或峰下(-1);即，亮度的增加或减少</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"># 将许多事件累积到一个框架中，使其可视化---将事件流划分为<span class="number">3</span>*<span class="number">2</span>个事件帧</span><br><span class="line">tonic.utils.plot_event_grid(events,axis_array=(<span class="number">3</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><strong>显示效果</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202302051424871.png" alt="image-20230205142409828"></p><h4 id="2-手写相同效果的程序"><a href="#2-手写相同效果的程序" class="headerlink" title="2.手写相同效果的程序"></a>2.手写相同效果的程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    将事件数据转换为帧---对tonic中的一些操作进行合并</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import tonic</span><br><span class="line">import tonic.transforms as transforms</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import torch</span><br><span class="line">import torchvision</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    事件帧的可视化程序，将事件帧可视化</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">def <span class="title function_">plot_frames</span><span class="params">(frames)</span>:</span><br><span class="line">    <span class="meta"># subplots 生成 1*len(frames) 个子图像</span></span><br><span class="line">    # 函数的返回值是一个元组，包括一个图形对象和所有的 axes 对象。</span><br><span class="line">        # 其中 axes 对象的数量等于 nrows * ncols，且每个 axes 对象均可通过索引值访问（从1开始）</span><br><span class="line">    fig, axes = plt.subplots(<span class="number">1</span>, len(frames))</span><br><span class="line">    <span class="meta"># zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表</span></span><br><span class="line">    <span class="keyword">for</span> axis, frame in <span class="title function_">zip</span><span class="params">(axes, frames)</span>:</span><br><span class="line">        # 让画布上的每一个子图显示一个图像</span><br><span class="line">        axis.<span class="title function_">imshow</span><span class="params">((frame[<span class="number">1</span>]-frame[<span class="number">0</span>]))</span></span><br><span class="line">        # 关闭所有坐标轴线、刻度标记和标签<span class="title function_">next</span><span class="params">(iternext(iter</span></span><br><span class="line"><span class="params">        axis.axis(<span class="string">&quot;off&quot;</span>)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    # 自动调整子图参数，使之填充整个图像区域</span></span><br><span class="line"><span class="params">    plt.tight_layout()</span></span><br><span class="line"><span class="params">    # 显示所有的figure，这是必要的，若没有则会出现，只出现一张子图的情况</span></span><br><span class="line"><span class="params">    plt.show()</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># 设置 CPU 生成随机数的 种子,可见不同的随机种子能够生成不同的随机数,但只要随机种子一样，每次运行代码都会生成该种子下的随机数</span></span><br><span class="line"><span class="params">torch.manual_seed(<span class="number">1234</span>)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># 手动转化</span></span><br><span class="line"><span class="params">sensor_size = tonic.datasets.NMNIST.sensor_size</span></span><br><span class="line"><span class="params"># 帧有尺寸(时间，极性数，高度和宽度)。让我们为N-MNIST样本中的三次扫视绘制一个帧。我们将利用两个相机的极性差来观察运动方向</span></span><br><span class="line"><span class="params">    # 用时间箱将事件流划分为 数量为n_time_bins的事件帧</span></span><br><span class="line"><span class="params">frame_transfrom = transforms.ToFrame(sensor_size=sensor_size,n_time_bins=<span class="number">6</span>)</span></span><br><span class="line"><span class="params"># 对事件进行去噪</span></span><br><span class="line"><span class="params">denoise_transform = tonic.transforms.Denoise(filter_time=<span class="number">10000</span>)</span></span><br><span class="line"><span class="params"># 对事件的变化操作</span></span><br><span class="line"><span class="params">transform = transforms.Compose([denoise_transform,frame_transfrom])</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># 下载 NMINST 数据 --- 已经对NMINST中数据进行处理变为帧</span></span><br><span class="line"><span class="params">dataset = tonic.datasets.NMNIST(</span></span><br><span class="line"><span class="params">    save_to=<span class="string">&quot;/home/zxz/Proj/DP/Do/demo_03/Tonic_dir/tutorials/data&quot;</span>, train=False, transform=transform</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">frame,target = dataset[<span class="number">1000</span>]</span></span><br><span class="line"><span class="params">plot_frames(frame)</span></span><br></pre></td></tr></table></figure><p><strong>显示效果</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202302051432511.png" alt="image-20230205143215481"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> SNN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SNN工具链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tonic.Transforms.ToFrame()</title>
      <link href="/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/SNN/Tonic.Transforms.ToFrame()/"/>
      <url>/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/SNN/Tonic.Transforms.ToFrame()/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Tonic-Transforms-ToFrame"><a href="#Tonic-Transforms-ToFrame" class="headerlink" title="Tonic.Transforms.ToFrame()"></a>Tonic.Transforms.ToFrame()</h2><p>Tonic是一个方便下载、操作和加载基于事件&#x2F;基于峰值的数据的工具。它就像PyTorch Vision，但用于神经形态数据!</p><p><a href="https://tonic.readthedocs.io/en/latest/auto_examples/representations/plot_toframe.html#sphx-glr-auto-examples-representations-plot-toframe-py">函数链接</a></p><p><a href="https://blog.csdn.net/black_buaa/article/details/108478804">事件相机的数据处理</a>：该博客中介绍了如何对事件数据进行可视化</p><p><strong>函数原型：</strong></p><p><strong>函数作用：通过一定的方法，将事件流可视化，得到帧</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">@dataclass(frozen=True)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToFrame</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Accumulate events to frames by slicing along constant time (time_window), constant number of</span></span><br><span class="line"><span class="string">    events (spike_count) or constant number of frames (n_time_bins / n_event_bins). All the events</span></span><br><span class="line"><span class="string">    in one slice are added up in a frame for each polarity. You can set one of the first 4</span></span><br><span class="line"><span class="string">    parameters to choose the slicing method. Depending on which method you choose, overlap will</span></span><br><span class="line"><span class="string">    assume different functionality, whether that might be temporal overlap, number of events or</span></span><br><span class="line"><span class="string">    fraction of a bin. As a rule of thumb, here are some considerations if you are unsure which</span></span><br><span class="line"><span class="string">    slicing method to choose:</span></span><br><span class="line"><span class="string">通过沿着常数时间(时间窗口)、常数数量的事件(峰值计数)或常数数量的帧(n个时间箱/ n个事件箱)将事件累积到帧中。一个切片中的所有事件都被添加到每个极性的帧   中。您可以设置前4个参数中的一个来选择切片方法。根据您选择的方法，重叠将假设不同的功能，无论是时间重叠、事件数量还是bin的部分。根据经验，如果你不确定     要选择哪种切片方法，这里有一些注意事项</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * If your recordings are of roughly the same length, a safe option is to set time_window. Bare in mind</span></span><br><span class="line"><span class="string">      that the number of events can vary greatly from slice to slice, but will give you some consistency when</span></span><br><span class="line"><span class="string">      training RNNs or other algorithms that have time steps.</span></span><br><span class="line"><span class="string">      如果你的录音长度大致相同，一个安全的选择是设置时间窗口。请记住，不同切片的事件数量可能会有很大差异，但在训练rnn或其他具有时间步长的算法时，会给你一       些一致性。</span></span><br><span class="line"><span class="string">      方法：利用固定时间窗口。以某一固定时间进行累计得到事件帧。但是不能改善状态差异导致的帧间的信息量差异</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * If your recordings have roughly the same amount of activity / number of events and you are more interested</span></span><br><span class="line"><span class="string">      in the spatial composition, then setting spike_count will give you frames that are visually more consistent.</span></span><br><span class="line"><span class="string">      如果您的记录具有大致相同的活动数量/事件数量，并且您对空间构成更感兴趣，那么设置峰值计数将为您提供视觉上更一致的帧</span></span><br><span class="line"><span class="string">      方法：利用事件数量。以达到某一数量的事件数为阈值，输出一个事件帧</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * The previous time_window and spike_count methods will likely result in a different amount of frames for each</span></span><br><span class="line"><span class="string">      recording. If your training method benefits from consistent number of frames across a dataset (for easier</span></span><br><span class="line"><span class="string">      batching for example), or you want a parameter that is easier to set than the exact window length or number</span></span><br><span class="line"><span class="string">      of events per slice, consider fixing the number of frames by setting n_time_bins or n_event_bins. The two</span></span><br><span class="line"><span class="string">      methods slightly differ with respect to how the slices are distributed across the recording. You can define</span></span><br><span class="line"><span class="string">      an overlap between 0 and 1 to provide some robustness.</span></span><br><span class="line"><span class="string">      之前的时间窗口和峰值计数方法可能会导致每个记录的帧数不同。如果你的训练方法受益于数据集中一致的帧数(例如，为了更容易批处理)，或者你想要一个比精确的       窗口长度或每个切片的事件数量更容易设置的参数，请考虑通过设置n个时间箱或n个事件箱来固定帧数。这两种方法在切片如何在记录中分布方面略有不同。可以为pro       定义0和1之间的重叠</span></span><br><span class="line"><span class="string">      方法：n个时间箱或n个事件箱来得到固定帧数，利用事件信息数量及事件阈值双限制的方式进行累计得到事件帧。这样产生的事件帧既可以保证高时间分辨率又可以使       事件中具有足够的信息进一步处理</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        sensor_size: a 3-tuple of x,y,p for sensor_size. If omitted, the sensor size is calculated for that sample. However,</span></span><br><span class="line"><span class="string">                    do use this feature sparingly as when not all pixels fire in a sample, this might cause issues with batching/</span></span><br><span class="line"><span class="string">                    stacking tensors further down the line.</span></span><br><span class="line"><span class="string">                    帧的尺寸大小，p表示通道数量</span></span><br><span class="line"><span class="string">                        </span></span><br><span class="line"><span class="string">        time_window (float): time window length for one frame. Use the same time unit as timestamps in the event recordings.</span></span><br><span class="line"><span class="string">                             Good if you want temporal consistency in your training, bad if you need some visual consistency</span></span><br><span class="line"><span class="string">                             for every frame if the recording&#x27;s activity is not consistent.</span></span><br><span class="line"><span class="string">                             一帧的时间窗口长度。在事件记录中使用与时间戳相同的时间单位。如果你想在训练中保持时间一致性，这很好;如果你需要每一帧的视                              觉一致性，如果记录的活动不一致，那就不好了。</span></span><br><span class="line"><span class="string">                             时间窗口 </span></span><br><span class="line"><span class="string">                                 </span></span><br><span class="line"><span class="string">        spike_count (int): number of events per frame. Good for training CNNs which do not care about temporal consistency.</span></span><br><span class="line"><span class="string">                           每帧的事件数。适合训练不关心时间一致性的cnn</span></span><br><span class="line"><span class="string">                                 </span></span><br><span class="line"><span class="string">        n_time_bins (int): fixed number of frames, sliced along time axis. Good for generating a pre-determined number of</span></span><br><span class="line"><span class="string">                           frames which might help with batching.</span></span><br><span class="line"><span class="string">                           固定帧数，沿时间轴切片。用于生成预先确定的帧数，这可能有助于批处理。</span></span><br><span class="line"><span class="string">                           时间箱---得到固定的帧数</span></span><br><span class="line"><span class="string">                                 </span></span><br><span class="line"><span class="string">        n_event_bins (int): fixed number of frames, sliced along number of events in the recording. Good for generating a</span></span><br><span class="line"><span class="string">                            pre-determined number of frames which might help with batching.</span></span><br><span class="line"><span class="string">                            固定帧数，沿着记录中的事件数切片。用于生成预先确定的帧数，这可能有助于批处理。</span></span><br><span class="line"><span class="string">                            事件箱</span></span><br><span class="line"><span class="string">                                 </span></span><br><span class="line"><span class="string">        overlap (float): overlap between frames defined either in time units, number of events or number of bins between 0 and 1.</span></span><br><span class="line"><span class="string">        include_incomplete (bool): if True, includes overhang slice when time_window or spike_count is specified.</span></span><br><span class="line"><span class="string">                                   Not valid for bin_count methods.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from tonic.transforms import ToFrame</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; transform1 = ToFrame(time_window=10000, overlap=300, include_incomplete=True)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; transform2 = ToFrame(spike_count=3000, overlap=100, include_incomplete=True)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; transform3 = ToFrame(n_time_bins=100, overlap=0.1)</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    sensor_size: Optional[Tuple[<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>]]</span><br><span class="line">    time_window: Optional[<span class="type">float</span>] = None</span><br><span class="line">    event_count: Optional[<span class="type">int</span>] = None</span><br><span class="line">    n_time_bins: Optional[<span class="type">int</span>] = None</span><br><span class="line">    n_event_bins: Optional[<span class="type">int</span>] = None</span><br><span class="line">    overlap: <span class="type">float</span> = <span class="number">0</span></span><br><span class="line">    include_incomplete: <span class="type">bool</span> = False</span><br><span class="line"></span><br><span class="line">    def __call__(self, events):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> functional.to_frame_numpy(</span><br><span class="line">            events=events,</span><br><span class="line">            sensor_size=self.sensor_size,</span><br><span class="line">            time_window=self.time_window,</span><br><span class="line">            event_count=self.event_count,</span><br><span class="line">            n_time_bins=self.n_time_bins,</span><br><span class="line">            n_event_bins=self.n_event_bins,</span><br><span class="line">            overlap=self.overlap,</span><br><span class="line">            include_incomplete=self.include_incomplete,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202302051152367.png" alt="image-20230205115223331"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> SNN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SNN工具链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Tonic加载标准本地的事件数据</title>
      <link href="/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/SNN/%E4%BD%BF%E7%94%A8Tonic%E5%8A%A0%E8%BD%BD%E6%A0%87%E5%87%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/SNN/%E4%BD%BF%E7%94%A8Tonic%E5%8A%A0%E8%BD%BD%E6%A0%87%E5%87%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="使用Tonic加载标准本地的事件数据"><a href="#使用Tonic加载标准本地的事件数据" class="headerlink" title="使用Tonic加载标准本地的事件数据"></a>使用Tonic加载标准本地的事件数据</h2><p><a href="https://zhuanlan.zhihu.com/p/149824829">os.walk()</a></p><p><a href="https://www.cnblogs.com/poloyy/p/15154008.html">callable and optional</a></p><p><a href="https://blog.csdn.net/ETalien_/article/details/103090294">numpy数组的保存：二进制文件（bin or npy）</a></p><p><a href="https://tonic.readthedocs.io/en/latest/how-tos/wrapping_own_data.html">Tonic帮助文档：How do I wrap my own recordings?</a></p><p>如果您在磁盘上有自己的记录，并且希望使用Tonic进行快速数据加载和应用转换，那么您可以将它们包装在一个自定义类中。最简单的选择是使用torchvision DatasetFolder类。如果这不适用于您的情况，您可以编写自己的类，在其中提供init、getitem和len方法的最小集合，然后就可以开始了。这个笔记是关于从本地numpy文件读取事件记录的模板类。我们将从创建一些虚拟文件开始</p><h3 id="1-模拟创建随机的事件流数据"><a href="#1-模拟创建随机的事件流数据" class="headerlink" title="1.模拟创建随机的事件流数据"></a>1.模拟创建随机的事件流数据</h3><p><strong>程序通过<code>np.random.rand(n_events)</code>创建<code>n_events</code>个服从<code>0-1</code>均匀分布的随机样本值，并将其存储在<code>numpy</code>数组中，通过<code>sensor_size[index]</code>确定事件四元组中每一个元素的范围大小。<code>dtype</code>中确定了四元组中每个元素的数据类型为<code>int</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    模型创建随机的事件流数据  事件四元组</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import numpy as np</span><br><span class="line">from tonic import Dataset, transforms</span><br><span class="line">import torch</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">sensor_size = (<span class="number">100</span>, <span class="number">200</span>, <span class="number">2</span>)</span><br><span class="line">n_recordings = <span class="number">10</span>   # 文件中包含<span class="number">10</span>个事件流  例如 NMNIST 中包含 <span class="number">10000</span> 个事件流</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    创建随机的事件流，并且保留在本地，以二进制文件格式保留</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">def create_random_input(</span><br><span class="line">    sensor_size=sensor_size,</span><br><span class="line">    # 事件流中的事件个数</span><br><span class="line">    n_events=<span class="number">10000</span>,</span><br><span class="line">    # 事件流中的事件以元组的形式表示，(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;p&#x27;</span>) x、y坐标  t 时间辍（微秒级别）  p 事件极性  均为整型</span><br><span class="line">    dtype=np.dtype([(<span class="string">&quot;x&quot;</span>, <span class="type">int</span>), (<span class="string">&quot;y&quot;</span>, <span class="type">int</span>), (<span class="string">&quot;t&quot;</span>, <span class="type">int</span>), (<span class="string">&quot;p&quot;</span>, <span class="type">int</span>)])</span><br><span class="line">):</span><br><span class="line">    events = np.zeros(n_events, dtype=dtype)</span><br><span class="line">    <span class="meta"># np.random.rand() 返回一个或者一组服从“0-1”均匀分布的随机样本值</span></span><br><span class="line">        <span class="meta"># np.random.rand(5)  return:[0.16132617 0.74789463 0.51725874 0.34676313 0.73510629]</span></span><br><span class="line">        <span class="meta"># np.random.rand(n_events) * sensor_size[0] 将该组样本值中的每一个元素均乘以 sensor_size[0]</span></span><br><span class="line">    events[<span class="string">&quot;x&quot;</span>] = np.random.rand(n_events) * sensor_size[<span class="number">0</span>]</span><br><span class="line">    events[<span class="string">&quot;y&quot;</span>] = np.random.rand(n_events) * sensor_size[<span class="number">1</span>]</span><br><span class="line">    events[<span class="string">&quot;p&quot;</span>] = np.random.rand(n_events) * sensor_size[<span class="number">2</span>]</span><br><span class="line">    events[<span class="string">&quot;t&quot;</span>] = np.sort(np.random.rand(n_events) * <span class="number">1e6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> events</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>模拟事件流效果显示：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(create_random_input())</span><br><span class="line">print(type(create_random_input()))</span><br><span class="line">    </span><br><span class="line"># 运行结果</span><br><span class="line">[(<span class="number">91</span>,   <span class="number">2</span>,    <span class="number">307</span>, <span class="number">0</span>) (<span class="number">38</span>,   <span class="number">1</span>,    <span class="number">577</span>, <span class="number">0</span>) (<span class="number">95</span>,  <span class="number">62</span>,   <span class="number">1119</span>, <span class="number">0</span>) ...</span><br><span class="line">(<span class="number">60</span>, <span class="number">104</span>, <span class="number">999259</span>, <span class="number">1</span>) (<span class="number">71</span>,  <span class="number">20</span>, <span class="number">999370</span>, <span class="number">0</span>) (<span class="number">35</span>, <span class="number">156</span>, <span class="number">999674</span>, <span class="number">0</span>)]</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">numpy</span>.<span class="title">ndarray</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p><strong>保存事件流数据</strong></p><p>**保存为<code>npy格式</code>**如下图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将事件流数据保留到本地  保存的文件格式为  npy</span><br><span class="line">[</span><br><span class="line">    # 数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中</span><br><span class="line">    np.save(f<span class="string">&quot;../Tonic_dir/tutorials/data/rand_by_myself/recording&#123;i&#125;.npy&quot;</span>, create_random_input())</span><br><span class="line">    <span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(<span class="number">0</span>,<span class="number">10</span>)</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202302071917631.png" alt="image-20230207191528867"></p><p><strong>保存为<code>bin</code>格式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将事件流数据保留到本地  文件保存的格式为 bin</span><br><span class="line">[</span><br><span class="line">    # 数组是以未压缩的原始二进制格式保存在扩展名为.bin的文件中</span><br><span class="line">    create_random_input().tofile(f<span class="string">&quot;../Tonic_dir/tutorials/data/rand_by_myself/recording&#123;i&#125;.bin&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(<span class="number">30</span>,<span class="number">40</span>)</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202302071918175.png" alt="image-20230207191814152"></p><h3 id="2-继承Dataset类加载本地的事件流数据"><a href="#2-继承Dataset类加载本地的事件流数据" class="headerlink" title="2.继承Dataset类加载本地的事件流数据"></a>2.继承Dataset类加载本地的事件流数据</h3><p>该程序只针对 以<code>npy</code>为后缀的事件流数据，以<code>bin</code>为后缀的数据可以根据文字开头<code>numpy数组的保存：二进制文件</code>链接跳转，修改<code>os.path.join(self.data_dir,f&quot;recording&#123;i&#125;.npy&quot;) for i in range(n_recordings)</code>以及<code>events = np.load(self.filenames[index])</code>两个部分，修改为读取<code>bin</code>文件的方式</p><p>使用此程序，需要修改<code>self.data_dir</code>即事件流文件目录路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">    继承Dataset类加载本地的事件流数据</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class MyRecordings(Dataset):</span><br><span class="line">    sensor_size = (</span><br><span class="line">        34,</span><br><span class="line">        34,</span><br><span class="line">        2,</span><br><span class="line">    )  # the sensor size of the event camera or the number of channels of the silicon cochlear that was used</span><br><span class="line">    ordering = (</span><br><span class="line">        &quot;xytp&quot;  # the order in which your event channels are provided in your recordings</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def __init__(</span><br><span class="line">        self,</span><br><span class="line">        train=True,</span><br><span class="line">        transform=None,</span><br><span class="line">        target_transform=None,</span><br><span class="line">    ):</span><br><span class="line">        super(MyRecordings, self).__init__(</span><br><span class="line">            save_to=&#x27;./&#x27;, transform=transform, target_transform=target_transform</span><br><span class="line">        )</span><br><span class="line">        self.train = train</span><br><span class="line"></span><br><span class="line">        # replace the strings with your training/testing file locations or pass as an argument</span><br><span class="line">        # 本地事件流文件路径</span><br><span class="line">        self.data_dir = f&quot;../Tonic_dir/tutorials/data/rand_by_myself/Test/0&quot;</span><br><span class="line">        if train:</span><br><span class="line">            self.filenames = [</span><br><span class="line">                # f&quot;recording&#123;i&#125;.npy&quot; 为 数据流文件</span><br><span class="line">                os.path.join(self.data_dir,f&quot;recording&#123;i&#125;.npy&quot;) for i in range(n_recordings)</span><br><span class="line">            ]</span><br><span class="line">        else:</span><br><span class="line">            raise NotImplementedError</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        # 加载文件中的事件流</span><br><span class="line">        events = np.load(self.filenames[index])</span><br><span class="line"></span><br><span class="line">        if self.transform is not None:</span><br><span class="line">            events = self.transform(events)</span><br><span class="line"></span><br><span class="line">        return events</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.filenames)</span><br></pre></td></tr></table></figure><p><strong>使用程序读取事件流数据</strong>，程序并为对事件流数据进行人工标注</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataset = MyRecordings(train=True)</span><br><span class="line">events = dataset[<span class="number">0</span>]</span><br><span class="line">print(events)</span><br><span class="line"></span><br><span class="line">dataloader = torch.utils.data.DataLoader(dataset, shuffle=True)</span><br><span class="line">events = next(iter(dataloader))</span><br><span class="line">print(events)</span><br></pre></td></tr></table></figure><h3 id="3-加载事件流数据并对其进行人工标注"><a href="#3-加载事件流数据并对其进行人工标注" class="headerlink" title="3.加载事件流数据并对其进行人工标注"></a>3.加载事件流数据并对其进行人工标注</h3><p>该程序改编自 <code>tonic.datasets.NMNIST</code>数据集加载的源码，将其网络下载的部分进行删剪得到</p><p><strong>程序只能对以<code>bin</code>为后缀的事件流数据进行人工标注</strong>，因为程序中<code>getitem()</code>中得到对应索引的事件流数据使用的是<code>tonic.io.read_minst_file()</code>函数，函数经过测试得到无法对以<code>npy</code>为后缀的事件流数据进行解析，其中的解析算法会报错</p><p><a href="https://tonic.readthedocs.io/en/latest/reference/generated/tonic.io.read_mnist_file.html">tonic.io.read_minst_file()函数网址链接</a></p><p>程序中需要修改的为<code>classes</code>数组，根据自己数据集的标签进行修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    对本地的事件流数据使用Tonic进行标注</span></span><br><span class="line"><span class="string">        有关网络下载的内容可以删除</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        save_to (string): Location to save files to on disk.</span></span><br><span class="line"><span class="string">        train (bool): If True, uses training subset, otherwise testing subset.</span></span><br><span class="line"><span class="string">        first_saccade_only (bool): If True, only work with events of the first of three saccades.</span></span><br><span class="line"><span class="string">                                   Results in about a third of the events overall.</span></span><br><span class="line"><span class="string">                                   如果为True，则只处理三个扫视中的第一个事件。大约三分之一的事件的结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        transform (callable, optional): A callable of transforms to apply to the data.</span></span><br><span class="line"><span class="string">        target_transform (callable, optional): A callable of transforms to apply to the targets/labels.</span></span><br><span class="line"><span class="string">                                               一个可调用的转换应用到目标/标签。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        transforms (callable, optional): A callable of transforms that is applied to both data and</span></span><br><span class="line"><span class="string">                                         labels at the same time.</span></span><br><span class="line"><span class="string">                                         同时应用于数据和标签的转换可调用对象</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import os</span><br><span class="line">from typing import Callable, Optional</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">from tonic.dataset import Dataset</span><br><span class="line">from tonic.io import read_mnist_file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class <span class="title function_">MYDATASET</span><span class="params">(Dataset)</span>:</span><br><span class="line">    train_filename = <span class="string">&quot;train.zip&quot;</span></span><br><span class="line">    train_folder = <span class="string">&quot;Train&quot;</span></span><br><span class="line">    test_filename = <span class="string">&quot;test.zip&quot;</span></span><br><span class="line">    test_folder = <span class="string">&quot;Test&quot;</span></span><br><span class="line"></span><br><span class="line">    classes = [</span><br><span class="line">        <span class="string">&quot;0 - zero&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1 - one&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    sensor_size = (<span class="number">34</span>, <span class="number">34</span>, <span class="number">2</span>)</span><br><span class="line">    dtype = np.dtype([(<span class="string">&quot;x&quot;</span>, <span class="type">int</span>), (<span class="string">&quot;y&quot;</span>, <span class="type">int</span>), (<span class="string">&quot;t&quot;</span>, <span class="type">int</span>), (<span class="string">&quot;p&quot;</span>, <span class="type">int</span>)])</span><br><span class="line">    ordering = dtype.names</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        构造函数</span></span><br><span class="line"><span class="string">            Callable 作为函数参数使用，其实只是做一个类型检查的作用，检查传入的参数值 get_func 是否为可调用对象</span></span><br><span class="line"><span class="string">                函数是可以调用的，变量是不可以调用的</span></span><br><span class="line"><span class="string">            Optional 可选类型 可选参数具有默认值，具有默认值的可选参数不需要在其类型批注上使用 Optional，因为它是可选的</span></span><br><span class="line"><span class="string">                Optional[int] 等价于 Union[int, None] 意味着：既可以传指定的类型 int，也可以传 None</span></span><br><span class="line"><span class="string">                如:transform: Optional[Callable] </span></span><br><span class="line"><span class="string">                    tranform 的 参数是一个 列表，其中参数可以为 Callable(可调用对象) 类型 也可以为 None</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    def __init__(</span><br><span class="line">            self,</span><br><span class="line">            save_to: str,</span><br><span class="line">            train: <span class="type">bool</span> = True,</span><br><span class="line">            first_saccade_only: <span class="type">bool</span> = False,</span><br><span class="line">            transform: Optional[Callable] = None,</span><br><span class="line">            target_transform: Optional[Callable] = None,</span><br><span class="line">            transforms: Optional[Callable] = None,</span><br><span class="line">    ):</span><br><span class="line">        super().__init__(</span><br><span class="line">            save_to,</span><br><span class="line">            transform=transform,</span><br><span class="line">            target_transform=target_transform,</span><br><span class="line">            transforms=transforms,</span><br><span class="line">        )</span><br><span class="line">        self.train = train</span><br><span class="line">        self.first_saccade_only = first_saccade_only</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> train:</span><br><span class="line">            self.filename = self.train_filename</span><br><span class="line">            self.folder_name = self.train_folder</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.filename = self.test_filename</span><br><span class="line">            self.folder_name = self.test_folder</span><br><span class="line"></span><br><span class="line">        # 在父类DataSet 中 self.location_on_system = os.path.join(save_to, self.__class__.__name__)</span><br><span class="line">            <span class="meta"># self.__class__.__name__  当前类类名 类名需要与本地的事件流数据集的外层名录名一致</span></span><br><span class="line">        # file_path = os.path.join(self.location_on_system, self.folder_name)</span><br><span class="line">        file_path = save_to</span><br><span class="line"></span><br><span class="line">        <span class="meta"># os.walk扫描test文件夹下所有的子目录和文件</span></span><br><span class="line">        # 二进制事件流文件的后缀名 --- 根据自己 文件 后缀名进行修改</span><br><span class="line">        events_file_end = <span class="string">&quot;bin&quot;</span></span><br><span class="line">        # 事件流标签的数据类型的别名 如 NMNIST 的标签为 <span class="number">0</span>到<span class="number">9</span> 为 <span class="type">int</span></span><br><span class="line">        label_type = <span class="type">int</span></span><br><span class="line">        <span class="keyword">for</span> path, dirs, files in os.walk(file_path):</span><br><span class="line">            # 排序</span><br><span class="line">            files.sort()</span><br><span class="line">            <span class="meta"># file 是 最底层目录下的 二进制数据流文件</span></span><br><span class="line">            <span class="keyword">for</span> file in files:</span><br><span class="line">                <span class="keyword">if</span> file.endswith(events_file_end):</span><br><span class="line">                    <span class="meta"># path 事件流上层目录的路径</span></span><br><span class="line">                    <span class="meta"># self.data 列表存储了所有的 事件流二进制文件</span></span><br><span class="line">                    self.data.append(path + <span class="string">&quot;/&quot;</span> + file)</span><br><span class="line">                    <span class="meta"># path 路径的 最后一个名录名称</span></span><br><span class="line">                    label_number = label_type(path[<span class="number">-1</span>])</span><br><span class="line">                    <span class="meta"># self.targets 列表存储了所有的 事件流二进制文件 对应的标签</span></span><br><span class="line">                    self.targets.append(label_number)</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                Returns:</span></span><br><span class="line"><span class="string">                    a tuple of (events, target) where target is the index of the target class.</span></span><br><span class="line"><span class="string">                    (events, target)的元组，其中target是目标类的索引</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="meta"># events 得到 self.data 对应 index 索引下的 事件流文件</span></span><br><span class="line">        events = read_mnist_file(self.data[index], dtype=self.dtype)</span><br><span class="line">        <span class="keyword">if</span> self.first_saccade_only:</span><br><span class="line">            events = events[events[<span class="string">&quot;t&quot;</span>] &lt; <span class="number">1e5</span>]</span><br><span class="line">        <span class="meta"># target 得到 self.targets 对应 index 索引下的 事件流文件所对应的标签</span></span><br><span class="line">        target = self.targets[index]</span><br><span class="line">        <span class="keyword">if</span> self.transform is not None:</span><br><span class="line">            events = self.transform(events)</span><br><span class="line">        <span class="keyword">if</span> self.target_transform is not None:</span><br><span class="line">            target = self.target_transform(target)</span><br><span class="line">        # 对事件流与标签同时进行transform</span><br><span class="line">        <span class="keyword">if</span> self.transforms is not None:</span><br><span class="line">            events, target = self.transforms(events, target)</span><br><span class="line">        <span class="keyword">return</span> events, target</span><br><span class="line"></span><br><span class="line">    # 得到文件中事件流的文件的个数</span><br><span class="line">    def __len__(self) -&gt; <span class="type">int</span>:</span><br><span class="line">        <span class="keyword">return</span> len(self.data)</span><br></pre></td></tr></table></figure><p><strong>测试程序：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    对 MYDATASET 进行测试</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import tonic</span><br><span class="line">import tonic.transforms as transforms</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">from MYDATASET import MYDATASET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset = MYDATASET(save_to=<span class="string">&quot;/home/zxz/Proj/DP/Do/demo_03/Tonic_dir/tutorials/data/rand_by_myself&quot;</span>,train=True)</span><br><span class="line"></span><br><span class="line">print(dataset[<span class="number">7</span>])</span><br><span class="line">events,target = dataset[<span class="number">7</span>]</span><br><span class="line">print(len(events))</span><br><span class="line">print(events)</span><br><span class="line">print(target)</span><br></pre></td></tr></table></figure><p><strong>测试效果:</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202302071955413.png" alt="image-20230207195517384"></p><p><strong>注意：</strong>数据集的目录文件结构如下，其中<code>0、1</code>为标签</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202302071957630.png" alt="image-20230207195739596"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> SNN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SNN工具链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用numpy创建三层神经网络</title>
      <link href="/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch/%E4%BD%BF%E7%94%A8numpy%E5%88%9B%E5%BB%BA%E4%B8%89%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch/%E4%BD%BF%E7%94%A8numpy%E5%88%9B%E5%BB%BA%E4%B8%89%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="numpy网络编程"><a href="#numpy网络编程" class="headerlink" title="numpy网络编程"></a>numpy网络编程</h2><p>本文参考于：书本<a href="https://www.amazon.com/Make-Your-Own-Neural-Network/dp/1530826608/r">《Make Your Own Neural Network》</a>  中文《Python神经网络编程》</p><p><a href="https://github.com/makeyourownneuralnetwork/makeyourownneuralnetwork">书中源代码</a></p><p><a href="https://github.com/maxswordsman/Create_Neural_Network">本文代码托管github</a></p><p>通过此次实践对于神经网络的认识更加深刻，通过数学推导到代码实践让自己有了比较大的收获</p><h3 id="一、数学推导"><a href="#一、数学推导" class="headerlink" title="一、数学推导"></a>一、数学推导</h3><p><strong>构造三层神经网络</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230303163043.png" alt="image-20230303163035955"></p><h4 id="1-前向传播"><a href="#1-前向传播" class="headerlink" title="1.前向传播"></a>1.前向传播</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230303163105.png" alt="image-20230303163104956"></p><h4 id="2-反向传播"><a href="#2-反向传播" class="headerlink" title="2.反向传播"></a>2.反向传播</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230303163132.png" alt="image-20230303163132514"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230303163226.png" alt="image-20230303163154712"></p><h4 id="3-更新权重"><a href="#3-更新权重" class="headerlink" title="3.更新权重"></a>3.更新权重</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230303163744.png" alt="image-20230303163743986"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230303163802.png" alt="image-20230303163802729"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230303163823.png" alt="image-20230303163822906"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230303163838.png" alt="image-20230303163838120"></p><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><h4 id="1-网络实现以及训练过程（Network-py）"><a href="#1-网络实现以及训练过程（Network-py）" class="headerlink" title="1.网络实现以及训练过程（Network.py）"></a>1.网络实现以及训练过程（<code>Network.py</code>）</h4><p>该部分对上述数学推导过程进行代码实现，构建一个三层的神经网络，其中隐含层的节点<code>self.hnodes</code>可以自己进行设置，因为网络主要使用的MNIST手写数字数据集，输入为（28，28）的灰度图片，但是要对其进行展平，变为784个输入数据；输出为10个节点，因为预测结果有0到9 十种可能</p><p><strong>网络实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    创建三层神经网络模型</span></span><br><span class="line"><span class="string">    用于训练  MNIST 数据集</span></span><br><span class="line"><span class="string">    书中的源码:https://github.com/makeyourownneuralnetwork/makeyourownneuralnetwork/blob/master/part2_neural_network_mnist_data.ipynb</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import numpy</span><br><span class="line"># Sigmod() 函数定义在scipy包里面，其输入可以直接 为矩阵</span><br><span class="line">import scipy.special</span><br><span class="line"># 绘图</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">neuralNetwork</span>:</span></span><br><span class="line">    def __init__(self,inputnodes,hiddennodes,outputnodes,learningrate):</span><br><span class="line">        self.inodes = inputnodes</span><br><span class="line">        self.hnodes = hiddennodes</span><br><span class="line">        self.onodes = outputnodes</span><br><span class="line"></span><br><span class="line">        <span class="meta"># learning rate</span></span><br><span class="line">        self.lr = learningrate</span><br><span class="line"></span><br><span class="line">        # 隐藏层与输入层之间wih  以及 隐藏层与输出层之间 的初始权重矩阵</span><br><span class="line">        self.wih = numpy.random.normal(<span class="number">0.0</span>,<span class="built_in">pow</span>(self.inodes,<span class="number">-0.5</span>),(self.hnodes,self.inodes))</span><br><span class="line">        self.who = numpy.random.normal(<span class="number">0.0</span>,<span class="built_in">pow</span>(self.hnodes,<span class="number">-0.5</span>),(self.onodes,self.hnodes))</span><br><span class="line"></span><br><span class="line">        # 激活函数</span><br><span class="line">        self.activation_function = lambda x: scipy.special.expit(x)</span><br><span class="line"></span><br><span class="line">    <span class="meta"># train the neural network</span></span><br><span class="line">    def train(self,inputs_list,targets_list):</span><br><span class="line">        # 将输入转为<span class="number">2</span>d 矩阵</span><br><span class="line">        inputs = numpy.<span class="built_in">array</span>(inputs_list,ndmin=<span class="number">2</span>).T</span><br><span class="line">        targets = numpy.<span class="built_in">array</span>(targets_list,ndmin=<span class="number">2</span>).T</span><br><span class="line"></span><br><span class="line">        # 计算隐藏层的信号加权和</span><br><span class="line">        hidden_inputs = numpy.dot(self.wih,inputs)</span><br><span class="line">        # 对加权和的值 使用激活函数</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line"></span><br><span class="line">        # 计算输出层的信号加权和</span><br><span class="line">        final_inputs = numpy.dot(self.who,hidden_outputs)</span><br><span class="line">        # 对加权和的值 使用激活函数</span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># output layer <span class="keyword">error</span> is the  (target - actual)</span></span><br><span class="line">        output_errors = targets - final_outputs</span><br><span class="line">        # 隐藏层的误差 是对输出层误差按照权重进行分割重组得到的</span><br><span class="line">        hidden_errors = numpy.dot(self.who.T,output_errors)</span><br><span class="line"></span><br><span class="line">        # 更新隐含层与输出层之间的权重</span><br><span class="line">        self.who += self.lr * numpy.dot((output_errors * final_outputs * (<span class="number">1.0</span> - final_outputs)),</span><br><span class="line">                                        numpy.transpose(hidden_outputs))</span><br><span class="line">        # 更新隐含层与输入层之间的权重</span><br><span class="line">        self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (<span class="number">1.0</span> - hidden_outputs)),</span><br><span class="line">                                       numpy.transpose(inputs))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> final_outputs</span><br><span class="line"></span><br><span class="line">    # 测试网络</span><br><span class="line">    def query(self,inputs_list):</span><br><span class="line">        # 将输入转化为<span class="number">2</span>D 矩阵</span><br><span class="line">        inputs = numpy.<span class="built_in">array</span>(inputs_list,ndmin=<span class="number">2</span>).T</span><br><span class="line"></span><br><span class="line">        # 将输入信号的加权和 输入之隐藏层</span><br><span class="line">        hidden_inputs = numpy.dot(self.wih,inputs)</span><br><span class="line">        # 是 加权使用 激活函数</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line"></span><br><span class="line">        # 对隐藏层的输出信号进行加权和</span><br><span class="line">        final_inputs = numpy.dot(self.who,hidden_outputs)</span><br><span class="line">        # 对加权和的信号  使用激活函数</span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> final_outputs</span><br></pre></td></tr></table></figure><p><strong>主程序</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="meta"># 输入为 28*28 = 784 单通道</span></span><br><span class="line">    input_nodes = <span class="number">784</span></span><br><span class="line">    hidden_nodes = <span class="number">200</span></span><br><span class="line">    <span class="meta"># 输出为 0-9 10 个预测数字</span></span><br><span class="line">    output_nodes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#  学习率</span></span><br><span class="line">    learning_rate = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    <span class="meta"># 创建网络实例</span></span><br><span class="line">    n = neuralNetwork(input_nodes,hidden_nodes,output_nodes,learning_rate)</span><br><span class="line"></span><br><span class="line">    <span class="meta"># 加载 MNIST 训练的数据集</span></span><br><span class="line">    training_data_file = open(<span class="string">&quot;/home/zxz/Proj/deeplearning/Create_neural_network/Mnist_dateset/mnist_train.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="meta"># 在csv 类型文本中 mnist 数据集 每一行 代表一张单通道图片 其中的内容为 图片像素矩阵的各个像素值，并且存入列表</span></span><br><span class="line">    training_data_list = training_data_file.readlines()</span><br><span class="line">    training_data_file.close()</span><br><span class="line"></span><br><span class="line">    <span class="meta"># 加载mnist 测试数据集</span></span><br><span class="line">    test_data_file = open(<span class="string">&quot;/home/zxz/Proj/deeplearning/Create_neural_network/Mnist_dateset/mnist_test.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    test_data_list = test_data_file.readlines()</span><br><span class="line">    test_data_file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta"># 训练神经网络</span></span><br><span class="line">    print(<span class="string">&quot;Training ...................................&quot;</span>)</span><br><span class="line">    epochs = <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="title">range</span>(<span class="params">epochs</span>):</span></span><br><span class="line"><span class="function">        scorecard</span> = []  <span class="meta"># 用于存储每一轮的训练正确与否的结果</span></span><br><span class="line">        <span class="meta"># 遍历训练数据(列表)并对其进行 数据处理  --- 对数据仅仅训练了一轮</span></span><br><span class="line">        <span class="keyword">for</span> recode <span class="keyword">in</span> training_data_list:</span><br><span class="line">            <span class="meta"># 每一行数据 之间的像素值 以 “,“ 分割开来</span></span><br><span class="line">            <span class="meta"># 以 “,” 将每一行的 像素矩阵的值进行分割，并且将值存入列表</span></span><br><span class="line">            all_values = recode.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            <span class="meta"># 正确的标签是 数组中的第一个元素</span></span><br><span class="line">            correct_label = <span class="built_in">int</span>(all_values[<span class="number">0</span>])</span><br><span class="line">            <span class="meta"># 对数据进行归一化以及偏移0.01 防止0输入导致权值无法更新</span></span><br><span class="line">            inputs = (numpy.asfarray(all_values[<span class="number">1</span>:]) / <span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span></span><br><span class="line">            <span class="meta"># 创建期望输出值 （所有的都为0.01 只有期望的标签对应的值 为 0.99）</span></span><br><span class="line">            targets = numpy.zeros(output_nodes) + <span class="number">0.01</span></span><br><span class="line">            <span class="meta"># 列表的第一个元素all_values[0]为 每一个图片的 标签</span></span><br><span class="line">            targets[<span class="built_in">int</span>(all_values[<span class="number">0</span>])] = <span class="number">0.99</span></span><br><span class="line">            <span class="meta"># 使用训练函数进行训练</span></span><br><span class="line">            outputs = n.train(inputs, targets)</span><br><span class="line">            <span class="meta"># 得到输出结果中得分最好的索引</span></span><br><span class="line">            result = numpy.argmax(outputs)</span><br><span class="line">            <span class="keyword">if</span>(result == correct_label):</span><br><span class="line">                scorecard.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                scorecard.append(<span class="number">0</span>)</span><br><span class="line">        <span class="meta"># 计算本轮训练中的正确率</span></span><br><span class="line">        scorecard_array = numpy.asarray(scorecard)</span><br><span class="line">        print(r<span class="string">&quot;Epoch &#123;&#125;  Training performance = &#123;&#125;&quot;</span>.format((epoch+<span class="number">1</span>),scorecard_array.sum() / scorecard_array.size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Testing ................................&quot;</span>)</span><br><span class="line">    <span class="meta"># 测试神经网络</span></span><br><span class="line">    scorecard = []   <span class="meta"># 用于存储每一轮的预测正确与否的结果</span></span><br><span class="line">    <span class="keyword">for</span> recode <span class="keyword">in</span> test_data_list:</span><br><span class="line">        all_values = recode.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="meta"># 正确的标签是 数组中的第一个元素</span></span><br><span class="line">        correct_label = <span class="built_in">int</span>(all_values[<span class="number">0</span>])</span><br><span class="line">        inputs = (numpy.asfarray(all_values[<span class="number">1</span>:]) / <span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span></span><br><span class="line">        <span class="meta"># 测试网络</span></span><br><span class="line">        outputs = n.query(inputs)</span><br><span class="line">        <span class="meta"># 得到输出结果中 得分最高的索引位置</span></span><br><span class="line">        label = numpy.argmax(outputs)</span><br><span class="line">        <span class="keyword">if</span>(label == correct_label):</span><br><span class="line">            scorecard.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            scorecard.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="meta"># 计算 该论测试中的 正确率</span></span><br><span class="line">    scorecard_array = numpy.asarray(scorecard)</span><br><span class="line">    print(<span class="string">&quot;Testing performance = &quot;</span>,scorecard_array.sum() / scorecard_array.size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"># 可视化数据集中的图片</span></span><br><span class="line"><span class="string">    all_v = test_data_list[0].split(&quot;</span>,<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    image_array = ((np.asfarray(all_values[1:])/255.0 * 0.99) + 0.01).reshape(28,28)</span></span><br><span class="line"><span class="string">    plt.imshow(image_array,cmap=&#x27;Greys&#x27;,interpolation=&#x27;None&#x27;)</span></span><br><span class="line"><span class="string">    plt.show()</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong>测试的正确率可以达到97%左右</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230303165100.png" alt="image-20230303165059981"></p><h4 id="2-构建自己的手写数字数据集"><a href="#2-构建自己的手写数字数据集" class="headerlink" title="2.构建自己的手写数字数据集"></a>2.构建自己的手写数字数据集</h4><p>将自己手写的数字，进行数据处理变为合适网络的输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    将自己手写的数字(PNG存储在my_image中)进行处理并且进行数据存储(存储到training_data_list中)</span></span><br><span class="line"><span class="string">        1.书中的源码:https://github.com/makeyourownneuralnetwork/makeyourownneuralnetwork/blob/master/part3_load_own_images.ipynb</span></span><br><span class="line"><span class="string">        2.将自己创建的数字图片存储在 my_image，每张图片对应的label为图片的上层文件夹，图片格式为xxx.PNG</span></span><br><span class="line"><span class="string">        文件结构;</span></span><br><span class="line"><span class="string">         my_image</span></span><br><span class="line"><span class="string">            ├── 0</span></span><br><span class="line"><span class="string">                └── 0.png</span></span><br><span class="line"><span class="string">            ├── 1</span></span><br><span class="line"><span class="string">                └── 1.png</span></span><br><span class="line"><span class="string">            ├── 2</span></span><br><span class="line"><span class="string">                └── 2.png</span></span><br><span class="line"><span class="string">            ├── 3</span></span><br><span class="line"><span class="string">                └── 3.png</span></span><br><span class="line"><span class="string">            ├── 4</span></span><br><span class="line"><span class="string">                └── 4.png</span></span><br><span class="line"><span class="string">            ├── 5</span></span><br><span class="line"><span class="string">                └── 5.png</span></span><br><span class="line"><span class="string">            ├── 6</span></span><br><span class="line"><span class="string">                └── 6.png</span></span><br><span class="line"><span class="string">            ├── 7</span></span><br><span class="line"><span class="string">                └── 7.png</span></span><br><span class="line"><span class="string">            ├── 8</span></span><br><span class="line"><span class="string">                └── 8.png</span></span><br><span class="line"><span class="string">            └── 9</span></span><br><span class="line"><span class="string">                └── 9.png</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">import numpy</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import PIL</span><br><span class="line">import os</span><br><span class="line">import torchvision</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="title function_">my_image</span><span class="params">(file_path)</span>:</span><br><span class="line">    # 将图片放缩至 （28，28）</span><br><span class="line">    ReSize = torchvision.transforms.Resize((<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    # 用于存储数据的列表</span><br><span class="line">    training_data_list = []</span><br><span class="line">    # 将路径下的文件转化 列表 --- 图片的标签列表</span><br><span class="line">    num_class = [cla <span class="keyword">for</span> cla in os.listdir(file_path)]</span><br><span class="line">    <span class="keyword">for</span> cla in num_class:</span><br><span class="line">        # 每一个标签文件夹</span><br><span class="line">        cla_path = os.path.join(file_path,cla)</span><br><span class="line">        # 每一个标签文件夹下的图片列表</span><br><span class="line">        images = os.listdir(cla_path)</span><br><span class="line">        <span class="keyword">for</span> image in images:</span><br><span class="line">            # 每一张图片的路径</span><br><span class="line">            image_path = os.path.join(cla_path,image)</span><br><span class="line"></span><br><span class="line">            # 开始对数据进行处理</span><br><span class="line">            # 将图片转为灰度图片</span><br><span class="line">            image_array = PIL.Image.open(image_path).convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            # 将图片的大小缩放到 （<span class="number">28</span>，<span class="number">28</span>）</span><br><span class="line">            image_array_crop = ReSize(image_array)</span><br><span class="line">            # 将 PIL.Image.Image 数据类型变为 ndarry 二维数组类型 ---- 并将其展平为一维数组(<span class="number">784</span>)列 ---网络中输入数据的固定格式</span><br><span class="line">            image_data = numpy.asfarray(image_array_crop).reshape(<span class="number">784</span>)</span><br><span class="line">            # 像素值<span class="number">0</span>表示黑色  <span class="number">255</span>表示白色 但是 MNIST 中相反因此需要用 <span class="number">255</span>-image_data</span><br><span class="line">            image_data = <span class="number">255</span> - image_data</span><br><span class="line">            # 数据归一化并且进行偏移<span class="number">0.01</span>，防止<span class="number">0</span>输入造成梯度消失</span><br><span class="line">            image_data = (image_data/<span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span></span><br><span class="line">            record = numpy.append(<span class="type">float</span>(cla),image_data)</span><br><span class="line">            train_data_list.append(record)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> training_data_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 与 Network.py中的 train_data_list 效果一致</span><br><span class="line">training_data_list = my_image(<span class="string">&quot;/home/zxz/Proj/deeplearning/Create_neural_network/my_image&quot;</span>)</span><br><span class="line">print(training_data_list[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"># 可视化图片</span></span><br><span class="line"><span class="string">    plt.imshow(image_data.reshape(28,28), cmap=&#x27;Greys&#x27;, interpolation=&#x27;None&#x27;)</span></span><br><span class="line"><span class="string">    plt.show()</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlexNet</title>
      <link href="/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/AlexNET/"/>
      <url>/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/AlexNET/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="AlexNET"><a href="#AlexNET" class="headerlink" title="AlexNET"></a>AlexNET</h2><h3 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h3><h4 id="1-网络可视化"><a href="#1-网络可视化" class="headerlink" title="1.网络可视化"></a>1.网络可视化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torchsummary</span><br></pre></td></tr></table></figure><p><strong>输入：</strong>为模型、输入尺寸、批数量、设备 </p><p><strong>输出：</strong>模型的参数信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from torchsummary import summary</span><br><span class="line"></span><br><span class="line">def <span class="title function_">summary</span><span class="params">(model, input_size, batch_size=<span class="number">-1</span>, device=<span class="string">&quot;cuda&quot;</span>)</span>  # 函数默认是cuda，若是在cpu下就需要修改</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torchsummary import summary</span><br><span class="line">from torchvision.models import vgg16  # 以 vgg16 为例</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">myNet = vgg16()  # 实例化网络，可以换成自己的网络</span><br><span class="line"># 将模型移动到gpu上</span><br><span class="line">myNet = myNet.to(device)</span><br><span class="line">summary(myNet, (<span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>))  # 输出网络结构</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305062235519.png" alt="image-20230506223506480"></p><h4 id="2-数据集"><a href="#2-数据集" class="headerlink" title="2.数据集"></a>2.数据集</h4><p>百度网盘下载地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: https:<span class="comment">//pan.baidu.com/s/1Uro6RuEbRGGCQ8iXvF2SAQ 密码: hl31</span></span><br></pre></td></tr></table></figure><p><code>ImageNet</code> 数据集太大了1000类别，而且达到100多G的大小，因此换成<code>Mini-ImageNet</code>测试网络</p><p><code>Mini-ImageNet</code>数据集大约3G左右，100个类别，每一个类别均有600张图片左右，共60000张图片，而且图片都是可变分辨率的（图片大小尺寸不固定）</p><p>数据集的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── mini-imagenet: 数据集根目录</span><br><span class="line">     ├── images: 所有的图片都存在这个文件夹中</span><br><span class="line">     ├── train.csv: 对应训练集的标签文件</span><br><span class="line">     ├── val.csv: 对应验证集的标签文件</span><br><span class="line">     └── test.csv: 对应测试集的标签文件</span><br></pre></td></tr></table></figure><p><code>Mini-Imagenet</code>数据集中包含了<code>train.csv</code>、<code>val.csv</code>以及<code>test.csv</code>三个文件,但是提供的标签文件并不是从每个类别中进行采样的，因此无法直接用于训练分类，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train.csv 包含<span class="number">38400</span>张图片，共<span class="number">64</span>个类别</span><br><span class="line">val.csv   包含<span class="number">9600</span>张图片，共<span class="number">16</span>个类别</span><br><span class="line">test.csv  包含<span class="number">12000</span>张图片，共<span class="number">20</span>个类别</span><br></pre></td></tr></table></figure><p>按照上述链接下载文件之后，对images进行解压，在使用<code>panads</code>对数据集进行分割，需要自己构建一个新的<code>new_train.csv</code>与<code>new_val.csv</code>以<code>new_test.val</code>，代码中<code>imagenet_class_index.json</code>的下载地址为：<a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/blob/master/pytorch_classification/mini_imagenet/imagenet_class_index.json">json</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    1.将train.csv与val.csv以及test.csv 进行合并(乱序)之后再按照比例进行分割为</span></span><br><span class="line"><span class="string">        new_train.csv与new_val.csv以及new_test.csv</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import os</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">from PIL import Image</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">print(BASE_DIR)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    读取csv下的分类</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">def read_csv_classes(csv_dir: str, csv_name: str):</span><br><span class="line">    # 读取mini-imagenet 下的csv文件</span><br><span class="line">    data = pd.read_csv(os.path.join(csv_dir, csv_name))</span><br><span class="line"></span><br><span class="line">    # 得到csv文件下的label列的元素  并对其进行去重 drop_duplicates()</span><br><span class="line">    label_set = <span class="built_in">set</span>(data[<span class="string">&quot;label&quot;</span>].drop_duplicates().values)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;&#123;&#125; have &#123;&#125; images and &#123;&#125; classes.&quot;</span>.format(csv_name,</span><br><span class="line">                                                     data.shape[<span class="number">0</span>],</span><br><span class="line">                                                     len(label_set)))</span><br><span class="line">    <span class="keyword">return</span> data, label_set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    进行分割数据集  6:2:2</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">def calculate_split_info(path: str, save_path:str,label_dict: dict, rate1: <span class="type">float</span> = <span class="number">0.2</span>,rate2: <span class="type">float</span> = <span class="number">0.2</span>):</span><br><span class="line">    # image_dir 为mini-imagenet 下的images路径 存放的是所有图片</span><br><span class="line">    image_dir = os.path.join(path, <span class="string">&quot;images&quot;</span>)</span><br><span class="line">    # 得到image_dir路径下以jpg为后缀的文件的列表</span><br><span class="line">    images_list = [i <span class="keyword">for</span> i in os.listdir(image_dir) <span class="keyword">if</span> i.endswith(<span class="string">&quot;.jpg&quot;</span>)]</span><br><span class="line">    # 输出数据集中的图片数量</span><br><span class="line">    print(<span class="string">&quot;find &#123;&#125; images in dataset.&quot;</span>.format(len(images_list)))</span><br><span class="line"></span><br><span class="line">    train_data, train_label = read_csv_classes(path, <span class="string">&quot;train.csv&quot;</span>)</span><br><span class="line">    val_data, val_label = read_csv_classes(path, <span class="string">&quot;val.csv&quot;</span>)</span><br><span class="line">    test_data, test_label = read_csv_classes(path, <span class="string">&quot;test.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">    # 得到 train test val 三个数据集中的标签  总共为 <span class="number">100</span>类</span><br><span class="line">    labels = (train_label | val_label | test_label)</span><br><span class="line">    labels = <span class="built_in">list</span>(labels)</span><br><span class="line">    labels.sort()</span><br><span class="line">    print(<span class="string">&quot;all classes: &#123;&#125;&quot;</span>.format(len(labels)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #  得到类似于 <span class="string">&#x27;n01532829&#x27;</span>: [<span class="number">0</span>, <span class="string">&#x27;house_finch&#x27;</span>] 这样格式的字典</span><br><span class="line">    classes_label = dict([(label, [index, label_dict[label]]) <span class="keyword">for</span> index, label in enumerate(labels)])</span><br><span class="line">    # 将得到的字典写入json文件中</span><br><span class="line">    json_str = json.dumps(classes_label, indent=<span class="number">4</span>)</span><br><span class="line">    with open(<span class="string">&#x27;./Data/classes_name.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) as json_file:</span><br><span class="line">        json_file.write(json_str)</span><br><span class="line"></span><br><span class="line">    # 将train.csv  test.csv  val.csv 三个文件的内容拼接到一起 （得到所有数据的csv文件  里面的样本数量总共为<span class="number">60000</span>）</span><br><span class="line">    <span class="meta"># pd.concat()函数可以沿着指定的轴将多个dataframe或者series拼接到一起</span></span><br><span class="line">    data = pd.concat([train_data, val_data, test_data], axis=<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">&quot;total data shape: &#123;&#125;&quot;</span>.format(data.shape))</span><br><span class="line"></span><br><span class="line">    # 在每一个类别中分割数据集</span><br><span class="line">    num_every_classes = []</span><br><span class="line">    split_train_data = []</span><br><span class="line">    split_val_data = []</span><br><span class="line">    split_test_data = []</span><br><span class="line">    <span class="keyword">for</span> label in labels:</span><br><span class="line">        # class_data 为每个类 对应的图片的图片的DataFrame</span><br><span class="line">        # 每个类别的图片数量为 <span class="number">600</span></span><br><span class="line">        class_data = data[data[<span class="string">&quot;label&quot;</span>] == label]</span><br><span class="line"></span><br><span class="line">        num_every_classes.append(class_data.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #  乱序</span><br><span class="line">        # DataFrame.sample 可用来对DataFrame进行随机抽样</span><br><span class="line">        <span class="meta"># frac 参数用于指定抽取的样本条数的比例（这里的代码表示全部进行抽取即乱序）</span></span><br><span class="line">        # random_state 参数 可以复现抽样结果 第二次与第一次抽取的结果一致</span><br><span class="line">        shuffle_data = class_data.sample(frac=<span class="number">1</span>, random_state=<span class="number">1</span>)</span><br><span class="line">        # 分割比例</span><br><span class="line">        num_train_sample = <span class="type">int</span>(class_data.shape[<span class="number">0</span>] * (<span class="number">1</span> - rate1 - rate2))</span><br><span class="line">        num_val_sample = <span class="type">int</span>(class_data.shape[<span class="number">0</span>] * rate1)</span><br><span class="line">        new_test_sample = <span class="type">int</span>(class_data.shape[<span class="number">0</span>] * rate2)</span><br><span class="line">        # 因为每个类别为<span class="number">600</span>张  对每个类别求的分割的比例</span><br><span class="line">        split_train_data.append(shuffle_data[:num_train_sample])</span><br><span class="line">        split_val_data.append(shuffle_data[num_train_sample:(num_val_sample + num_train_sample)])</span><br><span class="line">        split_test_data.append(shuffle_data[(num_val_sample + num_train_sample):<span class="type">int</span>(class_data.shape[<span class="number">0</span>])])</span><br><span class="line"></span><br><span class="line">        <span class="meta"># imshow</span></span><br><span class="line">        imshow_flag = False</span><br><span class="line">        <span class="keyword">if</span> imshow_flag:</span><br><span class="line">            img_name, img_label = shuffle_data.iloc[<span class="number">0</span>].values</span><br><span class="line">            img = Image.open(os.path.join(image_dir, img_name))</span><br><span class="line">            plt.imshow(img)</span><br><span class="line">            plt.title(<span class="string">&quot;class: &quot;</span> + classes_label[img_label][<span class="number">1</span>])</span><br><span class="line">            plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="meta"># plot classes distribution</span></span><br><span class="line">    plot_flag = False</span><br><span class="line">    <span class="keyword">if</span> plot_flag:</span><br><span class="line">        plt.bar(range(<span class="number">1</span>, <span class="number">101</span>), num_every_classes, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="meta"># concatenate data 将分割的数据集 创建一个新的csv文件  并将其内容进行拼接</span></span><br><span class="line">    new_train_data = pd.concat(split_train_data, axis=<span class="number">0</span>)</span><br><span class="line">    new_val_data = pd.concat(split_val_data, axis=<span class="number">0</span>)</span><br><span class="line">    new_test_data = pd.concat(split_test_data, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="meta"># save new csv data</span></span><br><span class="line">    new_train_data.to_csv(os.path.join(save_path, <span class="string">&quot;new_train.csv&quot;</span>))</span><br><span class="line">    new_val_data.to_csv(os.path.join(save_path, <span class="string">&quot;new_val.csv&quot;</span>))</span><br><span class="line">    new_test_data.to_csv(os.path.join(save_path, <span class="string">&quot;new_test.csv&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    data_dir = <span class="string">&quot;/media/zxz/新加卷/DataSET/mini-imagenet/&quot;</span>  # 指向数据集的根目录</span><br><span class="line">    json_path = <span class="string">&quot;./Data/imagenet_class_index.json&quot;</span>  # 指向imagenet的索引标签文件</span><br><span class="line">    save_path = <span class="string">&quot;./Data&quot;</span>   # 创建的new_train.csv  与  ne_val.csv 需要保留的地址</span><br><span class="line"></span><br><span class="line">    <span class="meta"># load imagenet labels</span></span><br><span class="line">    label_dict = json.load(open(json_path, <span class="string">&quot;r&quot;</span>))</span><br><span class="line">    # 得到一个字典，其中键代表 label  而值代表label对应的事物的英语单词 如： <span class="string">&#x27;n01440764&#x27;</span>: <span class="string">&#x27;tench&#x27;</span></span><br><span class="line">    label_dict = dict([(v[<span class="number">0</span>], v[<span class="number">1</span>]) <span class="keyword">for</span> k, v in label_dict.items()])</span><br><span class="line"></span><br><span class="line">    calculate_split_info(data_dir, save_path,label_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>一般训练集、验证集、测试集按照<code>6:2:2</code>的比例进行分割,分割后得到的<code>csv</code>文件如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_train.csv 包含<span class="number">36000</span>张图片，共<span class="number">100</span>个类别</span><br><span class="line">new_val.csv   包含<span class="number">12000</span>张图片，共<span class="number">100</span>个类别</span><br><span class="line">new_test.csv  包含<span class="number">12000</span>张图片，共<span class="number">100</span>个类别</span><br></pre></td></tr></table></figure><p>根据创建的csv文件划分为原始如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Mini-imageNet</span><br><span class="line">    new_train</span><br><span class="line">    class1_dir</span><br><span class="line">   class2_dir</span><br><span class="line">    ...</span><br><span class="line">   new_val</span><br><span class="line">    class1_dir</span><br><span class="line">   class2_dir</span><br><span class="line">    ...</span><br><span class="line">   new_test</span><br><span class="line">    class1_dir</span><br><span class="line">   class2_dir</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    根据split_dataset1 新创建的csv文件   对原始的数据集进行分割</span></span><br><span class="line"><span class="string">        1.根据new_train.csv 文件中的图片 创建new_train文件夹 将图片复制到 new_train文件夹的对应的label下的文件夹下</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def <span class="title function_">copy_to_move</span><span class="params">(base_path:str,root_path:str,csv_path:str,move_to_dir:str)</span>:</span><br><span class="line">    # 读取csv文件  获取所有的img文件名称</span><br><span class="line">    handle_csv = os.path.join(base_path, csv_path)</span><br><span class="line">    data = pd.read_csv(handle_csv)</span><br><span class="line"></span><br><span class="line">    # 将csv文件中的图片名字  装入列表</span><br><span class="line">    handle_filename = <span class="built_in">list</span>(data[<span class="string">&quot;filename&quot;</span>].values)</span><br><span class="line">    handle_label = <span class="built_in">list</span>(data[<span class="string">&quot;label&quot;</span>].values)   <span class="meta">#  classes = 100</span></span><br><span class="line">    print(<span class="string">&quot;the train_cav data num is &#123;&#125; classes is &#123;&#125;&quot;</span>.format(len(handle_filename), len(<span class="built_in">set</span>(handle_label))))</span><br><span class="line"></span><br><span class="line">    dst = move_to_dir   #  提前创建一个new_train or new_test or new_val 文件夹，将CSV对应的img 复制到文件夹中</span><br><span class="line">    <span class="keyword">for</span> i, name in enumerate(handle_filename):</span><br><span class="line">        imgx = os.path.join(root_path, name)</span><br><span class="line">        print(f<span class="string">&quot;第&#123;i&#125;张图片已经copy完成&quot;</span>)</span><br><span class="line">        print(imgx)</span><br><span class="line">        shutil.copy(imgx, dst)</span><br><span class="line"></span><br><span class="line">    files = os.listdir(dst)  # 上一步创建的文件夹</span><br><span class="line">    pre = dst</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, img in enumerate(files):</span><br><span class="line">        # <span class="number">1.</span> 首先遍历每个文件，创建文件夹</span><br><span class="line">        #  n0153282900000138.jpg</span><br><span class="line">        dir_name = img.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>][:<span class="number">9</span>]  # 这里就是为了截取label，根据img name 前<span class="number">9</span>个为label</span><br><span class="line">        dir_path = os.path.join(pre,dir_name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not os.path.exists(dir_path):</span><br><span class="line">            os.mkdir(dir_path)  # 创建该类文件夹</span><br><span class="line"></span><br><span class="line">        #  直接判断该文件，归类</span><br><span class="line">        img_path = os.path.join(pre,img)</span><br><span class="line">        <span class="keyword">if</span> not os.path.isdir(img_path):</span><br><span class="line">            <span class="keyword">if</span> img[:<span class="number">9</span>] == dir_name:  # 由于每个类包含很多img文件，判断该文件是否属于该类</span><br><span class="line">                shutil.move(img_path, dir_path)  <span class="meta"># true的话，移动到该类目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    # 当前程序文件所在的目录</span><br><span class="line">    BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    print(BASE_DIR)</span><br><span class="line"></span><br><span class="line">    <span class="meta"># mini-imagenet数据集原始的images文件下</span></span><br><span class="line">    root_path_images = <span class="string">&quot;/media/zxz/新加卷/DataSET/mini-imagenet/images&quot;</span></span><br><span class="line">    new_train_csv_path = <span class="string">&quot;./Mini-ImageNet/new_train.csv&quot;</span></span><br><span class="line">    new_val_csv_path = <span class="string">&quot;./Mini-ImageNet/new_val.csv&quot;</span></span><br><span class="line">    new_test_csv_path = <span class="string">&quot;./Mini-ImageNet/new_test.csv&quot;</span></span><br><span class="line"></span><br><span class="line">    new_train_dir = <span class="string">&quot;./Mini-ImageNet/new_train&quot;</span></span><br><span class="line">    new_val_dir = <span class="string">&quot;./Mini-ImageNet/new_val&quot;</span></span><br><span class="line">    new_test_dir = <span class="string">&quot;./Mini-ImageNet/new_test&quot;</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;创建new_train文件夹.....&quot;</span>)</span><br><span class="line">    copy_to_move(BASE_DIR,root_path_images,new_train_csv_path,new_train_dir)</span><br><span class="line">    print()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;创建new_val文件夹.....&quot;</span>)</span><br><span class="line">    copy_to_move(BASE_DIR, root_path_images, new_val_csv_path, new_val_dir)</span><br><span class="line">    print()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;创建new_test文件夹.....&quot;</span>)</span><br><span class="line">    copy_to_move(BASE_DIR, root_path_images, new_test_csv_path, new_test_dir)</span><br><span class="line">    print()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>划分的数据集图片：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305081527871.png" alt="image-20230508152703849"></p><h3 id="二、论文细节"><a href="#二、论文细节" class="headerlink" title="二、论文细节"></a>二、论文细节</h3><h4 id="1-ReLu与Tanh收敛速度的比较"><a href="#1-ReLu与Tanh收敛速度的比较" class="headerlink" title="1.ReLu与Tanh收敛速度的比较"></a>1.<code>ReLu</code>与<code>Tanh</code>收敛速度的比较</h4><p>在论文的3.1节中提到ReLu相较于Tanh收敛速度更快，且ReLu无需对输入数据进行归一化防止饱和，在不对数据进行归一化的情况下，比较如下：</p><h5 id="（1）代码"><a href="#（1）代码" class="headerlink" title="（1）代码"></a>（1）代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">代码功能:</span></span><br><span class="line"><span class="string">    复现论文中3.1的部分比较</span></span><br><span class="line"><span class="string">        对于特定的四层卷积神经网络 达到25%的训练误差 所迭代的论轮数</span></span><br><span class="line"><span class="string">        没有对数据进行任何的正规化</span></span><br><span class="line"><span class="string">        每个网络的学习速率都是独立选择的，以使训练尽可能快</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    1.导入库</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import torch</span><br><span class="line">import torchvision</span><br><span class="line">from torch import nn</span><br><span class="line">from torch.utils.data import DataLoader</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    2.下载数据集</span></span><br><span class="line"><span class="string">        len(train_data) = 50000</span></span><br><span class="line"><span class="string">        len(test_data) = 10000</span></span><br><span class="line"><span class="string">        pic shape = [2,32,32]</span></span><br><span class="line"><span class="string">        classes = 10</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(root=<span class="string">&quot;../Cifar-10&quot;</span>,transform=torchvision.transforms.PILToTensor(),train=True,download=True)</span><br><span class="line"></span><br><span class="line"># 利用DataLoader加载数据集</span><br><span class="line">train_dataloader = DataLoader(train_data,batch_size=<span class="number">128</span>,shuffle=True)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    3.搭建四层卷积网络</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"># 搭建神经网络</span><br><span class="line">class Module(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            # Layer1</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),  #  <span class="number">32</span> <span class="number">32</span> <span class="number">32</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=(<span class="number">2</span>,<span class="number">2</span>),stride=<span class="number">2</span>) , # <span class="number">32</span> <span class="number">16</span> <span class="number">16</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            # Layer2</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),  # <span class="number">64</span> <span class="number">16</span> <span class="number">16</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=(<span class="number">2</span>,<span class="number">2</span>),stride=<span class="number">2</span>),  # <span class="number">64</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            #Layer3</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),  # <span class="number">64</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=(<span class="number">2</span>,<span class="number">2</span>),stride=<span class="number">2</span>),  # <span class="number">64</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            # # Layer4</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),   # <span class="number">128</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=<span class="number">2</span>),  # <span class="number">128</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            # Linear Layer</span><br><span class="line">            nn.Flatten(),</span><br><span class="line">            nn.Linear(<span class="number">128</span>*<span class="number">2</span>*<span class="number">2</span>,<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">64</span>,<span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def forward(self,input):</span><br><span class="line">        input = self.model(input)</span><br><span class="line">        <span class="keyword">return</span> input</span><br><span class="line"></span><br><span class="line">class Module2(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            # Layer1</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),  #  <span class="number">32</span> <span class="number">32</span> <span class="number">32</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=(<span class="number">2</span>,<span class="number">2</span>),stride=<span class="number">2</span>) , # <span class="number">32</span> <span class="number">16</span> <span class="number">16</span></span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            # Layer2</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),  # <span class="number">64</span> <span class="number">16</span> <span class="number">16</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=(<span class="number">2</span>,<span class="number">2</span>),stride=<span class="number">2</span>),  # <span class="number">64</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            #Layer3</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),  # <span class="number">64</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=(<span class="number">2</span>,<span class="number">2</span>),stride=<span class="number">2</span>),  # <span class="number">64</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            # # Layer4</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),   # <span class="number">128</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=<span class="number">2</span>),  # <span class="number">128</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            # Linear Layer</span><br><span class="line">            nn.Flatten(),</span><br><span class="line">            nn.Linear(<span class="number">128</span>*<span class="number">2</span>*<span class="number">2</span>,<span class="number">64</span>),</span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            nn.Linear(<span class="number">64</span>,<span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def forward(self,input):</span><br><span class="line">        input = self.model(input)</span><br><span class="line">        <span class="keyword">return</span> input</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span></span><br><span class="line"><span class="meta">#     x = torch.rand([1, 3, 32, 32])</span></span><br><span class="line"><span class="meta">#     model = Module()</span></span><br><span class="line"><span class="meta">#     y = model(x)</span></span><br><span class="line"><span class="meta">#     print(y.shape)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    4.训练模型</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"># 定义程序运行设备，若无法使用GPU则在CPU上进行运算</span><br><span class="line">device_1 = <span class="string">&#x27;cuda:0&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line">device = torch.device(device_1)</span><br><span class="line"></span><br><span class="line"># 创建网络模型（Relu）</span><br><span class="line">model1 = Module()</span><br><span class="line">model1 = model1.to(device=device)</span><br><span class="line"># （Tanh）</span><br><span class="line">model2 = Module2()</span><br><span class="line">model2 = model2.to(device=device)</span><br><span class="line"></span><br><span class="line"># 定义损失函数</span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">loss_fn = loss_fn.to(device=device)</span><br><span class="line"></span><br><span class="line"># 定义优化器</span><br><span class="line">learn_rate = <span class="number">0.01</span></span><br><span class="line">optimizer1 = torch.optim.SGD(model1.parameters(),lr=learn_rate,momentum=<span class="number">0.9</span>,weight_decay=<span class="number">0.0005</span>)</span><br><span class="line">optimizer2 = torch.optim.SGD(model2.parameters(),lr=learn_rate,momentum=<span class="number">0.9</span>,weight_decay=<span class="number">0.0005</span>)</span><br><span class="line"></span><br><span class="line">def train(lun,dataloader,model,loss_fn,optimizer):</span><br><span class="line">    # 将模型转化为训练模式</span><br><span class="line">    model.train()</span><br><span class="line">    loss,acc,step,epoch_error_rate = <span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0</span>,<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> data in dataloader:</span><br><span class="line">        imgs,targets = data</span><br><span class="line">        imgs = imgs.<span class="type">float</span>()</span><br><span class="line">        <span class="meta"># imgs = torch.tensor(np.array(imgs))</span></span><br><span class="line">        <span class="meta"># targets = torch.tensor(np.array(targets))</span></span><br><span class="line">        # 对数据进行GPU加速</span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        targets = targets.to(device)</span><br><span class="line">        # 将数据传入网路模型</span><br><span class="line">        output = model(imgs) # 分别得到每一张图片为那一个target的概率值</span><br><span class="line">        # 求解当前损失值(当前批次的损失)</span><br><span class="line">        cur_loss = loss_fn(output,targets)</span><br><span class="line">        # 求解当前训练批次的正确率</span><br><span class="line">        _, pred = torch.max(output, axis=<span class="number">1</span>)</span><br><span class="line">        cur_acc = torch.sum(targets == pred) / output.shape[<span class="number">0</span>]</span><br><span class="line">        # 求解当前训练批次的错误率</span><br><span class="line">        batch_error = torch.sum(targets != pred) / output.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        # 反向传播</span><br><span class="line">        optimizer.zero_grad() # 优化前将梯度清<span class="number">0</span></span><br><span class="line">        cur_loss.backward()        # 反向传播，求得每一个节点的梯度</span><br><span class="line">        optimizer.step()       # 对模型的每一个参数进行优化</span><br><span class="line"></span><br><span class="line">        # 将训练集下的每一轮的每一个批次的的错误率累加（跳出<span class="keyword">for</span>循环最后得到这一轮的总错误率）</span><br><span class="line">        epoch_error_rate += batch_error.item()</span><br><span class="line">        <span class="meta"># step 该训练集目前训练到多少批次</span></span><br><span class="line">        step = step +<span class="number">1</span>  # 本轮样本的训练次数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 本轮训练的每一批次的平均损失</span><br><span class="line">    train_error_rate = epoch_error_rate / step # 本轮训练的平均损失</span><br><span class="line">    print(<span class="string">&quot;train_error_rate: &#123;&#125;&quot;</span>.format(train_error_rate))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_error_rate</span><br><span class="line"></span><br><span class="line"># 定义画图函数</span><br><span class="line">def matplot_loss(train_error_relu, train_error_tanh):</span><br><span class="line">    plt.plot(train_error_relu, label=<span class="string">&#x27;error_relu&#x27;</span>)  # 画一个折线名字named = error_relu</span><br><span class="line">    plt.plot(train_error_tanh, label=<span class="string">&#x27;error_tanh&#x27;</span>)      # 画一个折线名字named = error_tanh</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)                    # （说明那条曲线是什么的标签）指定图例的位置。默认为loc=best 左上方</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;train_error_rate&#x27;</span>)                        # 二维图形的y轴名称</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)                       # 二维图形的X轴名称</span><br><span class="line">    plt.title(<span class="string">&quot;train_error_relu vs train_error_tanh&quot;</span>)       # 图的标题</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建列表用于存储数据画图</span><br><span class="line">relu_train_error_rate = []</span><br><span class="line">tanh_train_error_rate = []</span><br><span class="line"></span><br><span class="line"># 训练轮数实现</span><br><span class="line">epoch = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i in range(epoch):</span><br><span class="line">        print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;-------Relu 第 &#123;&#125; 轮训练开始------&quot;</span>.format(i + <span class="number">1</span>))</span><br><span class="line">        train_error_relu = train(i + <span class="number">1</span>, train_dataloader, model1, loss_fn, optimizer1)</span><br><span class="line">        relu_train_error_rate.append(train_error_relu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in range(epoch):</span><br><span class="line">        print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;-------Tanh 第 &#123;&#125; 轮训练开始------&quot;</span>.format(i + <span class="number">1</span>))</span><br><span class="line">        train_error_tanh = train(i + <span class="number">1</span>, train_dataloader, model2, loss_fn, optimizer2)</span><br><span class="line">        tanh_train_error_rate.append(train_error_tanh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(relu_train_error_rate)</span><br><span class="line">    print(tanh_train_error_rate)</span><br><span class="line"></span><br><span class="line">    matplot_loss(relu_train_error_rate,tanh_train_error_rate)</span><br></pre></td></tr></table></figure><h5 id="（2）结果"><a href="#（2）结果" class="headerlink" title="（2）结果"></a>（2）结果</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305091445057.png" alt="image-20230509144434172"></p><p>对上面的结果进行比较可以得到，<code>ReLu</code>的收敛速度在17轮之前确实是优于<code>tanh</code></p><h4 id="2-LRN"><a href="#2-LRN" class="headerlink" title="2.LRN"></a>2.<code>LRN</code></h4><p>论文的3.3接提到的局部响应标准化（<code>LRN</code>）有助于AlexNet泛化能力的提升，受真实的神经元<strong>侧抑制</strong>启发</p><p>**侧抑制:**细胞分化变为不同时，会对周围细胞产生抑制信号，组织他们像相同的方向分化，最终表现为细胞命运的不同</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305091459835.png" alt="image-20230509145958807"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305091500540.png" alt="image-20230509150018496"></p><ul><li>a 表示<strong>卷积层（包括卷积操作和激活操作）后的输出结果</strong>。这个输出的结果是一个四维数组 [batch,height,width,channel]。这个输出结构中的一个位置 [a,b,c,d]，可以理解成在某一张特征图中的某一个通道下的某个高度和某个宽度位置的点，即<strong>第 a 张特征图的第 d 个通道下的高度为 b 宽度为 c 的点。</strong></li><li><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305091502049.png" alt="image-20230509150204010">表示第 i 个通道的特征图在位置（x,y)运用激活函数 ReLU 后的输出。n 是同一位置上临近的 feature map 的数目，N 是特征图的总数。</li></ul><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305091504802.png" alt="image-20230509150421758"></p><p>即公式中的分母，若此处的分母越大即表示对该处的像素值抑制程度越大。若<img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305091507434.png" alt="image-20230509150754414">周围的deepth_radius范围存在较大的像素值，那么对于<img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305091509677.png">的输出存在较大的抑制</p><p>论文中提到使用<code>LRN</code>分别减少了<code>top-1</code>和<code>top-5</code>的1.4%与1.2%的错误率</p><h5 id="（1）Pyotrch中LRN的实现"><a href="#（1）Pyotrch中LRN的实现" class="headerlink" title="（1）Pyotrch中LRN的实现"></a>（1）Pyotrch中LRN的实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.LocalResponseNorm(size, alpha=<span class="number">0.0001</span>, beta=<span class="number">0.75</span>, k=<span class="number">1.0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305091514922.png" alt="image-20230509151431897"></p><p>在2014年的<code>《Very Deep Convolutional Networks for Large-Scale Image Recognition》</code>提到<code>LRN</code>技术实际用处不大</p><h4 id="3-Overall-architecture"><a href="#3-Overall-architecture" class="headerlink" title="3. Overall architecture"></a>3. Overall architecture</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305091538588.png" alt="image-20230509153832557"></p><ul><li>首先输入的是一张<code>224x224x3</code>（因为是彩色&#96;RGB三通道的图）</li><li>第一层用的卷积核的大小是 <code>11∗11∗3 </code>，卷积核的个数是<code>48+48=96</code>，从这一层开始两个<code>GPU</code>开始分开运行，现在定义处理上半层特征图的叫<code>GPU_A</code>，处理下半层特征图的叫<code>GPU_B</code>，每个<code>GPU</code>负责48个卷积核的运算，上半层<code>GPU_A</code>生成48张特征图，下半层<code>GPU_B</code>生成48张特征图。这一层卷积结束之后，还需要<code>LRN</code>（<code>Local Response Normalization </code>局部响应归一化）和<code>Max_Pooling</code>（最大池化）</li><li>第二层和第一层同理，两个<code>GPU</code>分别处理自己上一层传来的<code>output</code>（那48张特征图），卷积核的大小是 <code>5∗5∗48</code> ，然后一共有<code>128+128=256</code>个卷积核，所以两个<code>GPU</code>各自利用自己上一层的<code>output</code>生成<code>128</code>张特征图。这一层的卷积结束之后还需要<code>LRN</code>（<code>Local Response Normalization </code>局部响应归一化）和<code>Max_Pooling</code>（最大池化）</li><li>第三层和前两层不同，这一层两个<code>GPU</code>都要是将两个<code>GPU</code>的上一层的全部输出<code>output</code>作为输入<code>input</code>，所以这一层的卷积核大小是 <code>3∗3∗ （128[来自GPU_A]+128[来自GPU_B]）</code>，也就是这层的卷积核是 <code>3∗3∗256 </code>，而不是像前两层那样只是把自己上一层的输出当成输入，这层一共有<code>192+192=384</code>个卷积核，<code>GPU_A</code>负责前192个卷积核的生成的特征图，<code>GPU_B</code>负责后<code>192</code>个卷积核生成的特征图</li><li>第四层和第五层同第三层</li><li>第六层，接了一个全连接层<code>(FC)</code>，首先将<code>128[来自GPU_A]和128[来自GPU_B]</code>的一共256张特征图拉直成一个超长的向量，连接到一个大小为4096的全连接层中，其中4096个神经元的前2048个神经元由<code>GPU_A</code>运算，后2048个神经元由<code>GPU_B</code>来运算</li><li>第七层和第六层同理</li><li>第八层是再连接到一个大小为1000的全连接层中，用softmax，来算1000种分类的分布</li></ul><h5 id="（1）pytorch代码实现"><a href="#（1）pytorch代码实现" class="headerlink" title="（1）pytorch代码实现"></a>（1）pytorch代码实现</h5><p><strong><code>AlexNet.py</code></strong>,需要注意的是，目前网络全是在一块GPU上进行加速运算的，因此与原来的架构不一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    搭建AlexNet网络模型</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    1.导入库</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import torch</span><br><span class="line">import torchvision</span><br><span class="line">from torch import nn</span><br><span class="line">from torch.utils.data import DataLoader</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    2.搭建网络模型</span></span><br><span class="line"><span class="string">        # 输入为 224*224*3</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">class <span class="title function_">AlexNet</span><span class="params">(nn.Module)</span>:</span><br><span class="line">    def __<span class="title function_">init__</span><span class="params">(self, num_classes: <span class="type">int</span> = <span class="number">100</span>, dropout: <span class="type">float</span> = <span class="number">0.5</span>)</span> -&gt; None:</span><br><span class="line">        <span class="title function_">super</span><span class="params">()</span>.__<span class="title function_">init__</span><span class="params">()</span></span><br><span class="line">        self.features = nn.Sequential(</span><br><span class="line">            # Layer1</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, stride=<span class="number">4</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.LocalResponseNorm(size=<span class="number">5</span>,alpha=<span class="number">10e-4</span>,beta=<span class="number">0.75</span>,k=<span class="number">2</span>),</span><br><span class="line">            nn.ReLU(inplace=True),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">            # Layer2</span><br><span class="line">            nn.Conv2d(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>,padding=<span class="number">2</span>),</span><br><span class="line">            nn.LocalResponseNorm(size=<span class="number">5</span>, alpha=<span class="number">10e-4</span>, beta=<span class="number">0.75</span>, k=<span class="number">2</span>),</span><br><span class="line">            nn.ReLU(inplace=True),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">            # Layer3</span><br><span class="line">            nn.Conv2d(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(inplace=True),</span><br><span class="line">            # Layer4</span><br><span class="line">            nn.Conv2d(<span class="number">384</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(inplace=True),</span><br><span class="line">            # Layer5</span><br><span class="line">            nn.Conv2d(<span class="number">384</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(inplace=True),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>), # <span class="number">256</span>*<span class="number">6</span>*<span class="number">6</span></span><br><span class="line">        )</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.classifier = nn.Sequential(</span><br><span class="line">            # Linear1</span><br><span class="line">            nn.Dropout(p=dropout),</span><br><span class="line">            nn.Linear(<span class="number">256</span> * <span class="number">6</span> * <span class="number">6</span>, <span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(inplace=True),</span><br><span class="line">            # Linear2</span><br><span class="line">            nn.Dropout(p=dropout),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(inplace=True),</span><br><span class="line">            # Linear3</span><br><span class="line">            nn.Linear(<span class="number">4096</span>, num_classes),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def forward(self,x):</span><br><span class="line">        x = self.features(x)</span><br><span class="line">        x= self.flatten(x)</span><br><span class="line">        x = self.classifier(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span></span><br><span class="line"><span class="meta">#     x = torch.rand([1, 3, 224, 224])</span></span><br><span class="line"><span class="meta">#     model = AlexNet()</span></span><br><span class="line"><span class="meta">#     y = model(x)</span></span><br><span class="line"><span class="meta">#     print(y.shape)</span></span><br></pre></td></tr></table></figure><h4 id="4-Data-Augmentation-数据增强"><a href="#4-Data-Augmentation-数据增强" class="headerlink" title="4. Data Augmentation(数据增强)"></a>4. Data Augmentation(数据增强)</h4><p>论文在训练阶段使用两种数据增强的方式减少数据的过拟合，都允许用很少的计算从原始图像生成转换</p><h5 id="（1）第一种"><a href="#（1）第一种" class="headerlink" title="（1）第一种"></a>（1）第一种</h5><p>从<code>256x256</code>的图像中随机扣下<code>224x224</code>大小的图片，并进行随机的水平翻转，这样相当于将数据增加了<code>2048倍(32x32x2)</code></p><ul><li>（数据保证符合网络期望的输入数据）将短边减少到256，长边也保证高宽比往下降，长边多出来的以中心为界将两个边进行裁剪在第二节 <code>2  The Dataset</code>中提到过，<code>ImageNet</code>是一个可变分辨率的数据集因此，</li></ul><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line">    </span><br><span class="line"># 标准化所求的数据集的均值与方差</span><br><span class="line">norm_mean = [<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]</span><br><span class="line">norm_std = [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line">    </span><br><span class="line">train_transform = transforms.Compose([</span><br><span class="line">        transforms.Resize((<span class="number">256</span>)),      # (<span class="number">256</span>, <span class="number">256</span>) 区别 按照长宽比进行缩放</span><br><span class="line">        transforms.CenterCrop(<span class="number">256</span>),    # 将长边多余的地方进行裁剪</span><br><span class="line">        transforms.RandomCrop(<span class="number">224</span>),    # 随机裁剪<span class="number">224</span>*<span class="number">224</span></span><br><span class="line">        transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>),  # 以<span class="number">50</span>%的概率进行水平翻转</span><br><span class="line">        transforms.ToTensor(),                   # 转变为tensor()数据</span><br><span class="line">        transforms.Normalize(norm_mean, norm_std),  # 标准化</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h5 id="（2）第二种"><a href="#（2）第二种" class="headerlink" title="（2）第二种"></a>（2）第二种</h5><p>第二种方法改变训练图像中<code>RGB</code>通道的强度，对整个<code>ImageNet</code>训练集的<code>RGB</code>像素值集执行<code>PCA</code>主成分分析,然后对主成分上的数进行微小的扰动，以此<strong>图像色彩</strong>就会发生微小的变化，增加图像的丰富性多样性 </p><p><strong>暂时不清楚如何对其进行操作…..</strong>,在<code>AlexNet</code>实现时候效果有限</p><p>同时在测试阶段也有对数据进行的操作：</p><h5 id="（3）测试阶段数据处理"><a href="#（3）测试阶段数据处理" class="headerlink" title="（3）测试阶段数据处理"></a>（3）测试阶段数据处理</h5><p>在测试时，网络通过提取<code>5个224 × 224</code>的patch(四个角斑和中心斑)及其水平反射(共10个patch)进行预测，并将网络的<code>softmax</code>层对这10个patch的预测取平均</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">valid_transform = transforms.Compose([</span><br><span class="line">        transforms.Resize((<span class="number">256</span>, <span class="number">256</span>)),</span><br><span class="line">        transforms.TenCrop(<span class="number">224</span>, vertical_flip=False),</span><br><span class="line">        transforms.Lambda(lambda crops: torch.<span class="built_in">stack</span>([normalizes(transforms.ToTensor()(crop)) <span class="keyword">for</span> crop in crops])),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h4 id="5-Dropout"><a href="#5-Dropout" class="headerlink" title="5. Dropout"></a>5. Dropout</h4><p>在网络架构的前两个全链接层后添加<code>Dropout</code>，防止了过拟合（论文作者最开始的理解是<code>Dropout</code>是做模型融合，实际上是在正则化，之后本文作者写了一篇<code>JMLR</code>文章说明Dropout实际等价一个<code>L2</code>的正则,使用<code>Dopout</code></p><p><strong>可以提高模型的泛化性</strong></p><h4 id="6-Details-of-learning"><a href="#6-Details-of-learning" class="headerlink" title="6. Details of learning"></a>6. Details of learning</h4><p>在论文中使用<code>SGD</code>随机梯度下降法作为优化函数进行权重参数优化,其中<code>dataloader</code>中的<code>batch_size = 128</code>,<code>momentum = 0.9</code> ,<code>weight decay = 0.0005</code></p><p>训练细节：</p><ul><li>权重参数初始化，标准差&#x3D;0.01  均值&#x3D;0   的高斯正太分布</li><li>有关学习率的调整，所有层的学习率相同，但是在验证的正确率随着当前学习率停止提高时，将学习率除以10继续训练；学习率<code>learn_rate = 0.01</code>  初始值</li><li>训练拟合时，第一层卷积的可视化，也需要进行演示</li></ul><h3 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h3><h5 id="1-模型训练"><a href="#1-模型训练" class="headerlink" title="1.模型训练"></a>1.模型训练</h5><p>模型使用<code>Mini-ImageNet</code>数据集对网络模型进行训练拟合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    对网络模型进行训练拟合，并且保存模型最好的验证正确率的参数权重</span></span><br><span class="line"><span class="string">        训练数据集 使用MINI-ImageNet</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    1.导入库</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import os</span><br><span class="line">import numpy as np</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch</span><br><span class="line">from torch.utils.data import DataLoader</span><br><span class="line">import torchvision.transforms as transforms</span><br><span class="line">import torch.optim as optim</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from torchvision.datasets import ImageFolder</span><br><span class="line">from AlexNet import AlexNet</span><br><span class="line">from torch.optim import lr_scheduler</span><br><span class="line">import logging</span><br><span class="line">import colorlog</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    2.定义相关全局变量</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"># 当前Train.py文件所在的目录位置</span><br><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 得到数据集所在文件目录</span><br><span class="line">data_dir = os.path.join(BASE_DIR,<span class="string">&quot;../Mini-ImageNet/&quot;</span>)</span><br><span class="line">train_data_dir = os.path.join(data_dir,<span class="string">&quot;./new_train&quot;</span>)</span><br><span class="line">test_data_dir = os.path.join(data_dir,<span class="string">&quot;./new_test&quot;</span>)</span><br><span class="line">num_classes = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">MAX_EPOCH = <span class="number">1</span>    # 最大训练epoch</span><br><span class="line">BATCH_SIZE = <span class="number">128</span></span><br><span class="line">LR = <span class="number">0.01</span></span><br><span class="line">classes = <span class="number">100</span></span><br><span class="line">start_epoch = <span class="number">-1</span></span><br><span class="line">log_interval = <span class="number">1</span></span><br><span class="line">val_interval = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 设置<span class="built_in">log</span>输出--控制台输出并保存到文件中</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.setLevel(level=logging.INFO)</span><br><span class="line">handler = logging.FileHandler(<span class="string">&quot;../Log/log.txt&quot;</span>,mode=<span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">handler.setLevel(logging.INFO)</span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">log_colors_config = &#123;</span><br><span class="line">    <span class="string">&#x27;INFO&#x27;</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console_formatter = colorlog.ColoredFormatter(log_colors=log_colors_config)</span><br><span class="line">console = logging.StreamHandler()</span><br><span class="line">console.setFormatter(console_formatter)</span><br><span class="line">console.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"># 重复日志问题：</span><br><span class="line"># <span class="number">1</span>、防止多次addHandler；</span><br><span class="line"># <span class="number">2</span>、loggername 保证每次添加的时候不一样；</span><br><span class="line"># <span class="number">3</span>、显示完<span class="built_in">log</span>之后调用removeHandler</span><br><span class="line"><span class="keyword">if</span> not logger.handlers:</span><br><span class="line">    logger.addHandler(handler)</span><br><span class="line">    logger.addHandler(console)</span><br><span class="line"></span><br><span class="line">handler.close()</span><br><span class="line">console.close()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    3.加载训练以及验证数据集</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">norm_mean = [<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]</span><br><span class="line">norm_std = [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line"></span><br><span class="line">train_transform = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">256</span>)),      # (<span class="number">256</span>, <span class="number">256</span>) 区别</span><br><span class="line">    transforms.CenterCrop(<span class="number">256</span>),</span><br><span class="line">    transforms.RandomCrop(<span class="number">224</span>),</span><br><span class="line">    transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(norm_mean, norm_std),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">normalizes = transforms.Normalize(norm_mean, norm_std)</span><br><span class="line">valid_transform = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">256</span>, <span class="number">256</span>)),</span><br><span class="line">    transforms.TenCrop(<span class="number">224</span>, vertical_flip=False), #  一张图片会得到<span class="number">10</span>张图片 <span class="number">10</span>张图片会以<span class="built_in">list</span>形式存储</span><br><span class="line">    # 将<span class="built_in">list</span>中的图片依次去取出做normalizes()  torch.<span class="built_in">stack</span>就将<span class="number">10</span>张图片进行拼接得到一个<span class="number">4</span>D张量  [B  C  H  W]  B = <span class="number">10</span></span><br><span class="line">    transforms.Lambda(lambda crops: torch.<span class="built_in">stack</span>([normalizes(transforms.ToTensor()(crop)) <span class="keyword">for</span> crop in crops])),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 构建Dataset实例</span><br><span class="line">train_dataset = ImageFolder(train_data_dir, transform=train_transform)</span><br><span class="line">test_dataset = ImageFolder(test_data_dir, transform=valid_transform)</span><br><span class="line"></span><br><span class="line"># 构建DataLoder</span><br><span class="line">train_loader = DataLoader(dataset=train_dataset, batch_size=BATCH_SIZE, shuffle=True)</span><br><span class="line">valid_loader = DataLoader(dataset=test_dataset, batch_size=<span class="number">4</span>,shuffle=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    4.导入网络模型</span></span><br><span class="line"><span class="string">        配置损失函数</span></span><br><span class="line"><span class="string">        配置优化器</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"># 模型</span><br><span class="line">alexnet_model = AlexNet(num_classes=<span class="number">100</span>,dropout=<span class="number">0.5</span>)</span><br><span class="line">alexnet_model.to(device)</span><br><span class="line"></span><br><span class="line"># 损失函数</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">criterion = criterion.to(device)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 优化器 （对最后一层使用了softmax）--- 卷积层的学习率可以小一些  在线性层学习率可以大一些 --- trick</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="meta"># flag = 1</span></span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">    <span class="meta"># map() 会根据提供的函数对指定序列(可以迭代对象)做映射</span></span><br><span class="line">    <span class="meta"># id() 函数返回指定对象的唯一 id    id 是对象的内存地址</span></span><br><span class="line">    # 该模型有三个线性层  每个线性层对应 一个输入参数与权重的乘法  以及一个加法（偏置）对应六个id</span><br><span class="line">    fc_params_id = <span class="built_in">list</span>(<span class="built_in">map</span>(id, alexnet_model.classifier.parameters()))  # 返回的是parameters的 内存地址</span><br><span class="line">    # 如 lambda x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]   x**<span class="number">2</span> 是函数表达式  x 参数  取值范围是  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="meta"># lambda p: id(p) not in fc_params_id, alexnet_model.parameters()</span></span><br><span class="line">    # 得到的id是模型参数中 不属于 fc_params_id(线性层)列表中的id</span><br><span class="line">    <span class="meta"># filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表  filter(function, iterable)</span></span><br><span class="line">    base_params = filter(lambda p: id(p) not in fc_params_id, alexnet_model.parameters())</span><br><span class="line">    optimizer = optim.SGD([</span><br><span class="line">        &#123;<span class="string">&#x27;params&#x27;</span>: base_params, <span class="string">&#x27;lr&#x27;</span>: LR * <span class="number">0.1</span>&#125;,  # <span class="number">0</span></span><br><span class="line">        &#123;<span class="string">&#x27;params&#x27;</span>: alexnet_model.classifier.parameters(), <span class="string">&#x27;lr&#x27;</span>: LR&#125;], momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    optimizer = optim.SGD(alexnet_model.parameters(), lr=LR, momentum=<span class="number">0.9</span>)  # 选择优化器</span><br><span class="line"></span><br><span class="line"># 学习率每隔<span class="number">10</span>轮变为原来的<span class="number">0.1</span></span><br><span class="line">lr_scheduler = lr_scheduler.StepLR(optimizer, step_size=<span class="number">10</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    train_curve = <span class="built_in">list</span>()</span><br><span class="line">    train_ACC_curve = <span class="built_in">list</span>()</span><br><span class="line">    valid_curve = <span class="built_in">list</span>()</span><br><span class="line">    valid_ACC_curve = <span class="built_in">list</span>()</span><br><span class="line">    min_acc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch in range(start_epoch + <span class="number">1</span>, MAX_EPOCH):</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                5.训练网络</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        loss_mean = <span class="number">0.</span></span><br><span class="line">        correct = <span class="number">0.</span></span><br><span class="line">        total = <span class="number">0.</span></span><br><span class="line">        train_ACC = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;----------------Train: Epoch &#123;&#125;----------------------&quot;</span>.format(epoch+<span class="number">1</span>))</span><br><span class="line">        alexnet_model.train()</span><br><span class="line">        <span class="keyword">for</span> i, data in enumerate(train_loader):</span><br><span class="line"></span><br><span class="line">            <span class="meta"># forward</span></span><br><span class="line">            inputs, labels = data</span><br><span class="line">            inputs, labels = inputs.to(device), labels.to(device)</span><br><span class="line">            outputs = alexnet_model(inputs)</span><br><span class="line"></span><br><span class="line">            <span class="meta"># backward</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss = criterion(outputs, labels)</span><br><span class="line">            loss.backward()</span><br><span class="line"></span><br><span class="line">            <span class="meta"># update weights</span></span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">            # 统计分类情况</span><br><span class="line">            _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span><br><span class="line">            total += labels.size(<span class="number">0</span>)   # 累加这一轮 每一批次的样本数量 = 这一轮的总样本数量</span><br><span class="line">            correct += (predicted == labels).squeeze().cpu().sum().numpy()  # 将该轮中每一个批次预测正确的样本数量进行累加</span><br><span class="line"></span><br><span class="line">            # 打印训练信息</span><br><span class="line">            loss_mean += loss.item()  # 将该轮中每一批次的损失进行累积  得到本轮的总损失</span><br><span class="line">            train_curve.append(loss.item())</span><br><span class="line">            train_ACC = correct / total</span><br><span class="line">            train_ACC_curve.append(train_ACC)</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % log_interval == <span class="number">0</span>:   # 在本轮训练中 当训练了log_interval的批次时名就打印一次训练信息</span><br><span class="line">                loss_mean = loss_mean / log_interval</span><br><span class="line"></span><br><span class="line">                logger.info(</span><br><span class="line">                    <span class="string">&quot;Training:Epoch[&#123;:0&gt;3&#125;/&#123;:0&gt;3&#125;] Iteration[&#123;:0&gt;3&#125;/&#123;:0&gt;3&#125;] Train_Loss: &#123;:.4f&#125; Train_Acc:&#123;:.2%&#125;&quot;</span>.format(</span><br><span class="line">                        epoch + <span class="number">1</span>, MAX_EPOCH, i + <span class="number">1</span>, len(train_loader), loss_mean, train_ACC)</span><br><span class="line">                )</span><br><span class="line">                loss_mean = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">        lr_scheduler.step()  # 更新学习率</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            6.验证网络</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % val_interval == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            correct_val = <span class="number">0.</span></span><br><span class="line">            total_val = <span class="number">0.</span></span><br><span class="line">            loss_val = <span class="number">0.</span></span><br><span class="line">            Valid_Acc = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">&quot;----------------Valid: Epoch &#123;&#125;----------------------&quot;</span>.format(epoch + <span class="number">1</span>))</span><br><span class="line">            alexnet_model.eval()</span><br><span class="line">            with torch.no_grad():</span><br><span class="line">                <span class="keyword">for</span> j, data in enumerate(valid_loader):</span><br><span class="line">                    inputs, labels = data</span><br><span class="line">                    inputs, labels = inputs.to(device), labels.to(device)</span><br><span class="line"></span><br><span class="line">                    bs, ncrops, c, h, w = inputs.size()  # [<span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>]</span><br><span class="line">                    outputs = alexnet_model(inputs.view(<span class="number">-1</span>, c, h, w))  # [<span class="number">40</span>,<span class="number">3</span>,<span class="number">224</span>,<span class="number">224</span>]</span><br><span class="line">                    # 论文中对于验证的相关操作 --- 对于网络的softmax层输出的<span class="number">10</span>个patch 预测取平均</span><br><span class="line">                    <span class="meta"># outputs.view(bs, ncrops, -1)  [4,10,100]</span></span><br><span class="line">                    <span class="meta"># torch.mean(x,dim)  dim表示对于输入x的那一个维度求平均 [bs,ncrops,100].mean(1) 对dim=1求平均</span></span><br><span class="line">                    outputs_avg = outputs.view(bs, ncrops, <span class="number">-1</span>).mean(<span class="number">1</span>)  #  outputs_avg.shape = [<span class="number">4</span>,<span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">                    loss = criterion(outputs_avg, labels)</span><br><span class="line"></span><br><span class="line">                    _, predicted = torch.max(outputs_avg.data, <span class="number">1</span>)  # 该批次验证预测的结果</span><br><span class="line">                    total_val += labels.size(<span class="number">0</span>)  # 本轮累积批次验证的样本总数</span><br><span class="line">                    correct_val += (predicted == labels).squeeze().cpu().sum().numpy()  #  本轮累积批次验证正确的样本数</span><br><span class="line"></span><br><span class="line">                    loss_val += loss.item()</span><br><span class="line"></span><br><span class="line">                loss_val_mean = loss_val / len(valid_loader)  # 本轮验证 每一个批次的平均损失</span><br><span class="line">                valid_curve.append(loss_val_mean)</span><br><span class="line">                Valid_Acc = correct_val/total_val  # 本轮的平均正确率</span><br><span class="line">                valid_ACC_curve.append(Valid_Acc)</span><br><span class="line"></span><br><span class="line">                logger.info(</span><br><span class="line">                    <span class="string">&quot;Valid:\t Epoch[&#123;:0&gt;3&#125;/&#123;:0&gt;3&#125;] Iteration[&#123;:0&gt;3&#125;/&#123;:0&gt;3&#125;] Valid_Loss: &#123;:.4f&#125; Valid_Acc:&#123;:.2%&#125;&quot;</span>.format(</span><br><span class="line">                        epoch+<span class="number">1</span>, MAX_EPOCH, j + <span class="number">1</span>, len(valid_loader), loss_val_mean, Valid_Acc)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">                <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                    7.保存网络模型</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span> Valid_Acc &gt; min_acc:</span><br><span class="line">                    folder = <span class="string">&#x27;../Models&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span> not os.path.exists(folder):  # 当前目录不存在则进行创建</span><br><span class="line">                        os.mkdir(folder)</span><br><span class="line">                    min_acc = Valid_Acc</span><br><span class="line">                    logger.info(<span class="string">&quot;save best model Epoch : &#123;&#125;&quot;</span>.format(epoch + <span class="number">1</span>))</span><br><span class="line">                    # 保存权重文件</span><br><span class="line">                    torch.save(alexnet_model.state_dict(), <span class="string">&#x27;../Models/best_model_AlexNet.pth&#x27;</span>)</span><br><span class="line">                # 保存最后一轮的权重文件</span><br><span class="line">                <span class="keyword">if</span> epoch+<span class="number">1</span> == MAX_EPOCH:</span><br><span class="line">                    torch.save(alexnet_model.state_dict(), <span class="string">&#x27;../Models/last_model_AlexNet.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            alexnet_model.train()</span><br><span class="line">            logger.info(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        7.结果可视化</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    train_x = range(len(train_curve))</span><br><span class="line">    train_y = train_curve</span><br><span class="line">    train_acc_x = range(len(train_ACC_curve))</span><br><span class="line">    train_acc_y = train_ACC_curve</span><br><span class="line"></span><br><span class="line">    train_iters = len(train_loader)</span><br><span class="line">    #  由于valid中记录的是epoch_loss，需要对记录点进行转换到iterations</span><br><span class="line">    valid_x = np.arange(<span class="number">1</span>, len(valid_curve) + <span class="number">1</span>) * train_iters * val_interval</span><br><span class="line">    valid_y = valid_curve</span><br><span class="line">    valid_acc_x = np.arange(<span class="number">1</span>, len(valid_ACC_curve) + <span class="number">1</span>) * train_iters * val_interval</span><br><span class="line">    valid_acc_y = valid_ACC_curve</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    plt.plot(train_x, train_y, label=<span class="string">&#x27;Train_loss&#x27;</span>)</span><br><span class="line">    plt.plot(valid_x, valid_y, label=<span class="string">&#x27;Valid_loss&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;loss value&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Iteration&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Training and Validation Loss&#x27;</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    plt.plot(train_acc_x, train_acc_y, label=<span class="string">&#x27;Train_acc&#x27;</span>)</span><br><span class="line">    plt.plot(valid_acc_x, valid_acc_y, label=<span class="string">&#x27;Valid_acc&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;acc value&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Iteration&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Training and Validation acc&#x27;</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&#x27;End....&#x27;</span>)</span><br></pre></td></tr></table></figure><p>训练结束之后，会将最优以及最后训练的模型进行保存，此外还会将训练的日志在控制台输出以及存储至<code>log.txt</code>文件中</p><p>最后会得到<code>训练损失vs验证损失</code>  以及  <code>训练正确率vs验证正确率</code>的可视化曲线</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305121048551.png" alt="image-20230512104741717"></p><p>训练得到的结果出现过拟合的现象，大概在迭代的10000次（10000&#x2F;282&#x3D;35）轮左右出现过拟合….</p><p>训练损失在降低，但是验证损失在增加，而且此时的测试正确率不再有变化…</p><h5 id="（1）过拟合解决方法"><a href="#（1）过拟合解决方法" class="headerlink" title="（1）过拟合解决方法"></a>（1）过拟合解决方法</h5><p>过拟合出现的主要原因是因为：<strong>数据太少+模型太复杂</strong></p><ul><li>增加数据量<ul><li>多收集数据集，扩大数据集的量</li><li>数据增强（通过图片的旋转、平移、亮度、切割），增加数据的多样性</li></ul></li><li>正则化方法<ul><li><code>L1</code>正则、<code>L2</code>正则（使得某些权重<code>w</code>不会过大）</li><li>Dropout</li></ul></li><li>多模型组合</li><li>贝叶斯方法</li></ul><h5 id="（2）Pytorch实现正则化"><a href="#（2）Pytorch实现正则化" class="headerlink" title="（2）Pytorch实现正则化"></a>（2）Pytorch实现正则化</h5><p>在<code>pytorch</code>中进行<code>L2</code>正则化，最直接的方式可以直接用优化器自带的<code>weight_decay</code>选项指定权值衰减率，相当于<code>L2</code>正则化中的<code>λ</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.SGD(alexnet_model.parameters(), lr=LR, momentum=<span class="number">0.9</span>,weight_decay=<span class="number">1e-5</span>)</span><br></pre></td></tr></table></figure><p>对上述模型加入<code>L2</code>的正则，并加载之前过拟合的训练的权重参数，发现其训练正确率在下降….</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305121557715.png" alt="image-20230512155714678"></p><h4 id="2-模型测试"><a href="#2-模型测试" class="headerlink" title="2.模型测试"></a>2.模型测试</h4><p>测试集数据与验证集数据的数量是一致的均为<code>12000</code>张</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    用于测试模型的正确率</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    1.导入库</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import os</span><br><span class="line">import numpy as np</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch</span><br><span class="line">from torch.utils.data import DataLoader</span><br><span class="line">import torchvision.transforms as transforms</span><br><span class="line">from torchvision.datasets import ImageFolder</span><br><span class="line">from AlexNet import AlexNet</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    2.得到有关100分类标签的列表(按照正确的顺序)</span></span><br><span class="line"><span class="string">        参数 class_name.json的路径</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">def <span class="title function_">get_classes_name</span><span class="params">(json_path)</span>:</span><br><span class="line">    classes_name_list = <span class="built_in">list</span>()</span><br><span class="line">    with <span class="title function_">open</span><span class="params">(json_path, <span class="string">&quot;r&quot;</span>)</span> as f:</span><br><span class="line">        class_names_dict = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k,v in class_names_dict.items():</span><br><span class="line">        classes_name_list.append(v[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> classes_name_list</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    3.定义相关全局变量</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">data_dir = os.path.join(BASE_DIR,<span class="string">&quot;../Mini-ImageNet/&quot;</span>)</span><br><span class="line">test_data_dir = os.path.join(data_dir,<span class="string">&quot;./new_test&quot;</span>)</span><br><span class="line"></span><br><span class="line">path_state_dict = os.path.join(BASE_DIR, <span class="string">&quot;../Models/best_model_AlexNet.pth&quot;</span>)</span><br><span class="line">num_classes=<span class="number">100</span></span><br><span class="line"></span><br><span class="line">classes_name = <span class="built_in">list</span>()   # 用于存储 Mini-ImageNet <span class="number">100</span>分类名字的列表</span><br><span class="line">classes_name_json_path = os.path.join(BASE_DIR, <span class="string">&quot;../Mini-ImageNet/classes_name.json&quot;</span>)  # 模型参数路径</span><br><span class="line">classes_name = get_classes_name(classes_name_json_path)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    4.测试数据集</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">norm_mean = [<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]</span><br><span class="line">norm_std = [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line"></span><br><span class="line">test_transform = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">256</span>, <span class="number">256</span>)),</span><br><span class="line">    transforms.CenterCrop(<span class="number">224</span>), #  一张图片会得到<span class="number">10</span>张图片 <span class="number">10</span>张图片会以<span class="built_in">list</span>形式存储</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(norm_mean,norm_std),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">test_dataset = ImageFolder(test_data_dir, transform=test_transform)</span><br><span class="line">test_loader = DataLoader(dataset=test_dataset, batch_size=<span class="number">1</span>,shuffle=True)  # batch_size = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    5.导入网络模型</span></span><br><span class="line"><span class="string">        加载模型参数</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">alexnet_model = AlexNet(num_classes=<span class="number">100</span>,dropout=<span class="number">0.5</span>)</span><br><span class="line">pretrained_state_dict = torch.load(path_state_dict)</span><br><span class="line">alexnet_model.load_state_dict(pretrained_state_dict)</span><br><span class="line">alexnet_model.to(device)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    6.验证</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">alexnet_model.eval()</span><br><span class="line">with torch.no_grad():</span><br><span class="line">    sum = len(test_dataset)</span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data in test_loader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        imgs,targets = imgs.to(device),targets.to(device)</span><br><span class="line"></span><br><span class="line">        output = alexnet_model(imgs)</span><br><span class="line">        _, pred = torch.max(output, axis=<span class="number">1</span>)</span><br><span class="line">        predicted_point = pred[<span class="number">0</span>].item()</span><br><span class="line">        <span class="keyword">if</span> predicted_point == <span class="type">int</span>(targets.item()):</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        predicted = classes_name[predicted_point]</span><br><span class="line">        actual = classes_name[<span class="type">int</span>(targets.item())]</span><br><span class="line">        print(f<span class="number">&#x27;</span>the predicted_point is <span class="string">&quot;&#123;predicted_point&#125; &quot;</span>predicted:<span class="string">&quot;&#123;predicted&#125;&quot;</span>, Actual:<span class="string">&quot;&#123;actual&#125;&quot;</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(f&quot;the Number of samples is &#123;sum&#125;&quot;)</span></span><br><span class="line"><span class="string">print(f&quot;the Accuracy  is &#123;float(right/sum)*100&#125; %&quot;)</span></span><br></pre></td></tr></table></figure><p>测试结果与训练输出的曲线结果类似，测试正确率与验证正确率都是在 <code>50%</code> 左右（这是用过拟合的模型进行测试的）—- 第一次过拟合的模型放在<code>My_Proj/Models/model_overfitting</code>目录下</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305121119943.png" alt="image-20230512111954917"></p><h4 id="3-卷积核的可视化"><a href="#3-卷积核的可视化" class="headerlink" title="3.卷积核的可视化"></a>3.卷积核的可视化</h4><p>在论文第五节中提到，将第一层的卷积核提取出来可以看到第一层96个卷积核（<code>GPU0  GPU1</code>）分别48个卷积核</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    训练拟合后对第一层的卷积核进行可视化</span></span><br><span class="line"><span class="string">        Web端 可视化的结果存储在 Visualization_Log目录下</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    1.导入库</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import os</span><br><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">from PIL import Image</span><br><span class="line">import torchvision.transforms as transforms</span><br><span class="line">from torch.utils.tensorboard import SummaryWriter</span><br><span class="line"></span><br><span class="line">import torchvision.models as models</span><br><span class="line">import torchvision.utils as vutils</span><br><span class="line"></span><br><span class="line">from AlexNet import AlexNet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    2.定义相关全局变量</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    log_dir = os.path.join(BASE_DIR, <span class="string">&quot;../Visualization_Log&quot;</span>)   #  用于存储 web 可视化结果的目录</span><br><span class="line"></span><br><span class="line">    writer = SummaryWriter(log_dir=log_dir, filename_suffix=<span class="string">&quot;_kernel&quot;</span>)  #  创建对象  filename_suffix文件名后缀</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        3.导入模型以及预训练参数</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    path_state_dict = os.path.join(BASE_DIR, <span class="string">&quot;../Models/best_model_AlexNet.pth&quot;</span> )</span><br><span class="line">    <span class="meta"># alexnet = models.alexnet()</span></span><br><span class="line">    alexnet  = AlexNet()</span><br><span class="line">    pretrained_state_dict = torch.load(path_state_dict)</span><br><span class="line">    alexnet.load_state_dict(pretrained_state_dict)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        4.卷积核可视化</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    kernel_num = <span class="number">-1</span></span><br><span class="line">    vis_max = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> sub_module in alexnet.modules():  <span class="meta"># model.modules()迭代遍历模型的所有子层</span></span><br><span class="line">        <span class="keyword">if</span> not isinstance(sub_module, nn.Conv2d):   # 判断当前迭代的层是否是卷积层</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        kernel_num += <span class="number">1</span>  # 当前迭代的子层是卷积层</span><br><span class="line">        <span class="keyword">if</span> kernel_num &gt; vis_max:   # 大于需要可视化最大层数量时  <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        kernels = sub_module.weight</span><br><span class="line">        c_out, c_int, k_h, k_w = tuple(kernels.shape)  # c_out与下一层的特征映射图数量一致(卷积核的数量)  c_int卷积核的通道数</span><br><span class="line"></span><br><span class="line">        # 拆分channel---将单个卷积核心的每一个通道的图像可视化</span><br><span class="line">        <span class="keyword">for</span> o_idx in range(c_out):</span><br><span class="line">            kernel_idx = kernels[o_idx, :, :, :]  # 获得(C, h, w)</span><br><span class="line">            # make_grid需要 BCHW，这里拓展C维度变为（C，<span class="number">1</span>， h, w）  unsqueeze()函数起升维的作用,参数表示在哪个地方加一个维度</span><br><span class="line">            # 这样一个卷积核的 多个通道就被拆开了</span><br><span class="line">            kernel_idx = kernel_idx.unsqueeze(<span class="number">1</span>)</span><br><span class="line">            kernel_grid = vutils.make_grid(kernel_idx,normalize=True, scale_each=True, nrow=<span class="number">8</span>) <span class="meta"># normalize=True 将值缩放值 [0-1] 之间</span></span><br><span class="line">            writer.add_image(<span class="string">&#x27;&#123;&#125;_Convlayer_split_in_channel&#x27;</span>.format(kernel_num), kernel_grid, global_step=o_idx)</span><br><span class="line"></span><br><span class="line">        # 将单个卷积核 进行可视化 第一层卷积核 有<span class="number">64</span>个</span><br><span class="line">        kernel_all = kernels.view(<span class="number">-1</span>, <span class="number">3</span>, k_h, k_w)</span><br><span class="line">        kernel_grid = vutils.make_grid(kernel_all, normalize=False, scale_each=True, nrow=<span class="number">8</span>)  <span class="meta"># c, h, w</span></span><br><span class="line">        writer.add_image(<span class="string">&#x27;&#123;&#125;_all&#x27;</span>.format(kernel_num), kernel_grid, global_step=<span class="number">620</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;&#123;&#125;_convlayer shape:&#123;&#125;&quot;</span>.format(kernel_num, tuple(kernels.shape)))</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        5.可视化第一层卷积后的特征映射图</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    writer = SummaryWriter(log_dir=log_dir, filename_suffix=<span class="string">&quot;_feature map&quot;</span>)</span><br><span class="line"></span><br><span class="line">    # 输入数据</span><br><span class="line">    path_img = os.path.join(BASE_DIR, <span class="string">&quot;../../deep_eyes/A_alexnet/data/tiger cat.jpg&quot;</span>)</span><br><span class="line">    normMean = [<span class="number">0.49139968</span>, <span class="number">0.48215827</span>, <span class="number">0.44653124</span>]</span><br><span class="line">    normStd = [<span class="number">0.24703233</span>, <span class="number">0.24348505</span>, <span class="number">0.26158768</span>]</span><br><span class="line">    norm_transform = transforms.Normalize(normMean, normStd)</span><br><span class="line">    img_transforms = transforms.Compose([</span><br><span class="line">        transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        norm_transform</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    img_pil = Image.open(path_img).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">    img_tensor = img_transforms(img_pil)</span><br><span class="line">    img_tensor.unsqueeze_(<span class="number">0</span>)  <span class="meta"># chw --&gt; bchw</span></span><br><span class="line"></span><br><span class="line">    # 前向传播</span><br><span class="line">    convlayer1 = alexnet.features[<span class="number">0</span>]   #  拿到模型的第一层卷积</span><br><span class="line">    fmap_1 = convlayer1(img_tensor)    # 得到特征映射图  shape = [<span class="number">1</span>,<span class="number">64</span>,<span class="number">55</span>,<span class="number">55</span>]</span><br><span class="line"></span><br><span class="line">    # 预处理 transpose方法的作用是交换矩阵的两个维度</span><br><span class="line">    fmap_1.transpose_(<span class="number">0</span>, <span class="number">1</span>)  <span class="meta"># bchw=(1, 64, 55, 55) --&gt; (64, 1, 55, 55)</span></span><br><span class="line">    fmap_1_grid = vutils.make_grid(fmap_1, normalize=False, scale_each=True, nrow=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    writer.add_image(<span class="string">&#x27;feature map in conv1&#x27;</span>, fmap_1_grid, global_step=<span class="number">620</span>)</span><br><span class="line">    writer.close()</span><br></pre></td></tr></table></figure><p>在<code>pycharm</code>控制台的终端,进入存放web可视化文件的目录下<code>My_Proj/Visualization_Log</code>目录下</p><p>终端输入:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=./</span><br></pre></td></tr></table></figure><p>终端输出一个主机<code>host</code></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305121133692.png" alt="image-20230512113315661"></p><p>点击，会在web端的<code>0_all</code>出现可视化的第一层卷积核：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305121135618.png" alt="image-20230512113525576"></p><p>后面几层卷积核，特征相对高级，很抽象。而且卷积核尺寸小，看不懂卷积学习的内容是什么</p><p>第一层卷积最为低级，而且卷积核尺寸为<code>11x11</code>，可以看到第一层卷积学习了图片数据的颜色、纹理、边缘这些较为低级的特征。</p><p>神经网络对数据的特征进行提取符合由低级至高级特征提取的过程</p><h3 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h3><h4 id="1-重点"><a href="#1-重点" class="headerlink" title="1.重点"></a>1.重点</h4><ul><li><code>AlexNet</code>本质是一个更大更深的<code>LeNet</code>,主要改进有,<code>Dropout</code>丢弃法、<code>ReLu</code>激活函数、<code>maxpooling</code>重叠池化；<code>ReLu</code>与<code>sigmoid</code>相比梯度更大，且<code>ReLu</code>在零点处一阶导更好（减缓梯度消失），<code>maxpooling</code>取最大池化，取最大值，输出梯度更大</li><li>局部响应标准化（<code>LRN</code>）有助于<code>AlexNet</code>泛化能力的提升，受真实的神经元<strong>侧抑制</strong>启发；但是在论文<code>VGG</code>说该方法作用不大，而且有更好的<code>Batch Normalization</code></li><li><code>PCA</code>对数据集图片的颜色进行扰动，对于模型的性能提升并不大，而且实现相对复杂，目前就不实现了…</li></ul><h4 id="2-启发性"><a href="#2-启发性" class="headerlink" title="2.启发性"></a>2.启发性</h4><ul><li>初始的<code>224x224x3</code>的图片经过五层卷积之后，最后会被展平成一个<code>256x6x6</code>的向量进入线性层，直到最后一个分类层（输出层）之前，向量长度为<code>4096</code>，则一张图片会表示为<code>4096</code>的维度，<strong>这个长度为4096的向量非常好的抓住了输入图片的语义信息。若两个图片最后的4096的向量的距离（欧几里德距离非常相近的话，那么这两张图片很有可能是同一个物体的图片）————-深度学习设计的网络可以通过中间的各种隐含层的操作将一张图片最后压缩为一个特征向量（知识的压缩），而这个向量可以很好的将中间的语义信息表示出来（变成了一个机器可以理解的东西）</strong>    （论文的6.1 Qualitative  Evaluations 中提及）</li><li>将神经网络在倒数第二层的输出拿出来，得到一个长向量。然后将每个图片均拿出来，然后给定一张图片看一下和我这个向量最近的图片是谁（欧几里德距离），<strong>如果两幅图像产生的特征激活向量具有小的欧几里德距离，我们可以说神经网络认为它们是相似的（注意原始的图像之间的距离是不相近的，但是通过神经网络提取得到的高级特征向量之后，欧几里德距离是相近的）</strong>—<strong>深度神经网络的图片训练出来的最后那个向量，在语义空间的表示特别好（非常好的特征）</strong>，相似的图片会将其放在一起</li><li><code>6.1 Qualitative  Evaluations </code>最后提出可以使用<code>AlexNet</code>做图像检索、图像聚类、图像编码，利用两个4096维实值向量之间的欧氏距离来计算相似度是低效的，但通过<strong>训练自动编码器</strong>将这些向量压缩成简短的二进制码可以提高效率。这将产生一种比对原始像素应用自动编码器好得多的图像检索方法，后者不使用图像标签，因此倾向于检索具有相似边缘模式的图像，无论它们在语义上是否相似。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 论文复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAKEFILE（4）</title>
      <link href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/MAKEFILE%EF%BC%884%EF%BC%89/"/>
      <url>/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/MAKEFILE%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="MAKEFILE"><a href="#MAKEFILE" class="headerlink" title="MAKEFILE"></a>MAKEFILE</h2><ul><li><p>在Linux中，有一个叫make的东西，就相当于C语言的集成开发环境，我们只需要在make里面创建文件，写代码，make会帮我们管理这些文件</p></li><li><p>我们创建的项目不叫project，而是称为Makefile，打开一个make源程序包，发现很多Makefile的文件，说明里面有很多的项目</p></li><li><p>源程序包里面，也有名为makefile的文件（m是小写），两个命名同时存在，这是合理的，在开发一个项目的时候，工程师一般都会命名为Makefile然后打包交给用户，用户觉得某个Makefile需要改动，用户改动后或者新建后的项目定义为makefile，并且在运行时候，先执行makefile，再执行Makefile文件。</p></li><li><p>快捷操作：</p><ul><li><pre><code class="c++">vim * -p :可以vim你所创建的文件gcc *.c ：编译该文件夹下的所有.c文件在非插入的模式下：    x可以删除光标前的内容    u可以撤销前一个操作    ctrl+r 反撤销    yy 复制光标所在一行的内容    v 进入可视模式，直接移动光标选中内容，按y复制内容，然后按p/P粘贴内容。    dd 删除一整行的内容    ggVG:选中全部   y复制   d全部删除<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 一、为何使用Makefile</span><br><span class="line"></span><br><span class="line">![image-20230311145137250](https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230311145144.png)</span><br><span class="line"></span><br><span class="line">* 这个树形图展示了一个项目中的层级关系，如果我们需要变动3号文件，会发现，牵一发而动全身，改动一个被迫需要改动一堆，为了解放我们，make中编写Makefile就不再需要考虑这些，你把每个文件的依赖关系以指令的形式说明清楚并且保存下来，改动一个即可，会自动帮你修改关联到的其他文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 二、创建相关文件</span><br><span class="line"></span><br><span class="line">#### 1.创建工程文件</span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  touch main.c tool1.c tool1.h tool2.c tool2.h</span><br><span class="line">  ls</span><br><span class="line">  gedit main.c tool1.c tool1.h tool2.c tool2.h  或者  vim * -p</span><br><span class="line">      </span><br><span class="line">  vim * -p 打开该文件下所有文件   gt用于切换文件</span><br><span class="line">  ：wqa 可在vim 中方退出所有文件</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><ul><li><p>编写代码</p><ul><li><p>tool1.h</p><ul><li><pre><code class="c++">#ifndef TOOL1_H#define TOOL1_Hvoid mytool1(void);# endif<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* tool2.h</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    #ifndef TOOL2_H</span><br><span class="line">    #define TOOL2_H</span><br><span class="line">    </span><br><span class="line">    void mytool2(void);</span><br><span class="line">    </span><br><span class="line">    # endif</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>tool1.c</p><ul><li><pre><code class="c++">#include &lt;stdio.h&gt;#include &quot;tool1.h&quot;void mytool1()&#123;    printf(&quot;tool1 print\n&quot;);&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* tool2.c</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    #include &quot;tool2.h&quot;</span><br><span class="line">    </span><br><span class="line">    void mytool2()</span><br><span class="line">    &#123;</span><br><span class="line">    printf(&quot;tool2 print\n&quot;);               </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>main.c</p><ul><li><pre><code class="c++">#include &quot;tool1.h&quot;#include &quot;tool2.h&quot;int main()&#123;    mytool1();    mytool2();    return 0;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 编译代码</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    gcc *.c</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><pre><code class="c">ls<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    * ![image-20230311150527032](https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230311150527.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.文件依赖关系</span><br><span class="line"></span><br><span class="line">**.o是可执行文件**</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  a.out -&gt; main.o tool1.o tool2.o   # 可执行文件a.out依赖于后面的三个执行文件</span><br><span class="line">  main.o -&gt; main.c</span><br><span class="line">  tool1.o -&gt; tool1.c</span><br><span class="line">  tool2.o -&gt; tool2.c</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="3-编写makefile文件"><a href="#3-编写makefile文件" class="headerlink" title="3.编写makefile文件"></a>3.编写makefile文件</h4><ul><li><pre><code class="c++">终端输入：vim makefile<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* makefile文件内容</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    mytool:main.o tool1.o tool2.o</span><br><span class="line">    [TAB键]gcc main.o tool1.o tool2.o -o mytool</span><br><span class="line">    </span><br><span class="line">    main.o:main.c</span><br><span class="line">    gcc main.c -c -Wall -g -o main.o</span><br><span class="line">    tool1.o:tool1.c</span><br><span class="line">    gcc tool1.c -c -Wall -g -o tool1.o</span><br><span class="line">    tool2.o:tool2.c</span><br><span class="line">    gcc tool2.c -c -Wall -g -o tool2.o</span><br><span class="line">        </span><br><span class="line">    clean:</span><br><span class="line">    rm *.o mytool -rf   </span><br></pre></td></tr></table></figure>* 上述文件内容说明了可执行文件，以及其依赖和对应编译过程  * ```c    mytool:main.o tool1.o tool2.o               # mytool依赖于main.o tool1.o tool2.o三个可执行文件        gcc main.o tool1.o tool2.o -o mytool    # gcc使得main.o tool1.o tool2.o 生成可执行文件mytool -o 使得可执行文件命名mytool            main.o:main.c                               # main.o依赖于main.c        gcc main.c -c -Wall -g -o main.o# gcc 编译main.c -c(编译) -Wall(显示警告信息) -g(gdb调试) -o(如上)            clean:        rm *.o mytool -rf                       # 递归的删除make生成的所有.o文件以及mytool文件    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* ```c</span><br><span class="line">  终端输入：make</span><br></pre></td></tr></table></figure>* 显示结果：![image-20230311151934404](https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230311151934.png)</code></pre></li></ul><h4 id="4-执行mytool可执行文件"><a href="#4-执行mytool可执行文件" class="headerlink" title="4.执行mytool可执行文件"></a>4.执行mytool可执行文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mytool</span><br></pre></td></tr></table></figure><p>在终端输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean     #  可将makefile文件中定义 rm *.o mytool -rf指令执行 递归伤处make生成的所有.o文件以及mytool文件</span><br></pre></td></tr></table></figure><h4 id="5-makefile第二个版本"><a href="#5-makefile第二个版本" class="headerlink" title="5.makefile第二个版本"></a>5.makefile第二个版本</h4><p><strong>利用关键词去替换重复部分减少工工作量，实际过程中操作：$(简写代码)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OBJS = main.o tool1.o tool2.o</span><br><span class="line">CC = gcc</span><br><span class="line">RM = rm -f</span><br><span class="line"></span><br><span class="line">mytool:$(OBJS)</span><br><span class="line">$(CC) $(OBJS) -o mytool</span><br><span class="line"></span><br><span class="line">main.o:main.c</span><br><span class="line">$(CC) main.c -c -Wall -g -o main.o</span><br><span class="line">tool1.o:tool1.c</span><br><span class="line">$(CC) tool1.c -c -Wall -g -o tool1.o</span><br><span class="line">tool2.o:tool2.c</span><br><span class="line">$(CC) tool2.c -c -Wall -g -o tool2.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">$(RM) *.o mytool -r</span><br></pre></td></tr></table></figure><h4 id="6-makefile第三个版本"><a href="#6-makefile第三个版本" class="headerlink" title="6.makefile第三个版本"></a>6.makefile第三个版本</h4><p><strong>将编译选项定义为CFLAGS代替</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OBJS = main.o tool1.o tool2.o</span><br><span class="line">CC = gcc</span><br><span class="line">RM = rm -f</span><br><span class="line">CFLAGS += -c -Wall -g</span><br><span class="line"></span><br><span class="line">mytool:$(OBJS)</span><br><span class="line">$(CC) $(OBJS) -o mytool</span><br><span class="line"></span><br><span class="line">main.o:main.c</span><br><span class="line">$(CC) main.c $(CFLAGS) -o main.o</span><br><span class="line">tool1.o:tool1.c</span><br><span class="line">$(CC) tool1.c $(CFLAGS) -o tool1.o</span><br><span class="line">tool2.o:tool2.c</span><br><span class="line">$(CC) tool2.c $(CFLAGS) -o tool2.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">$(RM) *.o mytool -r</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-makefile第四个版本"><a href="#7-makefile第四个版本" class="headerlink" title="7.makefile第四个版本"></a>7.makefile第四个版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OBJS = main.o tool1.o tool2.o</span><br><span class="line">CC = gcc</span><br><span class="line">RM = rm -f</span><br><span class="line">CFLAGS += -c -Wall -g</span><br><span class="line"></span><br><span class="line">mytool:$(OBJS)</span><br><span class="line">$(CC) $^ -o $@</span><br><span class="line"></span><br><span class="line">main.o:main.c</span><br><span class="line">$(CC) $^ $(CFLAGS) -o main.o</span><br><span class="line">tool1.o:tool1.c</span><br><span class="line">$(CC) $^ $(CFLAGS) -o tool1.o</span><br><span class="line">tool2.o:tool2.c</span><br><span class="line">$(CC) $^ $(CFLAGS) -o tool2.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">$(RM) *.o mytool -r</span><br></pre></td></tr></table></figure><ul><li><p>上述中:</p><ul><li><pre><code class="c++">mytool:$(OBJS)    $(CC) $^ -o $@    $^ 代表上述的依赖 $(OBJS)  $@ 代表上述需要生成的目标文件   $(CC) $^ -o $@ 整体意思：GCC将上述需要依赖的文件进行-o生成上一句当中的目标文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 8.第五个版本（重点）</span><br><span class="line"></span><br><span class="line">**将格式一致的部分利用通用公式代替：**</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">OBJS = main.o tool1.o tool2.o</span><br><span class="line">CC = gcc</span><br><span class="line">RM = rm -f</span><br><span class="line">CFLAGS += -c -Wall -g</span><br><span class="line"></span><br><span class="line">mytool:$(OBJS)</span><br><span class="line">$(CC) $^ -o $@</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">$(CC) $^ $(CFLAGS) -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">$(RM) *.o mytool -r</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"># 以下部分都是格式一致：</span><br><span class="line">main.o:main.c</span><br><span class="line">$(CC) $^ $(CFLAGS) -o main.o</span><br><span class="line">tool1.o:tool1.c</span><br><span class="line">$(CC) $^ $(CFLAGS) -o tool1.o</span><br><span class="line">tool2.o:tool2.c</span><br><span class="line">$(CC) $^ $(CFLAGS) -o tool2.o</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态内存管理（3）</title>
      <link href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%883%EF%BC%89/"/>
      <url>/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><h3 id="一、相关函数原型"><a href="#一、相关函数原型" class="headerlink" title="一、相关函数原型"></a>一、相关函数原型</h3><p><strong>原则-谁申请谁释放</strong></p><p>这类函数返回值都是 void * 可以与其他指针直接赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  <span class="comment">// 此类函数的头文件</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配一个内存为 size 大小的空间---指针函数---返回一个地址（开辟的内存的地址）</span></span><br><span class="line">       <span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">       <span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配 内存为 nmenb * sizeof(size) 大小的空间，可用于数组（连续的内存空间）</span></span><br><span class="line">       <span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新将指针ptr指向的地址 分配内存为 size 大小的空间 --- ptr必须是malloc或者calloc调用后返回的某一个指针</span></span><br><span class="line"><span class="comment">// 当原来使用malloc或者calloc开辟的内存空间不够时，若原来的地址后续内存足够，则在原来的地址的基础上进行扩充</span></span><br><span class="line"><span class="comment">// 若原来的地址后续内存不够，则会将原来malloc或者calloc开辟的内存空间进行释放重新找一块内存空间</span></span><br><span class="line">       <span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新分配连续的空间</span></span><br><span class="line">       <span class="type">void</span> *<span class="title function_">reallocarray</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、函数使用与注意事项"><a href="#二、函数使用与注意事项" class="headerlink" title="二、函数使用与注意事项"></a>二、函数使用与注意事项</h3><h4 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1.malloc()"></a>1.<code>malloc()</code></h4><p><strong>实例程序–<code>malloc()</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">        p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 强制转换(int *)可以省略，malloc()返回值为void *</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);   <span class="comment">// 程序异常时，提前终止程序运行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *p = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p --&gt; %d\n&quot;</span>,p,*p);</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>实例程序(分配连续的空间内存，用于数组)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建连续的空间内存</span></span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * num);</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,p+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-内存泄漏"><a href="#2-内存泄漏" class="headerlink" title="2.内存泄漏"></a>2.内存泄漏</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        p = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        func(p,num);  </span><br><span class="line">        <span class="built_in">free</span>(p);  <span class="comment">// 此时释放p相当于释放一个空指针</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>该程序存在内存泄漏，<code>func()</code>函数中的形式参数<code>int *p </code> 为局部变量，当<code>main()</code>中调用该函数结束后，p的指针就会被释放，但是<code>malloc(n)</code>是动态开辟的内存，只能进行主动释放，此时p指针已经被释放，不会指向此动态开辟的内存，因此这块动态开辟内存就会丢失</strong></p><p>修改程序</p><p>方法1:<strong>二级指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> **p,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        *p = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(*p == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        func(&amp;p,num);  <span class="comment">// 函数传入的是 main()函数中定义的int *p的地址，func函数调用结束也不会对其存在影响，因此*p仍然直线malloc(n)开辟的内存</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2: <strong>返回指针</strong>—-<strong>指针函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> **p,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        *p = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(*p == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        p = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span> )</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        func(p,num);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-野指针的使用"><a href="#3-野指针的使用" class="headerlink" title="3.野指针的使用"></a>3.野指针的使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;malloc() error! \n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *p = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p----&gt;%d\n&quot;</span>,p,*p);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">        *p = <span class="number">123</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p----&gt;%d\n&quot;</span>,p,*p);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230308220924.png" alt="image-20230308220924668"></p><p>在上述的运行结果，虽然<code>free（p）</code>之后的结果，对<code>*p</code>进行赋值，输出<code>*p</code>的值以及指针变量p里面存储的地址值(<strong>发现不变，仍然指向之前动态开辟的内存空间</strong>)，但是实际此时的<code>p</code>已经是一个<strong>野指针（或者悬空指针）</strong>，可能由于编译器的问题里面对应的地址值并没有变化，若程序在释放p之后在该地址出存储了一个特别重要的变量，这样操作将会造成很危险的结果，因此需要在释放的之后在该指针有下一个合法的指向之前对指针<code>p</code>赋值为<code>NULL</code><br><strong>悬空指针</strong>:是指向了一个已经被释放或无效的内存地址的指针。这种情况经常发生在一些编程错误中，例如在C或C++等低级编程语言中，当对象被删除或内存被释放后，任何仍然引用该内存地址的指针都可能变成悬空指针</p><p><strong>修改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;malloc() error! \n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *p = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p----&gt;%d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;  <span class="comment">// 在指针P有下一个合法的指向之前指向为NULL </span></span><br><span class="line"></span><br><span class="line">        *p = <span class="number">123</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p----&gt;%d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230308221752.png" alt="image-20230308221752696"></p><p><strong>上述结果出现段错误，因为free()实际并没有将该段地址中的值清除掉，而是变量p对于开辟的内存空间再也没有引用的权限，此时的指针<code>p</code>以及为NULL，无法对其在进行赋值</strong></p><h4 id="4-传入的指针参数，作为临时（局部）变量"><a href="#4-传入的指针参数，作为临时（局部）变量" class="headerlink" title="4. 传入的指针参数，作为临时（局部）变量"></a>4. 传入的指针参数，作为临时（局部）变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出数组中第 i 个元素 ， 使用指针p 指向arr[i-1]</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElem</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> i,<span class="type">int</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);  <span class="comment">// 得到传入数组的长度</span></span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;length)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 使得指针p 指向arr[i-1]</span></span><br><span class="line">        p = &amp;arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">list</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        GetElem(<span class="built_in">list</span>,i,p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译结果</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230308224213.png"></p><p><strong>原因:</strong> C语言中如果一个函数接受一个数组作为参数，那么数组将会被退化为指针，正确的用法不在其他函数内部使用<code>sizeof()</code>函数</p><p>而是在<code>main()</code>函数中将数组的长度计算出来得到&#96;length,在进一步将length作为参数传入值函数中</p><p><strong>运行结果:</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230308224626.png" alt="image-20230308224626590"></p><p><strong>最后得到的结果,p指针指向的是一个不确定的区块，可以将p仍然看作为野指针</strong></p><p><strong>原因：在调用函数GetElem()之后，传入的指针作为局部变量，函数调用完，指针p中就被释放，又被指向不确定区块</strong></p><p><strong>改正1，将指针变量作为返回值返回</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">GetElem</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> i,<span class="type">int</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;length)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        p = &amp;arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">list</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        p = GetElem(<span class="built_in">list</span>,i,p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后得到期望的值</span></span><br></pre></td></tr></table></figure><p><strong>改正2，二级指针操作函数参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElem</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> i,<span class="type">int</span> **p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;length)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        *p = &amp;arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">list</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        GetElem(<span class="built_in">list</span>,i,&amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后得到期望的值</span></span><br></pre></td></tr></table></figure><p><strong>例程2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> *q,<span class="type">int</span>* c,<span class="type">int</span>* d)</span></span><br><span class="line">&#123;</span><br><span class="line">        p = c;</span><br><span class="line">        q = d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> d=<span class="number">6</span>;</span><br><span class="line">        <span class="type">int</span> *p = &amp;a;</span><br><span class="line">        <span class="type">int</span> *q = &amp;b;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p:%d----*q:%d\n&quot;</span>,*p,*q);</span><br><span class="line">        swap(p,q,&amp;c,&amp;d);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p:%d----*q:%d\n&quot;</span>,*p,*q);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在函数swap()中使得指针p，q重新指向c,d，此操作无效，因为传入的指针，作为局部变量，在函数中对指针进行重新指向的操作，在函数调用结束之后，指针将指向原来的值</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230308225342.png" alt="image-20230308225342832"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造类型（2）</title>
      <link href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B%EF%BC%882%EF%BC%89/"/>
      <url>/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="构造类型"><a href="#构造类型" class="headerlink" title="构造类型"></a>构造类型</h2><h3 id="一、结构体"><a href="#一、结构体" class="headerlink" title="一、结构体"></a>一、结构体</h3><p>将不同类型的数据存储在同一个内存空间</p><p><strong>类型描述</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名字</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>;</span><br><span class="line">    数据类型 成员<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 结构体的类型描述（只是表明这种数据结构由哪些类型的数据组成）不占用存储空间，无法直接用等号初始化</span></span><br><span class="line">如;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名字 变量名</span></span><br><span class="line"><span class="class">如：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">zxz</span>;</span>    </span><br></pre></td></tr></table></figure><h4 id="1-结构体的内存（地址对齐）"><a href="#1-结构体的内存（地址对齐）" class="headerlink" title="1.结构体的内存（地址对齐）"></a>1.结构体的内存（地址对齐）</h4><p><strong>对于内存中放置不同类型的数据的对齐信息都有考量—因为有了该对齐信息—可以让CPU很快的找到数据</strong>，地址对齐方便硬件取地址</p><p>代码1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> NAMESIZE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> <span class="title">st</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> *<span class="title">p</span> =</span> &amp;st;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct(p) = %ld\n&quot;</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct(st) = %ld\n&quot;</span>,<span class="keyword">sizeof</span>(st));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果 <strong>因为当前运行程序的机器环境为64位，所以指针大小为8个字节，而结构体<code>st</code>的大小为12字节</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230305095244.png" alt="image-20230305095236954"></p><p>代码2</p><p>在结构体中，添加一个字节 <code>ch2</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> NAMESIZE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">char</span> ch2;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> <span class="title">st</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> *<span class="title">p</span> =</span> &amp;st;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct(p) = %ld\n&quot;</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct(st) = %ld\n&quot;</span>,<span class="keyword">sizeof</span>(st));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，与代码1结果相同</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230305095900.png" alt="image-20230305095900069"></p><p>代码3</p><p>将<code>float f</code>放到<code>ch</code>与<code>ch1</code>之间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> NAMESIZE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">        <span class="type">char</span> ch2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> <span class="title">st</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> *<span class="title">p</span> =</span> &amp;st;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct(p) = %ld\n&quot;</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct(st) = %ld\n&quot;</span>,<span class="keyword">sizeof</span>(st));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果存在不同，<strong>指针仍是8字节，但是结构体不同，为16字节</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230305100140.png" alt="image-20230305100140476"></p><p>出现上面的情况是由于<strong>机器的地址对齐</strong>造成的</p><p><strong>参考公式</strong>： <code>addr % sizeof(i) </code> 如可以整除则变量i存储在该地址处</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230305102810.png" alt="image-20230305102810599"><strong>让机器不地址对齐</strong></p><p><strong>在结构体后声明关键词<code>__attributr__((packed))</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> NAMESIZE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">        <span class="type">char</span> ch2;</span><br><span class="line">&#125;__attributr__((packed));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> <span class="title">st</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> *<span class="title">p</span> =</span> &amp;st;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct(p) = %ld\n&quot;</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct(st) = %ld\n&quot;</span>,<span class="keyword">sizeof</span>(st));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，<strong>结构体内存大小发生了变化</strong>，为10字节，即4+1+4+1 &#x3D; 12</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230305102157.png" alt="image-20230305102157819"></p><h3 id="二、共用体"><a href="#二、共用体" class="headerlink" title="二、共用体"></a>二、共用体</h3><h4 id="1-共用体"><a href="#1-共用体" class="headerlink" title="1. 共用体"></a>1. 共用体</h4><p><strong>形式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 该共用体a为4字节  ch为1字节   因此un大小为4字节</span></span><br><span class="line"><span class="comment">// 创建对象 共用体a</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">un</span> <span class="title">a</span></span></span><br><span class="line"><span class="class"> </span></span><br></pre></td></tr></table></figure><p><strong>共用体的所占内存为：共用体内存大小为 共用体所包含的数据中所占内存最大的数据的内存大小</strong></p><p>实例程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">union test_un</span><br><span class="line">&#123;</span><br><span class="line">        int i;</span><br><span class="line">        float f;  // 4字节</span><br><span class="line">        double d; // 共用体中内存最大的8字节</span><br><span class="line">        char ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        union test_un a;</span><br><span class="line">        a.f = 345.678;</span><br><span class="line">        printf(&quot;%f\n&quot;,a.f);</span><br><span class="line">        printf(&quot;%ld\n&quot;,sizeof(a));</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果   <strong>该共用体变量此时的内存大小为8字节，即double变量的内存大小</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230306092733.png" alt="image-20230306092726474"></p><h4 id="2-硬件存储"><a href="#2-硬件存储" class="headerlink" title="2. 硬件存储"></a>2. 硬件存储</h4><p>硬件存储数据两种方式：</p><p>大端：数据的第一位存在高地址中</p><p>小端：数据的第一位存在低地址中</p><h3 id="三、枚举"><a href="#三、枚举" class="headerlink" title="三、枚举"></a>三、枚举</h3><p>枚举类型可以视作<strong>有值的宏</strong>进行使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span>&#123;</span></span><br><span class="line">        MON = <span class="number">1</span>,</span><br><span class="line">        TUS,</span><br><span class="line">        THR,</span><br><span class="line">        WES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">a</span> =</span> MON;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">b</span> =</span> WES;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230307213550.png" alt="image-20230307213542982"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow 入门教程（2）</title>
      <link href="/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Tensorflow/Tensorflow%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
      <url>/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Tensorflow/Tensorflow%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Tensorflow教程（2）"><a href="#Tensorflow教程（2）" class="headerlink" title="Tensorflow教程（2）"></a>Tensorflow教程（2）</h2><p><strong>通过Tensorflow实现经典的卷积神经网络</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305050935919.png" alt="image-20230505093533845"></p><h3 id="一、LeNet"><a href="#一、LeNet" class="headerlink" title="一、LeNet"></a>一、LeNet</h3><p>卷积神经网络的开山之作(1998)</p><p>文章链接：<a href="https://www.researchgate.net/publication/2985446_Gradient-Based_Learning_Applied_to_Document_Recognition">Gradient-Based Learning Applied to Document Recognition</a></p><p>论文解读：<a href="https://zhuanlan.zhihu.com/p/273247515">Lenet5经典论文解读</a></p><h4 id="1-代码实现："><a href="#1-代码实现：" class="headerlink" title="1.代码实现："></a>1.代码实现：</h4><h5 id="（1）网络架构"><a href="#（1）网络架构" class="headerlink" title="（1）网络架构"></a>（1）网络架构</h5><p>LeNet时代没有<code>BN</code>以及<code>Dropout</code></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041146781.png" alt="image-20230504114615690"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041147270.png" alt="image-20230504114719184"></p><h5 id="（2）代码"><a href="#（2）代码" class="headerlink" title="（2）代码"></a>（2）代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    Tensorflow实现LeNet</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import tensorflow as tf</span><br><span class="line">import os</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">np.set_printoptions(threshold=np.inf)</span><br><span class="line"></span><br><span class="line"># 加载数据集</span><br><span class="line">cifar10 = tf.keras.datasets.cifar10</span><br><span class="line">(x_train, y_train), (x_test, y_test) = cifar10.load_data()</span><br><span class="line"># 对输入数据进行皈依化</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LeNet5(tf.keras.Model):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(LeNet5, self).__init__()</span><br><span class="line">        self.c1 = tf.keras.layers.Conv2D(filters=<span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">                         activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.p1 = tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.c2 = tf.keras.layers.Conv2D(filters=<span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">                         activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.p2 = tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.flatten = tf.keras.layers.Flatten()</span><br><span class="line">        self.f1 = tf.keras.layers.Dense(<span class="number">120</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.f2 = tf.keras.layers.Dense(<span class="number">84</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.f3 = tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    def call(self, x):</span><br><span class="line">        x = self.c1(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line"></span><br><span class="line">        x = self.c2(x)</span><br><span class="line">        x = self.p2(x)</span><br><span class="line"></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.f1(x)</span><br><span class="line">        x = self.f2(x)</span><br><span class="line">        y = self.f3(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = LeNet5()</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">checkpoint_save_path = <span class="string">&quot;./checkpoint/LeNet5.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    print(<span class="string">&#x27;-------------load the model-----------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br><span class="line"></span><br><span class="line">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,</span><br><span class="line">                                                 save_weights_only=True,</span><br><span class="line">                                                 save_best_only=True)</span><br><span class="line"></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>,</span><br><span class="line">                    callbacks=[cp_callback])</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="meta"># print(model.trainable_variables)</span></span><br><span class="line">file = open(<span class="string">&#x27;./weights.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> v in model.trainable_variables:</span><br><span class="line">    file.write(str(v.name) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(str(v.shape) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(str(v.numpy()) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">##############################################<span class="meta">#    show   ###############################################</span></span><br><span class="line"></span><br><span class="line"># 显示训练集和验证集的acc和loss曲线</span><br><span class="line">acc = history.history[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(acc, label=<span class="string">&#x27;Training Accuracy&#x27;</span>)</span><br><span class="line">plt.plot(val_acc, label=<span class="string">&#x27;Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(loss, label=<span class="string">&#x27;Training Loss&#x27;</span>)</span><br><span class="line">plt.plot(val_loss, label=<span class="string">&#x27;Validation Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="二、AlexNet"><a href="#二、AlexNet" class="headerlink" title="二、AlexNet"></a>二、AlexNet</h3><h4 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现"></a>1.代码实现</h4><p>论文原文中使用的是<code>LRN</code>操作，与<code>BN</code>操作类似</p><h5 id="（1）网络架构-1"><a href="#（1）网络架构-1" class="headerlink" title="（1）网络架构"></a>（1）网络架构</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041846834.png" alt="image-20230504184654735"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041857446.png" alt="image-20230504185755388"></p><h5 id="（2）代码-1"><a href="#（2）代码-1" class="headerlink" title="（2）代码"></a>（2）代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import os</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from tensorflow.keras.layers import Conv2D, BatchNormalization, Activation, MaxPool2D, Dropout, Flatten, Dense</span><br><span class="line">from tensorflow.keras import Model</span><br><span class="line"></span><br><span class="line">np.set_printoptions(threshold=np.inf)</span><br><span class="line"></span><br><span class="line">cifar10 = tf.keras.datasets.cifar10</span><br><span class="line">(x_train, y_train), (x_test, y_test) = cifar10.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlexNet8(Model):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(AlexNet8, self).__init__()</span><br><span class="line">        self.c1 = Conv2D(filters=<span class="number">96</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">        self.b1 = BatchNormalization()</span><br><span class="line">        self.a1 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p1 = MaxPool2D(pool_size=(<span class="number">3</span>, <span class="number">3</span>), strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.c2 = Conv2D(filters=<span class="number">256</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">        self.b2 = BatchNormalization()</span><br><span class="line">        self.a2 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p2 = MaxPool2D(pool_size=(<span class="number">3</span>, <span class="number">3</span>), strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.c3 = Conv2D(filters=<span class="number">384</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                         activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">                         </span><br><span class="line">        self.c4 = Conv2D(filters=<span class="number">384</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                         activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">                         </span><br><span class="line">        self.c5 = Conv2D(filters=<span class="number">256</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                         activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p3 = MaxPool2D(pool_size=(<span class="number">3</span>, <span class="number">3</span>), strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.f1 = Dense(<span class="number">2048</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d1 = Dropout(<span class="number">0.5</span>)</span><br><span class="line">        self.f2 = Dense(<span class="number">2048</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d2 = Dropout(<span class="number">0.5</span>)</span><br><span class="line">        self.f3 = Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    def call(self, x):</span><br><span class="line">        x = self.c1(x)</span><br><span class="line">        x = self.b1(x)</span><br><span class="line">        x = self.a1(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line"></span><br><span class="line">        x = self.c2(x)</span><br><span class="line">        x = self.b2(x)</span><br><span class="line">        x = self.a2(x)</span><br><span class="line">        x = self.p2(x)</span><br><span class="line"></span><br><span class="line">        x = self.c3(x)</span><br><span class="line"></span><br><span class="line">        x = self.c4(x)</span><br><span class="line"></span><br><span class="line">        x = self.c5(x)</span><br><span class="line">        x = self.p3(x)</span><br><span class="line"></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.f1(x)</span><br><span class="line">        x = self.d1(x)</span><br><span class="line">        x = self.f2(x)</span><br><span class="line">        x = self.d2(x)</span><br><span class="line">        y = self.f3(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = AlexNet8()</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">checkpoint_save_path = <span class="string">&quot;./checkpoint/AlexNet8.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    print(<span class="string">&#x27;-------------load the model-----------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br><span class="line"></span><br><span class="line">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,</span><br><span class="line">                                                 save_weights_only=True,</span><br><span class="line">                                                 save_best_only=True)</span><br><span class="line"></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>,</span><br><span class="line">                    callbacks=[cp_callback])</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="meta"># print(model.trainable_variables)</span></span><br><span class="line">file = open(<span class="string">&#x27;./weight_txt/weights.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> v in model.trainable_variables:</span><br><span class="line">    file.write(str(v.name) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(str(v.shape) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(str(v.numpy()) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">##############################################<span class="meta">#    show   ###############################################</span></span><br><span class="line"></span><br><span class="line"># 显示训练集和验证集的acc和loss曲线</span><br><span class="line">acc = history.history[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(acc, label=<span class="string">&#x27;Training Accuracy&#x27;</span>)</span><br><span class="line">plt.plot(val_acc, label=<span class="string">&#x27;Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(loss, label=<span class="string">&#x27;Training Loss&#x27;</span>)</span><br><span class="line">plt.plot(val_loss, label=<span class="string">&#x27;Validation Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="3-VGGNet"><a href="#3-VGGNet" class="headerlink" title="3.VGGNet"></a>3.VGGNet</h4>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> Tensorflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组-函数-指针（1）</title>
      <link href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E6%95%B0%E7%BB%84-%E5%87%BD%E6%95%B0-%E6%8C%87%E9%92%88%EF%BC%881%EF%BC%89/"/>
      <url>/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C/%E6%95%B0%E7%BB%84-%E5%87%BD%E6%95%B0-%E6%8C%87%E9%92%88%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="数组-函数-指针"><a href="#数组-函数-指针" class="headerlink" title="数组-函数-指针"></a>数组-函数-指针</h2><h3 id="1-注释方法"><a href="#1-注释方法" class="headerlink" title="1. 注释方法"></a>1. 注释方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-空指针与野指针"><a href="#2-空指针与野指针" class="headerlink" title="2. 空指针与野指针"></a>2. 空指针与野指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空指针</span></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 野指针 : 指针无确定指向，就发生了指针的使用</span></span><br><span class="line">如何杜绝： 定义指针开始就应该初始化，或者使其指向<span class="literal">NULL</span></span><br><span class="line">        如:<span class="type">int</span> *p = <span class="number">123</span>; <span class="comment">// 野指针</span></span><br></pre></td></tr></table></figure><h3 id="3-空类型指针"><a href="#3-空类型指针" class="headerlink" title="3. 空类型指针"></a>3. 空类型指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p; <span class="comment">// 可以赋给任意类型的指针</span></span><br></pre></td></tr></table></figure><h3 id="4-指针与数组"><a href="#4-指针与数组" class="headerlink" title="4. 指针与数组"></a>4. 指针与数组</h3><h4 id="（1）指针与一维数组"><a href="#（1）指针与一维数组" class="headerlink" title="（1）指针与一维数组"></a>（1）指针与一维数组</h4><p><strong>可以使用一级指针指向一维数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%p--&gt;%d\n&quot;</span>,&amp;a[i],a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义指针指向一维数组(数组名a代表数组第一个元素地址（a为地址常量，右值）)</span></span><br><span class="line">        <span class="type">int</span> *p = a;</span><br><span class="line">        <span class="comment">// 此时指针指向数组的第一个元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第一个元素地址: %p--&gt; 第一个元素为: %d\n&quot;</span>,p,*p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%p--&gt;%d\n&quot;</span>,(p+i),*(p+i));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="（2）指针与二维数组"><a href="#（2）指针与二维数组" class="headerlink" title="（2）指针与二维数组"></a>（2）指针与二维数组</h4><p><strong>Warning:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> *p = a;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p   %p\n&quot;</span>,a,a+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%p --&gt; %d\n&quot;</span>,&amp;a[i][j],a[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后会出现以下Warning:</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230304155807.png" alt="image-20230304155807863"></p><p>运行之后发现：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230304155820.png" alt="image-20230304155820132"></p><p><strong>数组名a是：a[0] [0]的地址 a,a+1是：a[1] [0]的地址，a+1 是在行间进行跳跃，而p指向的是二维数组首地址，p+1指向的是a[0] [1],p是在列之间进行跳跃</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line"><span class="comment">// 上述代码进行修改：</span></span><br><span class="line"><span class="type">int</span> *p = *(a+<span class="number">0</span>);   <span class="comment">// 对行地址取星，相当于降级为列地址 如此运行不会有Warning</span></span><br></pre></td></tr></table></figure><hr><p>对于二维数组也可以如此遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> *p = *a;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p   %p\n&quot;</span>,a,a+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// *(a+i) 变为列地址在后续进行+j，地址在列上进行移动</span></span><br><span class="line">                    <span class="comment">// *(*(a+i)+j) 得到的是a[i][j] 的元素 </span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%p --&gt; %d\n&quot;</span>,*(a+i)+j,*(*(a+i)+j));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><strong>通过列指针p进行遍历二维数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = *a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p   %p\n&quot;</span>,a,a+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// p指针为列指针，在列之间进行跳跃</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p --&gt; %d\n&quot;</span>,p+i,*(p+i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h5 id="数组指针-重点"><a href="#数组指针-重点" class="headerlink" title="数组指针(重点)"></a>数组指针(重点)</h5><p><strong>指向数组的指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 (*指针名)[] = 二维数组首地址;</span><br></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数组指针，指向数组a，指针 p+1 移动大小为 3个整型字节大小，类似于行指针，通过“*”号 *(p+i) 进行降级，变为列指针，在列之间进行操作</span></span><br><span class="line"><span class="comment">// 数组指针p 指向的对象为 int[3] 存有三个整型字节的一维度数组</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>] = a; </span><br></pre></td></tr></table></figure><p><strong>例程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 定义一个指针数组</span></span><br><span class="line">        <span class="type">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 指向的内存为大小为三个整型字节的一维数组地址，此时不会上一个程序有Warning,因为p+1移动大小为3个整型字节的大小，类似于行指针。而a+1同样如此移动三个整型字节的大小</span></span><br><span class="line">        <span class="comment">// 同样可以通过 *(p+1)对行指针进行降级 变为列指针</span></span><br><span class="line">        p = a;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p----&gt;%d---&gt;%p----&gt;%d\n&quot;</span>,p,(*p)[<span class="number">0</span>],p+<span class="number">1</span>,*(p+<span class="number">1</span>)[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p----&gt;%d----&gt;%p---&gt;%d\n&quot;</span>,a,(*a)[<span class="number">0</span>],a+<span class="number">1</span>,*(a+<span class="number">1</span>)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// *(p+i),用*号是的p降级从行指针变为列指针，可在列之间操作</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%p --&gt; %d\n&quot;</span>,*(p+i)+j,*(*(p+i)+j));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230304163440.png" alt="image-20230304163440412"></p><h3 id="5-指针数组"><a href="#5-指针数组" class="headerlink" title="5.指针数组"></a>5.指针数组</h3><p><strong>定义一个数组，里面的元素为指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型 *数组名 [长度];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 指针数组p，里面的元素均为int *,地址</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>] = &#123;&amp;a,&amp;b,&amp;c&#125;;</span><br></pre></td></tr></table></figure><p><strong>例程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 指针数组p，里面的元素均为int *,地址</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>] = &#123;&amp;a,&amp;b,&amp;c&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p---%p---%p\n&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d---%d---%d\n&quot;</span>,*p[<span class="number">0</span>],*p[<span class="number">1</span>],*p[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-指针函数与函数指针"><a href="#6-指针函数与函数指针" class="headerlink" title="6.指针函数与函数指针"></a>6.指针函数与函数指针</h3><h4 id="（1）指针函数"><a href="#（1）指针函数" class="headerlink" title="（1）指针函数"></a>（1）指针函数</h4><p>指针函数本质还是一个函数，返回为一个指针，地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret *<span class="title function_">func</span><span class="params">(args, ...)</span>;</span><br></pre></td></tr></table></figure><p><code>func</code>是一个函数，<code>args</code>是形参列表，<code>ret *</code>作为一个整体，是 <code>func</code>函数的返回值，是一个指针的形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义指针函数</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> result;  <span class="comment">//此处变量为静态局部变量</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">result = a + b;</span><br><span class="line">p = &amp;result;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = sum(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the result is %d&quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例二:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义指针函数</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> result;      <span class="comment">//此时变量为，普通局部变量</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">result = a + b;</span><br><span class="line">p = &amp;result;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = sum(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the result is %d&quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230304165649.png" alt="image-20230304165649028"></p><p><strong>上述两个实例，结果输出，并无差别，但是如果我们在main函数中做一些修改如下：</strong></p><p><strong>示例三：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义指针函数</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> result;      <span class="comment">//此时变量为，普通局部变量</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">result = a + b;</span><br><span class="line">p = &amp;result;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = sum(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wait for a while...\n&quot;</span>);    <span class="comment">//此处加一句打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the result is %d&quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/20230304165818.png" alt="image-20230304165818314"></p><p><strong>出现以上结果的原因：</strong></p><ul><li>一般的<strong>局部变量存在在栈区</strong>，当函数结束，栈区变量就会释放，倘若在函数内部定义一个局部变量，在使用指针指向该变量,当函数调用结束，这个变量的空间就会被释放。这是放回该地址的指针，也不一定得到正确的结果，上述<strong>示例一、示例二</strong>，在返回指针后，立马访问也是巧合。<strong>但是如果我们等待一段时间再去访问，这是可能该地址，可能地址以及被其他变量所占用</strong></li><li><strong>解决方法：</strong><ul><li>在函数内，使用static去修饰需要返回地址的变量，该变量就会变成静态变量，<strong>静态变量存放在数据段。静态变量的生命周期为整个程序的运行周期</strong></li><li>使用全局变量，<strong>全局变量同样存放在数据段，其生命周期为整个程序的运行周期</strong>，但是不推荐！</li></ul></li></ul><h4 id="（2）函数指针"><a href="#（2）函数指针" class="headerlink" title="（2）函数指针"></a>（2）函数指针</h4><p><strong>函数指针本质还是指针，指向函数的指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret (*p)(args, ...);</span><br><span class="line"><span class="comment">//ret为返回值，*p作为一个整体，代表的是指向该函数的指针，args为形参列表。其中p被称为函数指针变量 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>; </span><br><span class="line"><span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure><p><strong>函数指针初始化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数指针变量 = 函数名;</span><br></pre></td></tr></table></figure><p><strong>实例程序</strong></p><p>以下实例声明了函数指针变量 p，指向函数 max：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* p 是函数指针 */</span><br><span class="line">    int (* p)(int, int) = &amp; max; // &amp;可以省略</span><br><span class="line">    int a, b, c, d;</span><br><span class="line">    printf(&quot;请输入三个数字:&quot;);</span><br><span class="line">    scanf(&quot;%d %d %d&quot;, &amp; a, &amp; b, &amp; c);</span><br><span class="line">    /* 与直接调用函数等价，d = max(max(a, b), c) */</span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line">    printf(&quot;最大的数字是: %d\n&quot;, d);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下实例声明了函数指针变量p，指向函数sum</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>(*p)(<span class="type">int</span> a, <span class="type">int</span> b);<span class="comment">//定义一个函数指针---指向函数的指针</span></span><br><span class="line">p = &amp;sum;   <span class="comment">//此处的&amp;可以省略，p=sum----&gt;满足：函数指针变量=函数名</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> result = p(p(a,b),c);<span class="comment">//等价sum(sum(a,b),c)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the result is %d&quot;</span>,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）函数指针数组"><a href="#（3）函数指针数组" class="headerlink" title="（3）函数指针数组"></a>（3）函数指针数组</h4><p><strong>定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型 (*数组名[下标]) (形参)</span><br><span class="line">如：</span><br><span class="line">    <span class="type">int</span> (*arr[N])(<span class="type">int</span>)    如何理解：先看括号，首先是一个数组其次是一个指针 括号中整体就是 指针数组；最后还是一个函数；三者组合就是 函数指针数组</span><br></pre></td></tr></table></figure><h4 id="（4）回调函数"><a href="#（4）回调函数" class="headerlink" title="（4）回调函数"></a>（4）回调函数</h4><p>回调函数通过<strong>函数指针</strong>调用</p><p>的函数。<strong>其将函数指针作为一个参数，传递给另一个函数。回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。</strong></p><p>函数指针的一个非常典型的应用就是<strong>回调函数</strong></p><p><strong>回调函数是由别人的函数执行时调用你实现的函数。</strong></p><p><strong>实例程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能:累加求和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func_sum</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;n must be &gt; 0\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，其中第二个参数是一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> (*p)(<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> p(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thr sum is from 0 to %d is %d\n&quot;</span>,n,callback(n,func_sum));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用回调函数的优势:</strong></p><p>在这个程序中，回调函数callback无需关心<code>func_sum</code>是怎么实现的，只需要去调用即可。<br>这样的好处就是，如果以后对求和函数有优化，比如新写了个<code>func_sum2</code>函数的实现，我们只需要在调用回调函数的地方将函数指针指向<code>func_sum2</code>即可，而无需去修改callback函数内部。</p><p>回调函数广泛用于开发场景中，比如信号函数、线程函数等，都使用到了回调函数的知识。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习要点（1）</title>
      <link href="/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C%E5%8A%A0%E5%8A%A0/c++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E8%A6%81%E7%82%B9%20%EF%BC%881%EF%BC%89/"/>
      <url>/2023/05/16/%E5%B5%8C%E5%85%A5%E5%BC%8F/C%E5%8A%A0%E5%8A%A0/c++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E8%A6%81%E7%82%B9%20%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="一-C语言中-p与-x的区别"><a href="#一-C语言中-p与-x的区别" class="headerlink" title="一.C语言中%p与%x的区别"></a>一.C语言中%p与%x的区别</h2><p>“%p”中的p是pointer（指针）的缩写。%p是打印地址的, 而%x是以十六进制形式打印。<br>%p是打印地址（指针地址）的，是十六进制的形式，但是会全部打完，即有多少位打印多少位。</p><p>32位编译器的指针变量为4个字节(32位)，64位编译器的指针变量为8个字节(64位)。</p><p>所以，在32位编译器下，使用%p打印指针变量，则会显示32位的地址（16进制的）；在64位编译器下，使用%p打印指针变量，则会显示64位的地址（16进制的），左边空缺的会补0。</p><p>%x：无符号十六进制整数(字母小写，不像上面指针地址那样补零)</p><p>%X：无符号十六进制整数(字母大写，不像上面指针那样补零)</p><p>%x、%X和%p的相同点都是16进制，不同点是%p按编译器位数长短（32位&#x2F;64位）输出地址，不够的补零</p><h2 id="二-C-中如何打印字符的地址"><a href="#二-C-中如何打印字符的地址" class="headerlink" title="二.C++中如何打印字符的地址"></a>二.C++中如何打印字符的地址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">17</span>;</span><br><span class="line">        <span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> *ch1 = &amp;c1;</span><br><span class="line">        <span class="type">char</span> *ch2 = &amp;c2;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;c1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,ch1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,a);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;static_cast&lt;void *&gt;(&amp;c1)=&quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;c1)&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;c1 &lt;&lt; endl;   <span class="comment">// 同样可以输出字符地址</span></span><br><span class="line">   cout &lt;&lt; (string *)&amp;c1 &lt;&lt; endl;   <span class="comment">// 同样可以输出字符地址</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;c1); <span class="comment">//打印c1字符的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,ch1); <span class="comment">//打印ch1指针变量的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,a);   <span class="comment">//将整型a以16进制形式输出</span></span><br></pre></td></tr></table></figure><p><strong>重点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C++标准库中I/O类对输出操作符&lt;&lt;重载，在遇到字符型指针时会将其当做字符串名来处理，输出指针所指的字符串。既然这样，我们就别让他知道那是字符型指针，所以得进行类型转换，即：希望任何字符型的指针变量输出为地址的话，都要作一个转换，即强制<span class="type">char</span> *转换成<span class="type">void</span> *，如下所示：</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;static_cast&lt;void *&gt;(&amp;c1)=&quot;</span>&lt;&lt;static_cast&lt;<span class="type">void</span>*&gt;(&amp;c1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// static_cast是一个强制类型转换操作符。强制类型转换，也称为显式转换</span></span><br><span class="line">链接：https:<span class="comment">//blog.csdn.net/zongyinhu/article/details/49512919</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="type">int</span> *)&amp;c1 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 同样可以输出字符地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="built_in">string</span> *)&amp;c1 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 同样可以输出字符地址</span></span><br></pre></td></tr></table></figure><h2 id="三-简单文件的输入输出"><a href="#三-简单文件的输入输出" class="headerlink" title="三.简单文件的输入输出"></a>三.简单文件的输入输出</h2><p>《C++ Primer Plus》第六章第八小节</p><h3 id="1-文件的输出"><a href="#1-文件的输出" class="headerlink" title="1. 文件的输出"></a>1. 文件的输出</h3><p>​将文件内容输出至文本中</p><p>​<strong>类比：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cout控制台输出---cout输出在屏幕上</span></span><br><span class="line"><span class="number">1.</span> 包含头文件 iostream</span><br><span class="line"><span class="number">2.</span> 头文件iostream定义一个用于处理输出的ostream类</span><br><span class="line"><span class="number">3.</span> 头文件iostream声明一个名为<span class="built_in">cout</span>的ostream变量（对象）</span><br><span class="line"><span class="number">4.</span> 必须指明名称空间；必须使用编译指令using或者<span class="built_in">std</span>::</span><br><span class="line"><span class="number">5.</span> 可以使用<span class="built_in">cout</span>和运算符&lt;&lt; 来显示各种类型的数据</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件输出---ofstream对象输出在对象所关联的文件中</span></span><br><span class="line"><span class="number">1.</span> 包含头文件fstream</span><br><span class="line"><span class="number">2.</span> 头文件fstream定义一个用于处理输出的ofstream类</span><br><span class="line"><span class="number">3.</span> 需要声明一个或多个ofstream变量（对象）</span><br><span class="line"><span class="number">4.</span> 需将ofstream对象与文件关联起来，例如方法：open();</span><br><span class="line"><span class="number">5.</span> 使用完文件后，用close()将其关闭</span><br><span class="line"><span class="number">6.</span> 可结合使用ofstream对象和运算符&lt;&lt;来输出各种类型的数据</span><br><span class="line">    </span><br><span class="line"><span class="comment">// outFile 可以使用 cout 可使用的任何方法</span></span><br></pre></td></tr></table></figure><h6 id="将文件与ofstream关联起来"><a href="#将文件与ofstream关联起来" class="headerlink" title="将文件与ofstream关联起来"></a>将文件与ofstream关联起来</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ofstream outFile;</span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">outFile(<span class="string">&quot;fish.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="type">char</span> filename[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; filename;</span><br><span class="line">outFile(filename);</span><br></pre></td></tr></table></figure><hr><h6 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> automobile[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line"><span class="type">double</span> a_price;</span><br><span class="line"><span class="type">double</span> d_price;</span><br><span class="line"></span><br><span class="line">ofstream outFile;</span><br><span class="line">outFile.open(<span class="string">&quot;carinfo.txt&quot;</span>);  <span class="comment">// associate with a file</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the make and model of automobile : &quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(automobile , <span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the model year : &quot;</span> ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; year;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Make the original asking price : &quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a_price ;</span><br><span class="line">d_price = <span class="number">0.913</span> * a_price;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed;</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">2</span>); <span class="comment">// 保留两位小数</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios_base::showpoint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Make and model: &quot;</span> &lt;&lt; automobile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Year: &quot;</span> &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Was asking: $&quot;</span> &lt;&lt; a_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Now asking: $&quot;</span> &lt;&lt; d_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; fixed;</span><br><span class="line">outFile.precision(<span class="number">2</span>); <span class="comment">// 保留两位小数</span></span><br><span class="line">outFile.setf(ios_base::showpoint);</span><br><span class="line">outFile &lt;&lt; <span class="string">&quot;Make and model: &quot;</span> &lt;&lt; automobile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">&quot;Year: &quot;</span> &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       outFile &lt;&lt; <span class="string">&quot;Was asking: $&quot;</span> &lt;&lt; a_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">&quot;Now asking: $&quot;</span> &lt;&lt; d_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile.close();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf()的作用是通过设置格式标志来控制输出形式，其中ios_base::fixed表示：用正常的记数方法显示浮点数(与科学计数法相对应)；ios_base::floatfield表示小数点后保留<span class="number">6</span>位小数。</span><br><span class="line"></span><br><span class="line">setf()的第一原型：</span><br><span class="line">C++为标准输入和输出定义了一些格式标志：</span><br><span class="line">例如 ： <span class="built_in">cout</span>.setf(ios_base::left); <span class="comment">//对所有cout的输出进行左对齐调整.</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\27239\AppData\Roaming\Typora\typora-user-images\image-20220326105933847.png" alt="image-20220326105933847"></p><hr><h3 id="2-文件的读取"><a href="#2-文件的读取" class="headerlink" title="2. 文件的读取"></a>2. 文件的读取</h3><p><strong>类比</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cout 的文件输入</span></span><br><span class="line"><span class="number">1.</span> 头文件包含iostream</span><br><span class="line"><span class="number">2.</span> 头文件定义用于处理输入的istream</span><br><span class="line"><span class="number">3.</span> 头文件iostream声明了一个名为<span class="built_in">cin</span>的istream变量(对象)</span><br><span class="line"><span class="number">4.</span> 必须指明名称空间</span><br><span class="line"><span class="number">5.</span> 可结合使用<span class="built_in">cin</span>和运算符&gt;&gt; 来读取各种类型数据</span><br><span class="line"><span class="number">6.</span> 可使用<span class="built_in">cin</span>和get()方法来读取一个字符，使用<span class="built_in">cin</span>和getline()来读取一行字符</span><br><span class="line"><span class="number">7.</span> 可结合使用<span class="built_in">cin</span>和eof()、fail()判断输入是否成功</span><br><span class="line"><span class="number">8.</span> 对象<span class="built_in">cin</span>本身被用作测试条件时，若最后一个读取操作成功，它将被转换为布尔值<span class="literal">true</span> 否则 转为<span class="literal">false</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 文件的读取</span></span><br><span class="line"><span class="number">1.</span> 头文件fstream</span><br><span class="line"><span class="number">2.</span> 头文件fstream定义一个用于处理输入的ifstream类</span><br><span class="line"><span class="number">3.</span> 需要声明一个或多个ifstream变量（对象）</span><br><span class="line"><span class="number">4.</span> 必须指明名称空间</span><br><span class="line"><span class="number">5.</span> 需要将ifstream对象与文件关联起来,使用方法open()</span><br><span class="line"><span class="number">6.</span> 使用完文件后，使用close()方法将其关闭</span><br><span class="line"><span class="number">7.</span> 结合使用ifstream对象和运算符&gt;&gt; 来读取各种类型的数据</span><br><span class="line"><span class="number">8.</span> 可以使用ifstream对象和get()方法来读取一个字符，使用ifstream对象和getline()读取一行字符</span><br><span class="line"><span class="number">9.</span> 可结合使用ifstream和eof()、fail()判断输入是否成功</span><br><span class="line"><span class="number">10.</span> 对象ifstream本身被用作测试条件时，若最后一个读取操作成功，它将被转换为布尔值<span class="literal">true</span> 否则 转为<span class="literal">false</span></span><br></pre></td></tr></table></figure><h6 id="将文件与ofstream关联起来-1"><a href="#将文件与ofstream关联起来-1" class="headerlink" title="将文件与ofstream关联起来"></a>将文件与ofstream关联起来</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifstream inFile;</span><br><span class="line"><span class="comment">//方法1：</span></span><br><span class="line">inFile.open(<span class="string">&quot;123.txt&quot;</span>);</span><br><span class="line"><span class="comment">//方法2：</span></span><br><span class="line"><span class="type">char</span> filename[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; filename;</span><br><span class="line">inFile.open(filename);</span><br></pre></td></tr></table></figure><h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> wt;</span><br><span class="line">inFile &gt;&gt; wt;  <span class="comment">// read a num from 123.txt</span></span><br><span class="line"><span class="type">char</span> line[<span class="number">80</span>];</span><br><span class="line">inFile.getline(line,<span class="number">80</span>); <span class="comment">// read a line of text</span></span><br></pre></td></tr></table></figure><h6 id="is-open"><a href="#is-open" class="headerlink" title="is_open()"></a>is_open()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查文件是否成功被打开使用方法is_open()</span></span><br><span class="line">inFile.open(<span class="number">123.</span>txt);</span><br><span class="line"><span class="keyword">if</span>(!inFile.is_open())   <span class="comment">// 当文本打开失败---&gt; 不允许读写 ---&gt; 或者文件不存在时</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FALLURE); <span class="comment">// exit()在头文件cstdlib中定义，还定义了一个同操作系统通信的参数值EXIT_FAILURE ----&gt; exit()终止程序 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="other"><a href="#other" class="headerlink" title="other"></a>other</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eof（）方法用于判断最后一次读取数据时候是否遇到EOF，若是返回<span class="literal">true</span>  </span><br><span class="line"></span><br><span class="line">fail（）方法用于判断最后一次读取数据的时候是否遇到了类型不配的情况，若是返回<span class="literal">true</span>（如果遇到了EOF，该方法也返回<span class="literal">true</span>）</span><br><span class="line"></span><br><span class="line">bad（） 如果出现意外的问题，如文件受损或硬件故障，最后一次读取数据的时候发生了这样的问题，方法bad（）将返回<span class="literal">true</span>。</span><br><span class="line"></span><br><span class="line">good（） 该方法在没有发生任何错误的时候返回<span class="literal">true</span>。该方法也指出的最后一次读取输入的操作是否成功。</span><br></pre></td></tr></table></figure><h6 id="实例程序"><a href="#实例程序" class="headerlink" title="实例程序"></a>实例程序</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Size = <span class="number">60</span>;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> filename[Size];.</span><br><span class="line">        </span><br><span class="line">ifstream inFile;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter name of data file :&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(filename,Size);</span><br><span class="line">inFile.open(filename);  <span class="comment">// associate inFile with a file</span></span><br><span class="line"><span class="keyword">if</span>(!inFile.is_open())<span class="comment">// failed to open the file</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Could not open the file &quot;</span> &lt;&lt; filename &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Program terminating.\n&quot;</span> ;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);  <span class="comment">// Abnormal exit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> value;</span><br><span class="line"><span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------ Data Reading -------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">inFile &gt;&gt; value;</span><br><span class="line"><span class="keyword">while</span>(inFile.good())  <span class="comment">// Judge whether the last read was successful</span></span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">sum += value;</span><br><span class="line">inFile &gt;&gt; value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If the last reading fails, judge the reason</span></span><br><span class="line"><span class="keyword">if</span>(inFile.eof())   <span class="comment">// the end of the file</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;End of file reached.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(inFile.fail())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Determine whether the last read encountered a type mismatch</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Input terminated by data minmatch.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Input terminated for unknown reason.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Judge whether there is data in the file</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>==count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No data processed.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Items read : &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Average: &quot;</span> &lt;&lt; sum/count &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">inFile.close();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-指针数组与数组指针"><a href="#四-指针数组与数组指针" class="headerlink" title="四.指针数组与数组指针"></a>四.指针数组与数组指针</h2><p><strong>[]的优先级高于</strong>*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*arr)[<span class="number">4</span>];             <span class="comment">// 数组指针，本质为一个指针，指向一个数组，数组中有四个元素，每一个元素都是int 类型----指向二维数组</span></span><br><span class="line"><span class="type">int</span> *arr[<span class="number">4</span>];               <span class="comment">// 指针数组，本质为一个数组，有四个元素，每一个元素都是int * 类型</span></span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> date[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> (*arr)[<span class="number">4</span>] = date;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(date[<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果： 都为 sizeof结果都为16  第一个date[1],第一行的数组，为第一个元素，有4*4=16个字节</span></span><br><span class="line"><span class="comment">//                           第二个arr[1], 指向第一个数组元素，即date的第一行也为4*4=16个字节</span></span><br></pre></td></tr></table></figure><p><strong>易混淆</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                result += (*arr + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> arr[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> result = sum(arr);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the result is: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错：</span></span><br><span class="line"><span class="number">13.</span>cpp: In function ‘<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>’:</span><br><span class="line">13.cpp:19:19: error: cannot convert ‘<span class="type">int</span>*’ to ‘<span class="title function_">int</span> <span class="params">(*)</span>[4]’</span><br><span class="line">   19 |  <span class="type">int</span> result = sum(arr);</span><br><span class="line">      |                   ^~~</span><br><span class="line">      |                   |</span><br><span class="line">      |                   <span class="type">int</span>*</span><br><span class="line"><span class="number">13.</span>cpp:<span class="number">6</span>:<span class="number">15</span>: note:   initializing argument <span class="number">1</span> of ‘<span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> (*)[<span class="number">4</span>])</span>’</span><br><span class="line">    6 | <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">4</span>])</span></span><br><span class="line">      |         ~~~~~~^~~~~~~</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 解析：</span></span><br><span class="line">    <span class="type">int</span> arr[] 一维数组，的arr本质是一个<span class="type">int</span> * 类型的指针变量，存储的为地址。即arr数组的首地址</span><br><span class="line">    <span class="title function_">int</span> <span class="params">(*arr)</span>[4] 数组指针，本质为一个指针，指向一个数组，指向由4个<span class="type">int</span>组成的数组指针。其类型为 <span class="title function_">int</span> <span class="params">(*)</span>[4] 无法相互转换</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五-数组替代"><a href="#五-数组替代" class="headerlink" title="五.数组替代"></a>五.数组替代</h2><h3 id="1-vector模板类"><a href="#1-vector模板类" class="headerlink" title="1.vector模板类"></a>1.vector模板类</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 #include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">// vector包含在命名空间std中</span></span><br><span class="line"><span class="comment">// 声明：</span></span><br><span class="line"><span class="built_in">vector</span>&lt;typeName&gt; <span class="title function_">vt</span><span class="params">(n_elem)</span></span><br><span class="line"><span class="comment">// typeName 为类型   ， n_elem 元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例：</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vi;   <span class="comment">// 长度为0的vector，可使用vector的方法对其进行插入或者添加值 ---&gt; 自动调整长度 ---&gt; 动态数组 </span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">double</span>&gt; <span class="title function_">vd</span><span class="params">(<span class="number">5</span>)</span>;</span><br><span class="line"><span class="comment">// 功能比数组强大，但是其效率较低</span></span><br><span class="line"><span class="comment">// 是使用New创建动态数组的替代品，使用new与delete管理内存，但是该过程是自动完成的</span></span><br><span class="line"><span class="comment">// 使用堆(new) ，动态内存分配，自由存储区</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-array模板类（C-11）"><a href="#2-array模板类（C-11）" class="headerlink" title="2.array模板类（C++11）"></a>2.array模板类（C++11）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 #include &lt;array&gt;</span></span><br><span class="line"><span class="comment">// array包含在命名空间std中</span></span><br><span class="line"><span class="comment">// 声明：</span></span><br><span class="line"><span class="built_in">array</span>&lt;typeName,n_elem&gt; arr</span><br><span class="line"><span class="comment">// typeName 为类型   ， n_elem 元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例：</span></span><br><span class="line">        <span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">5</span>&gt; ai;   </span><br><span class="line"><span class="comment">// array 长度固定,效率与数组一样，安全性相对数组更高</span></span><br><span class="line"><span class="comment">// 使用栈，静态内存分配</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-超界问题解决"><a href="#3-超界问题解决" class="headerlink" title="3.超界问题解决"></a>3.超界问题解决</h3><p><strong>vector 与 array 不会对于错误进行检查</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="type">double</span>,<span class="number">5</span>&gt; arr;</span><br><span class="line">arr[<span class="number">-2</span>] = <span class="number">2.3</span>;  <span class="comment">// 超界问题，但是系统不会报错 ---&gt; 编译器代码转换为 *(arr-2) = 2.3;</span></span><br></pre></td></tr></table></figure><p><strong>使用成员函数 at() 进行非法索引的捕获</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr.at(<span class="number">-2</span>);   </span><br><span class="line"><span class="comment">// 非法，at对于-2非法索引进行捕获\</span></span><br><span class="line"><span class="comment">// 报错：</span></span><br><span class="line"><span class="built_in">terminate</span> called after throwing an instance of <span class="string">&#x27;std::out_of_range&#x27;</span></span><br><span class="line">  what():  <span class="built_in">array</span>::at: __n (which is <span class="number">18446744073709551614</span>) &gt;= _Nm (which is <span class="number">5</span>)</span><br><span class="line">已放弃 (核心已转储)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="六-函数指针"><a href="#六-函数指针" class="headerlink" title="六. 函数指针"></a>六. 函数指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">pf</span><span class="params">(<span class="type">int</span>)</span>   <span class="comment">// 可以不写形参变量名字</span></span><br></pre></td></tr></table></figure><p><strong>函数指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> (*pf)(<span class="type">int</span>) </span><br><span class="line"><span class="comment">// () 和[] 一样优先级高于*</span></span><br><span class="line"><span class="comment">// 上述定义 解释 --&gt; pf是一个指向返回值为double，形参类型为int的函数指针</span></span><br></pre></td></tr></table></figure><p><strong>区分指针函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> *<span class="title function_">pf</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">// 由于 () 优先级高于 *</span></span><br><span class="line"><span class="comment">// 上述定义解释 --&gt; 首先是一个函数 形参类型为 int ,函数的返回值为 double * 类型</span></span><br></pre></td></tr></table></figure><h3 id="1-使用指针来调用函数"><a href="#1-使用指针来调用函数" class="headerlink" title="1. 使用指针来调用函数"></a>1. 使用指针来调用函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">pam</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">double</span> (*pf)(<span class="type">int</span>);</span><br><span class="line">pf = pam;         <span class="comment">// pf指针指向pam函数</span></span><br><span class="line"><span class="type">double</span> x = pam(<span class="number">5</span>);</span><br><span class="line"><span class="type">double</span> y = (*pf)(<span class="number">5</span>); <span class="comment">// 通过函数指针来调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++同样允许以下方式：</span></span><br><span class="line"><span class="type">double</span> z = pf(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="2-深入（C-primer-plus-202页）"><a href="#2-深入（C-primer-plus-202页）" class="headerlink" title="2. 深入（C++ primer plus 202页）"></a>2. 深入（C++ primer plus 202页）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个指针函数，其返回值类型为 double *</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* <span class="title function_">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *ar,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* <span class="title function_">f2</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ar+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* <span class="title function_">f3</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ar+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> av[<span class="number">3</span>] = &#123;<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PART1-----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 定义一个 double * 类型的函数指针，指向函数f1</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* (*p1)(<span class="type">const</span> <span class="type">double</span>*,<span class="type">int</span>) = f1;</span><br><span class="line"><span class="comment">// C++11 特性 --&gt; 自动推断类型</span></span><br><span class="line"><span class="keyword">auto</span> p2 = f2;</span><br><span class="line"><span class="comment">// 等价于 --&gt; double* (*p2)(const double*,int) = f2;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address        Value&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 调用f1输出av数组的地址   输出av数组第一个元素的值</span></span><br><span class="line"><span class="comment">// (*p1)(av,3)  == f1(av,3)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (*p1)(av,<span class="number">3</span>) &lt;&lt;<span class="string">&quot;   &quot;</span> &lt;&lt; *(*p1)(av,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2(av,3) == f2(av,3)  对地址使用解除引用* 得到其内存中的数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p2(av,<span class="number">3</span>) &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; *p2(av,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// part2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PART2-----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address        Value&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 定义一个指针数组，数组有三个元素，每一个元素都为函数指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* (*pa[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span> * ,<span class="type">int</span>) = &#123;f1,f2,f3&#125;;</span><br><span class="line"><span class="keyword">auto</span> pb = pa;</span><br><span class="line"><span class="comment">// 等价于 const double* (**pb)(const double *,int) = pa;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (*pa[i])(av,<span class="number">3</span>) &lt;&lt;<span class="string">&quot;   &quot;</span> &lt;&lt; *(*pa[i])(av,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (*pb[i])(av,<span class="number">3</span>) &lt;&lt;<span class="string">&quot;   &quot;</span> &lt;&lt; *(*pb[i])(av,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PART3-----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address        Value&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// pc 是一个指针，指向由三个函数指针组成的数组</span></span><br><span class="line"><span class="keyword">auto</span> pc = &amp;pa;</span><br><span class="line"><span class="comment">// 等价于 const double *(*(*pc)[3])(const double *,int) = &amp;pa;</span></span><br><span class="line"><span class="comment">// (*pc)[3] --&gt; 数组指针，pc是一个指针，指针指向由三个元素组成的数组</span></span><br><span class="line"><span class="comment">// (*(pc)[3]) 数组内的每一个元素都是指针</span></span><br><span class="line"><span class="comment">// const double *(*(*pc)[3])(const double *,int) 数组内的每一个元素都为函数指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (*pc)[<span class="number">0</span>](av,<span class="number">3</span>) &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; *(*pc)[<span class="number">0</span>](av,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// (*pc) == pa  --&gt; (*pc)[0](av,3) = pa[0](av,3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PART1-----------</span><br><span class="line">Address        Value</span><br><span class="line"><span class="number">0x7fffbc4b7000</span>   <span class="number">1.1</span></span><br><span class="line"><span class="number">0x7fffbc4b7008</span>   <span class="number">1.2</span></span><br><span class="line">PART2-----------</span><br><span class="line">Address        Value</span><br><span class="line"><span class="number">0x7fffbc4b7000</span>   <span class="number">1.1</span></span><br><span class="line"><span class="number">0x7fffbc4b7008</span>   <span class="number">1.2</span></span><br><span class="line"><span class="number">0x7fffbc4b7010</span>   <span class="number">1.3</span></span><br><span class="line"><span class="number">0x7fffbc4b7000</span>   <span class="number">1.1</span></span><br><span class="line"><span class="number">0x7fffbc4b7008</span>   <span class="number">1.2</span></span><br><span class="line"><span class="number">0x7fffbc4b7010</span>   <span class="number">1.3</span></span><br><span class="line">PART3-----------</span><br><span class="line">Address        Value</span><br><span class="line"><span class="number">0x7fffbc4b7000</span>   <span class="number">1.1</span></span><br></pre></td></tr></table></figure><h2 id="七-左值引用-右值引用"><a href="#七-左值引用-右值引用" class="headerlink" title="七.左值引用 右值引用"></a>七.左值引用 右值引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对一个值取地址可以成功取出的为 左值，无法成功取出则为 右值</span><br></pre></td></tr></table></figure><h5 id="1-左值引用"><a href="#1-左值引用" class="headerlink" title="(1). 左值引用"></a>(1). 左值引用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; c = a;   <span class="comment">//左值引用，赋值运算符右侧，一定要是左值，（常）普通变量a是左值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>&amp; c = (a+b);   <span class="comment">// error ，因为(a+b)是一个右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; d = <span class="number">10</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; c = (a+b);  <span class="comment">// 常引用成功！ const 会将 10，(a+b)计算的结果，放置到内存的临时变量中，使得引用与临时变量产生关联</span></span><br><span class="line"><span class="comment">// 使用常引用后，仅能通过引用来读取数据，无法修改数据</span></span><br></pre></td></tr></table></figure><h5 id="2-右值引用"><a href="#2-右值引用" class="headerlink" title="(2).右值引用"></a>(2).右值引用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a= <span class="number">10</span>; <span class="comment">// 常值是右值，其地址是随机的不确定的</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;x = <span class="number">10</span>;     <span class="comment">// 合法，右值引用</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;y = (a+b);  <span class="comment">// 右值引用</span></span><br></pre></td></tr></table></figure><h2 id="八-函数显示具体化与实例化区别"><a href="#八-函数显示具体化与实例化区别" class="headerlink" title="八.函数显示具体化与实例化区别"></a>八.函数显示具体化与实例化区别</h2><h3 id="1-形式区别"><a href="#1-形式区别" class="headerlink" title="1.形式区别"></a>1.形式区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt; <span class="type">void</span> Swap&lt;typeName&gt;(typeName &amp;a,typeName &amp;b);</span><br><span class="line">template&lt;&gt; <span class="type">void</span> <span class="title function_">Swap</span><span class="params">(typeName &amp;a,typeName &amp;b)</span>;</span><br><span class="line"><span class="comment">// 显示具体化，选择以上一种 ---&gt; typeName必须指定为特定的数据类型</span></span><br><span class="line"><span class="comment">// 非函数模板 &gt; 显示具体化 &gt; 函数模板</span></span><br><span class="line"><span class="comment">// 当传入函数的类型为指定的符合显示具体化中对应的参数类型时，此时优先使用显示具体化</span></span><br><span class="line"><span class="comment">// 显示具体化，可以帮助当模板函数无法重载时</span></span><br><span class="line"></span><br><span class="line">template <span class="type">void</span> Swap&lt;typeName&gt;(typeName &amp;a,typeName &amp;b);</span><br><span class="line"><span class="comment">// 显示实例化 ---&gt; typeName必须指定为特定的数据类型</span></span><br><span class="line"><span class="comment">// 函数模板只是用于生成函数定义的方案，并非函数定义</span></span><br><span class="line"><span class="comment">// 显示实例化：使用函数模板生成指定参数类型的函数定义</span></span><br></pre></td></tr></table></figure><p><strong>上述，代码可知，显示具体化声明在关键字 template后包含&lt;&gt;,而显示实例化没有</strong></p><hr><h3 id="2-意义区别"><a href="#2-意义区别" class="headerlink" title="2.意义区别"></a>2.意义区别</h3><p><strong>显示具体化：</strong></p><ul><li>显示具体化,<strong>指定模板函数中类型</strong>，意思是不要使用函数通用的模板来生成函数定义，而是要使用指定的数据类型来生成函数定义</li><li>显示具体化，实际仍然是<strong>隐式实例化</strong>，仅在函数调用时，根据指定的参数类型生成指定的函数定义</li><li>显示具体化为<strong>函数模板的特例</strong></li></ul><p><strong>显示实例化：</strong></p><ul><li>显示实例化,直接命令编译器创建特定的实例 —&gt; <strong>无论是否调用，均会生成函数定义</strong>，即函数定义一直存在。调用函数时，函数定义直接使用，不调用时函数定义已经存在</li><li><strong>其具体用途：</strong> 先创建模板的某个具体实例，而非使用时在隐式的创建（隐式实例化）。<ul><li>显示实例化，是为了编写库文件提供的。没有实例化的模板无法放置在<strong>目标文件（源文件编译之后生成目标文件，目标文件再经过链接生成可执行文件）</strong>中。<strong>当其他文件代码的目标文件调用（或者链接）该函数时，前提是该函数已经生成了目标文件（即该函数已经生成函数定义实例化后，倘若仍然为函数模板则无法调用）</strong></li></ul></li></ul><h2 id="九、ostream控制格式输出"><a href="#九、ostream控制格式输出" class="headerlink" title="九、ostream控制格式输出"></a>九、ostream控制格式输出</h2><p><strong>注：</strong>该部分转载至:<a href="http://c.biancheng.net/view/275.html#:~:text=ostream%20%E7%B1%BB%E6%9C%89%E4%B8%80%E4%BA%9B%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%8C%E9%80%9A%E8%BF%87%20cout%20%E8%B0%83%E7%94%A8%E5%AE%83%E4%BB%AC%E4%B9%9F%E8%83%BD%E7%94%A8%E4%BA%8E%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%8C%E5%85%B6%E4%BD%9C%E7%94%A8%E5%92%8C%E6%B5%81%E6%93%8D%E7%BA%B5%E7%AE%97%E5%AD%90%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%A6%82%E8%A1%A8%203%20%E6%89%80%E7%A4%BA%E3%80%82%20setf%20%E5%92%8C,unsetf%20%E5%87%BD%E6%95%B0%E7%94%A8%E5%88%B0%E7%9A%84%20flag%20%EF%BC%8C%E4%B8%8E%20setiosflags%20%E5%92%8C%20resetiosflags%20%E7%94%A8%E5%88%B0%E7%9A%84%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C%E3%80%82">链接</a></p><h3 id="1-使用流操作算子"><a href="#1-使用流操作算子" class="headerlink" title="1.使用流操作算子"></a>1.使用流操作算子</h3><p>C++ 中常用的输出流操纵算子如表 1 所示，它们都是在头文件 iomanip 中定义的；要使用这些流操纵算子，必须包含该头文件</p><p><strong>注意：“流操纵算子”一栏中的星号<code>*</code>不是算子的一部分，星号表示在没有使用任何算子的情况下，就等效于使用了该算子。例如，在默认情况下，整数是用十进制形式输出的，等效于使用了 dec 算子。</strong></p><table><thead><tr><th>流操纵算子</th><th>作  用</th><th></th></tr></thead><tbody><tr><td>*dec</td><td>以十进制形式输出整数</td><td>常用</td></tr><tr><td>hex</td><td>以十六进制形式输出整数</td><td></td></tr><tr><td>oct</td><td>以八进制形式输出整数</td><td></td></tr><tr><td>fixed</td><td>以普通小数形式输出浮点数</td><td></td></tr><tr><td>scientific</td><td>以科学计数法形式输出浮点数</td><td></td></tr><tr><td>left</td><td>左对齐，即在宽度不足时将填充字符添加到右边</td><td></td></tr><tr><td>*right</td><td>右对齐，即在宽度不足时将填充字符添加到左边</td><td></td></tr><tr><td>setbase(b)</td><td>设置输出整数时的进制，b&#x3D;8、10 或 16</td><td></td></tr><tr><td>setw(w)</td><td>指定输出宽度为 w 个字符，或输人字符串时读入 w 个字符</td><td></td></tr><tr><td>setfill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td><td></td></tr><tr><td>setprecision(n)</td><td>设置输出浮点数的精度为 n。  在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。  在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</td><td></td></tr><tr><td>setiosflags(flag)</td><td>将某个输出格式标志置为 1</td><td></td></tr><tr><td>resetiosflags(flag)</td><td>将某个输出格式标志置为 0</td><td></td></tr><tr><td>boolapha</td><td>把 true 和 false 输出为字符串</td><td>不常用</td></tr><tr><td>*noboolalpha</td><td>把 true 和 false 输出为 0、1</td><td></td></tr><tr><td>showbase</td><td>输出表示数值的进制的前缀</td><td></td></tr><tr><td>*noshowbase</td><td>不输出表示数值的进制.的前缀</td><td></td></tr><tr><td>showpoint</td><td>总是输出小数点</td><td></td></tr><tr><td>*noshowpoint</td><td>只有当小数部分存在时才显示小数点</td><td></td></tr><tr><td>showpos</td><td>在非负数值中显示 +</td><td></td></tr><tr><td>*noshowpos</td><td>在非负数值中不显示 +</td><td></td></tr><tr><td>*skipws</td><td>输入时跳过空白字符</td><td></td></tr><tr><td>noskipws</td><td>输入时不跳过空白字符</td><td></td></tr><tr><td>uppercase</td><td>十六进制数中使用 A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td><td></td></tr><tr><td>*nouppercase</td><td>十六进制数中使用 a~e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。</td><td></td></tr><tr><td>internal</td><td>数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td><td></td></tr></tbody></table><p>使用这些算子的方法是将算子用 &lt;&lt; 和 cout 连用。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; <span class="number">12</span> &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="number">24</span>; <span class="comment">// 这条语句的作用是指定以十六进制形式输出后面两个数</span></span><br></pre></td></tr></table></figure><h3 id="2-setioflags-算子"><a href="#2-setioflags-算子" class="headerlink" title="2.setioflags()算子"></a>2.setioflags()算子</h3><p>setiosflags() 算子实际上是一个库函数，它以一些标志作为参数，这些标志可以是在 iostream 头文件中定义的以下几种取值，它们的含义和同名算子一样。</p><table><thead><tr><th>标 志</th><th>作 用</th></tr></thead><tbody><tr><td>ios::left</td><td>输出数据在本域宽范围内向左对齐</td></tr><tr><td>ios::right</td><td>输出数据在本域宽范围内向右对齐</td></tr><tr><td>ios::internal</td><td>数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</td></tr><tr><td>ios::dec</td><td>设置整数的基数为 10</td></tr><tr><td>ios::oct</td><td>设置整数的基数为 8</td></tr><tr><td>ios::hex</td><td>设置整数的基数为 16</td></tr><tr><td>ios::showbase</td><td>强制输出整数的基数（八进制数以 0 开头，十六进制数以 0x 打头）</td></tr><tr><td>ios::showpoint</td><td>强制输出浮点数的小点和尾数 0</td></tr><tr><td>ios::uppercase</td><td>在以科学记数法格式 E 和以十六进制输出字母时以大写表示</td></tr><tr><td>ios::showpos</td><td>对正数显示“+”号</td></tr><tr><td>ios::scientific</td><td>浮点数以科学记数法格式输出</td></tr><tr><td>ios::fixed</td><td>浮点数以定点格式（小数形式）输出</td></tr><tr><td>ios::unitbuf</td><td>每次输出之后刷新所有的流</td></tr><tr><td>ios::stdio</td><td>每次输出之后清除 stdout, stderr</td></tr></tbody></table><p>多个标志可以用<code>|</code>运算符连接，表示同时设置。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; setiosflags(ios::scientific|ios::showpos) &lt;&lt; <span class="number">12.34</span>;</span><br></pre></td></tr></table></figure><p>如果两个相互矛盾的标志同时被设置，如先设置 setiosflags(ios::fixed)，然后又设置 setiosflags(ios::scientific)，那么结果可能就是两个标志都不起作用。因此，在设置了某标志，又要设置其他与之矛盾的标志时，就应该用 resetiosflags 清除原先的标志。例如下面三条语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; <span class="number">12.34</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; resetiosflags(ios::fixed) &lt;&lt; setiosflags(ios::scientific | ios::showpos) &lt;&lt; <span class="number">12.34</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; resetiosflags(ios::showpos) &lt;&lt; <span class="number">12.34</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//清除要输出正号的标志</span></span><br></pre></td></tr></table></figure><h3 id="3-调用cout成员函数"><a href="#3-调用cout成员函数" class="headerlink" title="3.调用cout成员函数"></a>3.调用cout成员函数</h3><p>ostream 类有一些成员函数，通过 cout 调用它们也能用于控制输出的格式，其作用和流操纵算子相同.</p><table><thead><tr><th>成员函数</th><th>作用相同的流操纵算子</th><th>说明</th></tr></thead><tbody><tr><td>precision(n)</td><td>setprecision(n)</td><td>设置输出浮点数的精度为 n。</td></tr><tr><td>width(w)</td><td>setw(w)</td><td>指定输出宽度为 w 个字符。</td></tr><tr><td>fill(c)</td><td>setfill (c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）。</td></tr><tr><td>setf(flag)</td><td>setiosflags(flag)</td><td>将某个输出格式标志置为 1。</td></tr><tr><td>unsetf(flag)</td><td>resetiosflags(flag)</td><td>将某个输出格式标志置为 0。</td></tr></tbody></table><p>setf 和 unsetf 函数用到的<code>flag</code>，与 setiosflags 和 resetiosflags 用到的完全相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::scientific);</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">12.23</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1.22300000e+001</span></span><br></pre></td></tr></table></figure><h2 id="十、类的自动类型转换与强制转换"><a href="#十、类的自动类型转换与强制转换" class="headerlink" title="十、类的自动类型转换与强制转换"></a>十、类的自动类型转换与强制转换</h2><h3 id="1-构造函数用作自动类型转换的转换函数"><a href="#1-构造函数用作自动类型转换的转换函数" class="headerlink" title="1.构造函数用作自动类型转换的转换函数"></a>1.构造函数用作自动类型转换的转换函数</h3><p><strong>只接受一个参数的构造函数才可以作为转换函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stock::Stock(<span class="type">double</span> lab); <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Stock对象</span></span><br><span class="line">Stock one; </span><br><span class="line"><span class="comment">// 将创建一个Stock(double lab)的临时对象，并将19.6作为初始值，采用成员赋值的方法，将该临时对象的内容复制到one中</span></span><br><span class="line">one = <span class="number">19.6</span></span><br></pre></td></tr></table></figure><h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h4><p><strong>可通过构造函数前，显示添加explicit，关闭该自动特性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explicit <span class="title function_">Stock::Stock</span><span class="params">(<span class="type">double</span> lab)</span>;</span><br><span class="line"><span class="comment">// 只接受一个参数的构造函数定义了从参数类型到类类型的转换，使用explicit可以关闭这种自动的隐式转换.</span></span><br></pre></td></tr></table></figure><h3 id="2-转换函数"><a href="#2-转换函数" class="headerlink" title="2.转换函数"></a>2.转换函数</h3><p><strong>转换函数，定义了从 某种类型 到 类类型的转换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stock::Stock(<span class="type">double</span> lab); <span class="comment">// 构造函数</span></span><br><span class="line">Stock::Stock(<span class="type">double</span> lab，<span class="type">double</span> mab)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若定义了从Stock到double类型的转换</span></span><br><span class="line">Stock <span class="title function_">wolf</span><span class="params">(<span class="number">16.3</span>)</span>;</span><br><span class="line">Stock <span class="title function_">solf</span><span class="params">(<span class="number">30</span>,<span class="number">5</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用转换函数</span></span><br><span class="line"><span class="type">double</span> host = <span class="type">double</span>(wolf);</span><br><span class="line"><span class="type">double</span> think = (<span class="type">double</span>) wolf;</span><br><span class="line"><span class="comment">// 使用转换函数</span></span><br><span class="line"><span class="type">double</span> host2 = <span class="type">double</span>(solf);</span><br><span class="line"><span class="type">double</span> think2 = (<span class="type">double</span>) solf;</span><br></pre></td></tr></table></figure><p><strong>创建转换函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">operator <span class="title function_">typeName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="number">1.</span>转换函数必须是类方法</span><br><span class="line">    <span class="number">2.</span>转换函数不能指定返回类型</span><br><span class="line">    <span class="number">3.</span>转换函数不能有参数</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line">        operator <span class="title function_">double</span><span class="params">()</span>; <span class="comment">//此处的typeName(double)是指定要转换成的类型</span></span><br></pre></td></tr></table></figure><h4 id="explicit-1"><a href="#explicit-1" class="headerlink" title="explicit"></a>explicit</h4><p>若类方法中，只定义了 <strong>类类型到一种类型</strong> 的转换函数，这将避免二义性，而使得可以使用隐式转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类声明中</span></span><br><span class="line">Stock::Stock(<span class="type">double</span> a); <span class="comment">// 构造函数</span></span><br><span class="line">operator <span class="title function_">double</span><span class="params">()</span> ;<span class="comment">// 定义转换函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式转换</span></span><br><span class="line">Stock <span class="title function_">opp</span><span class="params">(<span class="number">5</span>)</span>;</span><br><span class="line"><span class="type">double</span> lab = opp; <span class="comment">// 而非显示转换 double lab = double(opp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二义性</span></span><br><span class="line">operator <span class="title function_">double</span><span class="params">()</span> ;<span class="comment">// 定义转换函数</span></span><br><span class="line">operator <span class="title function_">int</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> gone = opp;</span><br><span class="line"><span class="type">long</span> gone = opp; <span class="comment">//由于上面定义了两种转换函数，这样使用隐式转换编译器报错</span></span><br></pre></td></tr></table></figure><p><strong>explicit关键词，可以防止这样的隐式转换，只允许显示转换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explicit operator <span class="title function_">double</span><span class="params">()</span> ;<span class="comment">// 定义转换函数</span></span><br><span class="line">explicit operator <span class="title function_">int</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> gone = (<span class="type">double</span>)opp;</span><br><span class="line"><span class="type">long</span> gone = (<span class="type">int</span>)opp;</span><br></pre></td></tr></table></figure><h2 id="十一、类的静态成员变量"><a href="#十一、类的静态成员变量" class="headerlink" title="十一、类的静态成员变量"></a>十一、类的静态成员变量</h2><p><strong>静态类成员：无论创建多少个类对象，程序只创建一个静态类变量的副本</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在StringBad类声明中</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> number;</span><br></pre></td></tr></table></figure><p><strong>不能在类声明中初始化静态成员变量，声明描述了如何分配内存，但是并不分配内存，若在类声明（.h头文件中）初始化静态成员变量，当将该头文件引入别的文件时，会违背单定义的原则</strong></p><p><strong>可以在类实现中（.cpp文件中）初始化静态变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化在类实现文件中</span></span><br><span class="line"><span class="type">int</span> StringBad::number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过类名进行调用</span></span><br><span class="line">StringBad::number</span><br></pre></td></tr></table></figure><p><strong>若静态成员变量是const类型，则可以在类声明中初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明中进行初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> number = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="十二、复制构造函数"><a href="#十二、复制构造函数" class="headerlink" title="十二、复制构造函数"></a>十二、复制构造函数</h2><p>复制构造函数用于将一个对象复制到新创建的对象中。即用于初始化过程中（包括按值传递参数），而非常规的赋值过程，<strong>类的复制构造函数原型通常如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class_Name(<span class="type">const</span> Class_Name &amp;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line">    StringBad(<span class="type">const</span> StringBad &amp;)</span><br></pre></td></tr></table></figure><h3 id="1-何时调用赋值构造函数"><a href="#1-何时调用赋值构造函数" class="headerlink" title="1.何时调用赋值构造函数"></a>1.何时调用赋值构造函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>当函数按值传递类对象时（意味着创建原始变量的副本，编译器将生成临时对象，将使用复制构造函数）</span><br><span class="line"><span class="number">2.</span>函数返回类对象时（返回类对象，也会生成临时对象）</span><br></pre></td></tr></table></figure><p>按值传递对象将调用复制构造函数，因此尽可能<strong>按引用传递对象</strong>，节省调用复制构造函数的时间，节省创建副本的时间</p><h3 id="2-定义显示复制构造函数"><a href="#2-定义显示复制构造函数" class="headerlink" title="2.定义显示复制构造函数"></a>2.定义显示复制构造函数</h3><p>定义一个显示的复制构造函数进行深度复制，<strong>复制构造函数，应当复制对象的数据内容并将对象副本的地址赋给令一个对象，而不仅仅是复制对象的地址，从而去引用该对象</strong>。</p><p>仅仅复制对象的地址赋给其他对象，从而引用该对象，为<strong>浅复制</strong>，当调用析构函数进行释放内存时，则会将一个对象进行两次释放。</p><p>一般的C++标准库均有复制构造函数的重载，若一类中的成员无使用动态的内存分配，程序调用默认的复制构造函数无影响，因为程序结束时，调用析构函数无动态的内存释放，不会对同一个开辟的内存空间进行两次释放。</p><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果类中包含了使用New初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而非指针（对象地址），这被称为深度复制。</span><br><span class="line">浅复制：仅浅浅的复制指针信息，而不会深入“挖掘”以复制指针引用的结构与其内容。</span><br></pre></td></tr></table></figure><h3 id="3-赋值问题"><a href="#3-赋值问题" class="headerlink" title="3.赋值问题"></a>3.赋值问题</h3><p>将一个对象赋值给另外一个对象，也会出现与隐式复制构造函数相同的问题，因此需要<strong>提供复制赋值运算符的定义进行（深度复制）</strong></p><p>书中：P356</p><h2 id="十三、成员列表的初始化"><a href="#十三、成员列表的初始化" class="headerlink" title="十三、成员列表的初始化"></a>十三、成员列表的初始化</h2><p>对类中声明的const常量无法在类定义中对其进行赋值，因为<strong>常量只能在声明时进行初始化</strong>，因此可以使用<strong>成员初始化列表</strong>的方式，<strong>对常量进行初始化操作</strong>。成员列表初始化会在执行构造函数之前，对创建的对象进行初始化。成员列表初始化的方式只能用于构造函数。</p><p><strong>注意：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>只能用于构造函数</span><br><span class="line"><span class="number">2.</span>必须使用成员列表初始化的操作，初始化非静态<span class="type">const</span>数据成员</span><br><span class="line"><span class="number">3.</span>必须使用成员列表初始化的操作，初始化引用数据成员</span><br><span class="line">    </span><br><span class="line">    成员列表初始化，在执行构造函数的函数体之前，先创建对象并对对象进行初始化</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Queue::Queue(<span class="type">int</span> qs):qsize(qs)</span><br><span class="line">&#123;</span><br><span class="line">front = rear = <span class="literal">NULL</span>;</span><br><span class="line">items = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//qsize =qs;    // 这是非法操作，对常量无法进行赋值操作，仅能初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析：</span></span><br><span class="line">:qsize(qs)    <span class="comment">// 该部分是对类常量qsize 初始化为qs</span></span><br></pre></td></tr></table></figure><p><strong><code>qsiz</code>e</strong> 是在类声明中定义的一个常量，无法通过 <code>**qsize =qs**</code> 对常量进行赋值操作，只能初始化，原因是从概念上来说，调用构造函数时，对象将在括号中的代码执行之前被创建，因此调用 <strong>Queue(int qs)</strong> 构造函数将导致程序首先给四个成员变量分配内存<strong>（此时分配内存相当于在做初始化）</strong>，然后程序流程进入到括号中，使用常规的赋值方式，将值存储到内存中，因此对于 <strong>const</strong> 数据成员，<strong>必须在执行构造函数体之前，即创建对象时进行初始化</strong></p><p><strong>成员初始化列表，不用写在类声明中，只需要写在类定义中</strong></p><h2 id="十四、友元"><a href="#十四、友元" class="headerlink" title="十四、友元"></a>十四、友元</h2><ul><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ul><p><strong>友元函数是一种非成员函数，可以赋予该函数与类的成员函数相同的访问权限，可以访问类中的私有成员变量</strong></p><p><strong>友元函数，将普通的函数，通过<code>friend</code>修饰，但是该修饰只出现在函数原型上，即类声明中。不要在类定义中使用关键字<code>friend</code></strong></p><h2 id="十五、派生类的构造函数"><a href="#十五、派生类的构造函数" class="headerlink" title="十五、派生类的构造函数"></a>十五、派生类的构造函数</h2><h3 id="1-成员初始化列表调用基类构造函数"><a href="#1-成员初始化列表调用基类构造函数" class="headerlink" title="1.成员初始化列表调用基类构造函数"></a>1.成员初始化列表调用基类构造函数</h3><p><strong>派生类的构造函数必须使用基类的构造函数</strong></p><p><strong>创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化列表的方式创建</strong></p><p>下面是一个派生类<code>RatedPlayer</code>继承自基类<code>TableTennisPlayer</code>构造函数的代码实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只在类实现中这样写，类声明中不写成员列表初始化</span></span><br><span class="line">RatedPlayer::RatedPlayer(<span class="type">unsigned</span> <span class="type">int</span> r,<span class="type">const</span> <span class="built_in">string</span> &amp; fn,<span class="type">const</span> <span class="built_in">string</span> &amp; ln,<span class="type">bool</span> ht):TableTennisPlayer(fn,ln,ht)</span><br><span class="line">&#123;</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实例代码，<code>:TableTennisPlayer(fn,ln,ht)</code>是成员初始化列表。它是<strong>可执行代码，调用TableTennisPlayer构造函数。通过成员初始化列表，使用基类的构造函数为基类的私有成员进行赋值。</strong></p><p><strong>先创建基类对象（通过成员初始化列表的方式，隐式创建），在通过派生类构造函数创建派生类对象</strong></p><h3 id="2-省略成员初始化列表"><a href="#2-省略成员初始化列表" class="headerlink" title="2.省略成员初始化列表"></a>2.省略成员初始化列表</h3><p>若省略成员初始化列表，实例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RatedPlayer::RatedPlayer(<span class="type">unsigned</span> <span class="type">int</span> r,<span class="type">const</span> <span class="built_in">string</span> &amp; fn,<span class="type">const</span> <span class="built_in">string</span> &amp; ln,<span class="type">bool</span> ht)</span><br><span class="line">&#123;</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>必须首先创建基类对象，若不调用基类构造函数（即使不使用成员初始化列表方式调用基类的构造函数），程序也将使用默认基类构造函数</strong>，以下代码与上述等价：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于调用默认的构造函数</span></span><br><span class="line">RatedPlayer::RatedPlayer(<span class="type">unsigned</span> <span class="type">int</span> r,<span class="type">const</span> <span class="built_in">string</span> &amp; fn,<span class="type">const</span> <span class="built_in">string</span> &amp; ln,<span class="type">bool</span> ht):TableTennisPlayer()</span><br><span class="line">&#123;</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>除非使用默认的构造函数，否则应该显示的调用正确的基类构造函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RatedPlayer::RatedPlayer(<span class="type">unsigned</span> <span class="type">int</span> r,<span class="type">const</span> TableTennisPlayer &amp; tp):TableTennisPlayer(tp)</span><br><span class="line">&#123;</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tp</code>的类型是 <code>TableTennisPlayer &amp; </code>,因此将调用基类的复制构造函数，基类若没有定义复制构造函数，编译器将自动生成一个。</p><p>若愿意，也可以使用成员初始化列表对<strong>派生类成员进行初始化</strong>，代码实例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RatedPlayer::RatedPlayer(<span class="type">unsigned</span> <span class="type">int</span> r,<span class="type">const</span> TableTennisPlayer &amp; tp):TableTennisPlayer(tp),rating(r)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-要点"><a href="#3-要点" class="headerlink" title="3.要点"></a>3.要点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先创建基类对象</span><br><span class="line">派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数</span><br><span class="line">派生类构造函数应初始化派生类新增的数据成员</span><br></pre></td></tr></table></figure><p><strong>注意：创建派生类对象时，程序首先调用基类构造函数，再调用派生类构造函数，基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类构造函数总是调用几个基类的构造函数。可以使用初始化列表的语法指明要使用的基类构造函数，否则将使用默认的基类构造函数</strong></p><p><strong>派生类对象过期（应该被释放时），程序首先调用派生类的析构函数，然后再调用基类的析构函数</strong></p><h2 id="十六、派生类与基类之间的关系"><a href="#十六、派生类与基类之间的关系" class="headerlink" title="十六、派生类与基类之间的关系"></a>十六、派生类与基类之间的关系</h2><ul><li><p>派生类可以使用基类的方法，<strong>前提是方法非私有</strong></p></li><li><p><strong>基类的指针与引用均可以不在显示转换的情况下指向派生类对象</strong>，但是基类指针与方法均只能调用基类的方法。**(单向)**，派生类新增的方法与成员基类的指针与引用无法调用</p><ul><li><pre><code class="c">// ball 是 basketball 的基类basketball object(&quot;vs&quot;);ball *f_object1 = &amp;object; // 基类指针指向派生类对象ball &amp;f_object2 = object;  // 基类引用指向派生类对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 可以将派生类对象赋给基类对象**(会使用隐式的重载运算符)**</span><br><span class="line"></span><br><span class="line">  * ```c</span><br><span class="line">    // ball 是 basketball 的基类</span><br><span class="line">    basketball object(&quot;vs&quot;);</span><br><span class="line">    ball f_object1 = object; // 派生类对象赋值给基类对象</span><br><span class="line">    </span><br><span class="line">    // 这种情况，会使用隐式的重载运算符</span><br><span class="line">    ball &amp;f_object1 = (const ball &amp;) object;  // 基类引用指向派生类对象,object的基类部分，将被复制给f_object1</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>在派生类中若定义了与基类相同名称的方法<strong>（重写）</strong>，则需要通过<code>::</code>作用域解析运算符来调用基类的方法</p><ul><li><pre><code>// ball 是 basketball 的基类// 若基类与派生类中均定义了 view()方法，在派生类中想使用基类的方法，则需要使用 基类名称：：方法名称 调用基类方法ball::view()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 十七、虚方法</span><br><span class="line"></span><br><span class="line">在类的类声明的函数原型中通过`virtual`关键字可以将函数进行**虚函数**的声明。**`virtual`关键词只用于类声明的方法原型中**，同友元函数的关键词`friend`</span><br><span class="line"></span><br><span class="line">**在基类中将派生类会重新定义的方法，声明为虚方法，方法在基类中被声明为虚方法之后，在派生类中不用指明关键字 virtual 也会自动成为虚方法**，好习惯，还是将**派生类中的虚方法通过`virtual`声明出来，增加代码的可读性**</span><br><span class="line"></span><br><span class="line">**基类声明一个虚的析构函数，这样可以确保释放对象时，按照正确的顺序调用析构函数**</span><br><span class="line"></span><br><span class="line">### 1.重点</span><br><span class="line"></span><br><span class="line">**利用基类的指针与引用指向派生类对象，若方法没有声明为`virtual` 虚方法，程序将根据指针或者引用的类型去选择方法；若使用了`virtual`声明为了虚方法，程序则会根据指针或者引用则会根据指向对象的类型来选择方法**</span><br><span class="line"></span><br><span class="line">* 若`view()`没有被声明为虚方法,`view()`方法在基类与派生类中均有定义</span><br><span class="line"></span><br><span class="line">  * ```c</span><br><span class="line">    // ball 是 basketball 的基类</span><br><span class="line">    basketball object(&quot;vs&quot;);</span><br><span class="line">    ball opp(&quot;str&quot;);</span><br><span class="line">    ball &amp;f_object1 = opp; // 基类引用指向基类对象</span><br><span class="line">    ball &amp;f_object2 = object;  // 基类引用指向派生类对象</span><br><span class="line">    </span><br><span class="line">    ball.view(); // 引用类型为基类引用，因此均是调用基类中定义的 view() 方法</span><br><span class="line">    ball.view(); // 引用类型为基类引用，因此均是调用基类中定义的 view() 方法</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>若<code>view()</code>被声明为虚方法,<code>view()</code>方法在基类与派生类中均有定义</p><ul><li><pre><code class="c">// ball 是 basketball 的基类basketball object(&quot;vs&quot;);ball opp(&quot;str&quot;);ball &amp;f_object1 = opp; // 基类引用指向基类对象ball &amp;f_object2 = object;  // 基类引用指向派生类对象ball.view(); // 引用类型为基类引用，引用指向的对象为基类对象，因此使用基类的方法ball.view(); // 引用类型为基类引用，引用指向的对象为派生类对象，因此使用派生类的方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.虚函数注意事项</span><br><span class="line"></span><br><span class="line">* 若定义的类被用作基类，则应该将那些**派生类中重新定义的方法声明为虚函数**</span><br><span class="line">* **构造函数**不能为虚函数</span><br><span class="line">* **析构函数应当是虚函数，除非类不做基类**，即使类不做基类，将其析构函数定义为虚函数也没有问题</span><br><span class="line">* **友元函数不能为虚函数，因为友元函数不是成员函数，为非成员函数**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 十八、为何需要虚的析构函数</span><br><span class="line"></span><br><span class="line">**若析构函数不是虚函数**，通过一个基类指针/引用指向派生类对象时，当基类指针/引用被释放时，则将只调用对应于指针或者引用类型的析构函数。，这意味着只有基类的对象被调用，即使指向了一个派生类对象。</span><br><span class="line"></span><br><span class="line">**若析构函数为虚函数**，通过一个基类指针/引用指向派生类对象时，当基类指针/引用被释放时，则将先调用派生类即**指针/引用指向对象的析构函数**，然后**自动调用基类的析构函数**即指针/引用类型的析构函数。</span><br><span class="line"></span><br><span class="line">**总结：**使用虚的析构函数，可以确保正确的析构函数序列被调用。**好习惯：在基类中声明虚的析构函数**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 十九、抽象基类（纯虚函数）</span><br><span class="line"></span><br><span class="line">抽象基类**（ABC）**包含其所有派生类的共有（共性）部分</span><br><span class="line"></span><br><span class="line">C++通过纯虚函数来提供为实现的函数，**纯虚函数在结尾处为=0**</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">virtual double Area()=0; // 纯虚函数</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>若一个类需要成为抽象基类（ABC）则该基类中必须包含一个纯虚函数，含有纯虚函数的类（ABC）只能做基类，无法创建该类对象。但是即使该基类为抽象的，我们仍可以在实现文件中提供方法的定义</strong></p><h2 id="二十、类模板"><a href="#二十、类模板" class="headerlink" title="二十、类模板"></a>二十、类模板</h2><h3 id="1-创建类模板与模板函数分为以下三步："><a href="#1-创建类模板与模板函数分为以下三步：" class="headerlink" title="1.创建类模板与模板函数分为以下三步："></a>1.创建类模板与模板函数分为以下三步：</h3><ul><li>模板类—如下代码打头：<code>template&lt;class Type&gt;</code></li><li>每个函数头都将以相同的模板声明打头：<code>template&lt;class Type&gt;</code></li><li>最后需要将类限定符 从 <strong><code>类名::</code></strong> 改为 <strong><code>类名&lt;Type&gt;::</code></strong></li></ul><p><strong>重点：</strong></p><p><strong>这些模板不是类和成员函数的定义，他们是c++编译器指令，</strong>说明了如何生成类和成员函数定义，模板的具体实现被称为实例化或者具体化。不能将模板成员函数放在独立的实现文件中，<strong>由于模板不是函数，他们不能单独编译. 模板必须与特定的模板实例一起使用</strong>，最简单的方法是：<strong>将所有模板信息放在一个头文件中</strong></p><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    private:</span><br><span class="line">    Type item[<span class="number">5</span>];</span><br><span class="line">    public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">pop</span><span class="params">(Type &amp; item)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数实现</span></span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="type">bool</span> Stack&lt;Type&gt;::pop(Type &amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-模板隐式实例化、显示实例化、具体化"><a href="#2-模板隐式实例化、显示实例化、具体化" class="headerlink" title="2.模板隐式实例化、显示实例化、具体化"></a>2.模板隐式实例化、显示实例化、具体化</h3><p>① <strong>隐式实例化</strong>：给模板传入特定的类型参数并创建类对象时，会同时生成类声明，<strong>该操作在程序运行阶段生成类定义</strong></p><p>② <strong>显示实例化</strong>：使用template打头，并给模板传入特定的类型参数（无需创建类对象）。<strong>该操作在程序编译阶段产生类声明</strong></p><p>③ <strong>具体化</strong>：给模板使用具体的类型参数生成类声明。显&#x2F;隐实例化均通过具体的类型生成类声明。实例化属于具体化</p><p>类模板与函数模板很相似，均可以有隐式实例化、显示实例化和显示具体化，都统称为具体化，<strong>模板以泛型的方式描述类，而具体化使用具体的类型生成类声明</strong></p><p><strong>模板仅仅描述类的样子并无类的定义与声明，而通过具体化可生成类声明</strong></p><h2 id="二十一、异常"><a href="#二十一、异常" class="headerlink" title="二十一、异常"></a>二十一、异常</h2><h3 id="1-调用abort-函数"><a href="#1-调用abort-函数" class="headerlink" title="1.调用abort()函数"></a>1.调用abort()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">hmean</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> x,y,z;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter 2 number:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y)</span><br><span class="line">    &#123;</span><br><span class="line">        z = hmean(x,y);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter next set of number &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bye!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">hmean</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==-b) <span class="comment">// 若当前 a==-b则会出现除数为0的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; untenable arguments to hmean()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*a*b / (a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>abort()函数会在出现a==-b</code>的情况时会直接中止程序，程序运行阶段错误</strong></p><p><strong>运行结果：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home/zxz/c++/demo/<span class="number">9</span>/cmake-build-debug/<span class="number">9</span></span><br><span class="line">Enter <span class="number">2</span> number:</span><br><span class="line"><span class="number">10</span> <span class="number">-10</span></span><br><span class="line"> untenable arguments to <span class="title function_">hmean</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 134 <span class="params">(interrupted by signal <span class="number">6</span>: SIGABRT)</span></span><br></pre></td></tr></table></figure><h3 id="2-异常机制"><a href="#2-异常机制" class="headerlink" title="2.异常机制"></a>2.异常机制</h3>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C加加 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow 入门教程（1）</title>
      <link href="/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Tensorflow/Tensorflow%20%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2023/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Tensorflow/Tensorflow%20%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Tensorflow-入门教程（1）"><a href="#Tensorflow-入门教程（1）" class="headerlink" title="Tensorflow 入门教程（1）"></a>Tensorflow 入门教程（1）</h2><p>视频教程链接：</p><p><a href="https://www.bilibili.com/video/BV1Cg4y1q7Xq?p=9">【国家精品课程】北京大学人工智能实践-TensorFlow2.0</a></p><h3 id="一、张量以及常用函数"><a href="#一、张量以及常用函数" class="headerlink" title="一、张量以及常用函数"></a>一、张量以及常用函数</h3><h4 id="1-创建张量"><a href="#1-创建张量" class="headerlink" title="1.创建张量"></a>1.创建张量</h4><p>由<code>tf.constant()</code>函数进行创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">a = tf.constant([[<span class="number">1</span>,<span class="number">2</span>]],dtype=tf.int32)</span><br><span class="line">print(a)</span><br><span class="line">print(a.dtype)</span><br><span class="line">print(a.shape)</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011456814.png" alt="image-20230501145049017"></p><p><strong>将<code>numpy</code>格式转换为tensor格式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = numpy.range(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">b = tf.convert_to_tensor(a,dtype=tf.int64)</span><br></pre></td></tr></table></figure><p><strong>创建特殊张量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建全部为<span class="number">0</span>的张量</span><br><span class="line">tf.zeros(维度)</span><br><span class="line">    </span><br><span class="line"># 创建全部为<span class="number">1</span>的张量</span><br><span class="line">tf.ones(维度)</span><br><span class="line">    </span><br><span class="line"># 创建全为指定值的张量</span><br><span class="line">tf.fill(维度，指定值)   <span class="meta"># tf.fill([2,2],9)</span></span><br><span class="line">    </span><br><span class="line"># 生成正太分布的随机数 默认均值为 <span class="number">0</span>  标准差为<span class="number">1</span></span><br><span class="line">tf.random.normal(维度,mean=均值,stddev=标准差)</span><br><span class="line"></span><br><span class="line"># 生成截断式正太分布的随机数  生成的随机数据取值在(均值<span class="number">-2</span>*标准差，均值+<span class="number">2</span>*标准差)</span><br><span class="line">tf.random.truncated_normal(维度,mean=均值,stddev=标准差)</span><br><span class="line">    </span><br><span class="line"># 生成均匀分布随机数 在[minval,maxval]之间</span><br><span class="line">tf.random.uniform(维度,minval=最小值,maxval=最大值)</span><br></pre></td></tr></table></figure><h4 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2.常用函数"></a>2.常用函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 强制tensor转换该数据</span><br><span class="line">tf.cast(张量名,dtype=数据类型)</span><br><span class="line"></span><br><span class="line"># 计算张量维度上元素的最大值</span><br><span class="line">tf.reduce_min(张量名)</span><br><span class="line"></span><br><span class="line"># 计算张量维度上元素的最大值</span><br><span class="line">tf.reduce_max(张量名)</span><br></pre></td></tr></table></figure><p><strong>指定<code>axis</code></strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011508366.png" alt="image-20230501150803267"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 计算张量沿着指定维度的平均值</span><br><span class="line">tf.reduce_mean(张量名,axis=操作轴)</span><br><span class="line"></span><br><span class="line"># 计算张量沿着指定维度的和</span><br><span class="line">tf.reduce_sum(张量名,axis=操作轴)</span><br></pre></td></tr></table></figure><p>示例code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">a = tf.constant([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]],dtype=tf.int32)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(tf.reduce_mean(a))</span><br><span class="line"></span><br><span class="line">print(tf.reduce_sum(a,axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011515660.png" alt="image-20230501151534626"></p><h5 id="（1）tf-Varible"><a href="#（1）tf-Varible" class="headerlink" title="（1）tf.Varible()"></a>（1）tf.Varible()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将变量标记为可训练，被标记的变量会在反向传播中记录梯度信息</span><br><span class="line">tf.Varible(初始值)</span><br></pre></td></tr></table></figure><h5 id="（2）Tensorflow中的数学运算"><a href="#（2）Tensorflow中的数学运算" class="headerlink" title="（2）Tensorflow中的数学运算"></a>（2）Tensorflow中的数学运算</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011520916.png" alt="image-20230501152015863"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011520117.png" alt="image-20230501152046019"> </p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011522716.png" alt="image-20230501152232661"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011522399.png" alt="image-20230501152255367"></p><h5 id="（3）输入特征与标签配对的函数"><a href="#（3）输入特征与标签配对的函数" class="headerlink" title="（3）输入特征与标签配对的函数"></a>（3）输入特征与标签配对的函数</h5><p><strong>numpy与tensor格式都可以用该语句输入数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 切分传入张量的第一维度，生成输入特征与标签对，构建数据集</span><br><span class="line">tf.data.Dataset.from_tensor_slices((输入特征,标签))</span><br></pre></td></tr></table></figure><p>示例code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">feature = tf.constant([<span class="number">12</span>,<span class="number">23</span>,<span class="number">10</span>,<span class="number">17</span>])</span><br><span class="line">labels = tf.constant([<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">dataset = tf.data.Dataset.from_tensor_slices((feature,labels))</span><br><span class="line">print(dataset)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> els in dataset:</span><br><span class="line">    print(els)</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011534097.png" alt="image-20230501153406054"></p><h5 id="（4）tf-GradientTape"><a href="#（4）tf-GradientTape" class="headerlink" title="（4）tf.GradientTape()"></a>（4）tf.GradientTape()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 函数对参数的求导运算,with结构记录计算过程，gradient求出张量的梯度</span><br><span class="line">with tf.GradientTape() as tape:</span><br><span class="line"> 若干计算过程</span><br><span class="line">grad = tape.gradient(函数,对谁求导)</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011543126.png" alt="image-20230501154342092"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with tf.GradientTape() as tape:</span><br><span class="line">    w = tf.Variable(tf.constant(<span class="number">3.0</span>))</span><br><span class="line">    loss = tf.<span class="built_in">pow</span>(w, <span class="number">2</span>)</span><br><span class="line">grad = tape.gradient(loss, w)</span><br><span class="line">print(grad)</span><br></pre></td></tr></table></figure><p>运行:</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011543834.png" alt="image-20230501154356793"></p><h5 id="（5）tf-one-hot"><a href="#（5）tf-one-hot" class="headerlink" title="（5）tf.one_hot()"></a>（5）tf.one_hot()</h5><p>独热编码：在分类问题中，常用独热编码作为标签，标记类别：1表示是，0表示非</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将待转换的数据 转换为one-hot形式的数据输出</span><br><span class="line">tf.one_hot(待转换的数据,depth=几分类)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#tf.one_hot</span></span><br><span class="line">classes=<span class="number">3</span></span><br><span class="line">labels=tf.constant([<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]) # 输入的元素值最小为<span class="number">0</span>  最大为<span class="number">2</span></span><br><span class="line">output=tf.one_hot(labels,depth=classes)</span><br><span class="line">print(output)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011552258.png" alt="image-20230501155233232"></p><h5 id="（6）tf-nn-softmax"><a href="#（6）tf-nn-softmax" class="headerlink" title="（6）tf.nn.softmax()"></a>（6）tf.nn.softmax()</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011556222.png" alt="image-20230501155629072"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011556634.png" alt="image-20230501155656570"></p><h5 id="（7）-assign-sub"><a href="#（7）-assign-sub" class="headerlink" title="（7） assign_sub()"></a>（7） assign_sub()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 赋值操作 更新参数的值并且返回</span><br><span class="line"># 调用assign_sub之前，先用tf.Varible定义w为可以训练（可自更新）</span><br><span class="line">w.assign(w要自减的内容)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#assign_sub</span><br><span class="line">w=tf.Variable(<span class="number">4</span>)</span><br><span class="line">w.assign_sub(<span class="number">1</span>)</span><br><span class="line">print(w)</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011602129.png" alt="image-20230501160203099"></p><h5 id="（8）tf-argmax"><a href="#（8）tf-argmax" class="headerlink" title="（8）tf.argmax()"></a>（8）tf.argmax()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 返回张量沿指定维度最大值的索引</span><br><span class="line">tf.argmax(张量名,axis=操作轴)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011603296.png" alt="image-20230501160348245"></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#tf.argmax</span></span><br><span class="line">import numpy as np</span><br><span class="line">test=np.<span class="built_in">array</span>([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>]])</span><br><span class="line">print(test)</span><br><span class="line">print(tf.argmax(test,axis=<span class="number">0</span>))#返回每一列最大值的索引</span><br><span class="line">print(tf.argmax(test,axis=<span class="number">1</span>))#返回每一行最大值的索引</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">4</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">7</span> <span class="number">2</span>]]</span><br><span class="line">tf.Tensor([<span class="number">3</span> <span class="number">3</span> <span class="number">1</span>], shape=(<span class="number">3</span>,), dtype=int64)</span><br><span class="line">tf.Tensor([<span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span>], shape=(<span class="number">4</span>,), dtype=int64)</span><br></pre></td></tr></table></figure><h3 id="二、鸢尾花分类"><a href="#二、鸢尾花分类" class="headerlink" title="二、鸢尾花分类"></a>二、鸢尾花分类</h3><p>数据集介绍:</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011608240.png" alt="image-20230501160800120"></p><h4 id="1-准备数据"><a href="#1-准备数据" class="headerlink" title="1.准备数据"></a>1.准备数据</h4><h5 id="（1）数据集读入"><a href="#（1）数据集读入" class="headerlink" title="（1）数据集读入"></a>（1）数据集读入</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn import datasets</span><br><span class="line">import pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x_data = datasets.load_iris().data    <span class="meta"># 返回iris数据集所有数据集</span></span><br><span class="line">y_data = datasets.load_iris().target  <span class="meta"># 返回iris数据集所有标签</span></span><br><span class="line"><span class="meta"># print(&quot;x_data:\n&quot;, x_data)</span></span><br><span class="line"><span class="meta"># print(&quot;y_data:\n&quot;, y_data)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># 将数据变成表格的形式</span></span><br><span class="line">x_data = pd.DataFrame(x_data, columns=[<span class="string">&#x27;花萼长&#x27;</span>, <span class="string">&#x27;花萼宽&#x27;</span>, <span class="string">&#x27;花瓣长&#x27;</span>, <span class="string">&#x27;花瓣宽&#x27;</span>])</span><br><span class="line">pd.set_option(<span class="string">&#x27;display.unicode.east_asian_width&#x27;</span>, True)  <span class="meta"># 设置列名对齐</span></span><br><span class="line">print(<span class="string">&#x27;x_data add index:\n&#x27;</span>, x_data)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 在表格中增加一列</span></span><br><span class="line">x_data[<span class="string">&#x27;类别&#x27;</span>] = <span class="function">y_data</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params"><span class="string">&#x27;x_data add a column:\n&#x27;</span>, x_data</span>)</span></span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011617229.png" alt="image-20230501161709190"></p><h5 id="（2）数据集乱序"><a href="#（2）数据集乱序" class="headerlink" title="（2）数据集乱序"></a>（2）数据集乱序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import datasets</span><br><span class="line">from pandas import DataFrame</span><br><span class="line">import pandas as pd</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line"># 读入数据</span><br><span class="line">x_data = datasets.load_iris().data    # 返回iris数据集所有数据集</span><br><span class="line">y_data = datasets.load_iris().target  # 返回iris数据集所有标签</span><br><span class="line"></span><br><span class="line"># 数据集乱序</span><br><span class="line">np.random.seed(<span class="number">116</span>)  # 使用相同的seed，使输入特征/标签一一对应</span><br><span class="line">np.random.shuffle(x_data)  # 打乱</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_data)</span><br><span class="line"></span><br><span class="line"># 数据集分出永不相见的训练集和测试集</span><br><span class="line">x_train = x_data[:<span class="number">-30</span>]</span><br><span class="line">y_train = y_data[:<span class="number">-30</span>]</span><br><span class="line">x_test = x_data[<span class="number">-30</span>:]</span><br><span class="line">y_test = y_data[<span class="number">-30</span>:]</span><br><span class="line"></span><br><span class="line"># 转换数据类型</span><br><span class="line">x_train = tf.cast(x_train, tf.float32)</span><br><span class="line">x_test = tf.cast(x_test, tf.float32)</span><br><span class="line"></span><br><span class="line"># 配成输入特征，标签对，每次喂入一小撮（<span class="number">32</span>个样本为一个batch）</span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(<span class="number">32</span>)</span><br><span class="line">test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(<span class="number">32</span>)</span><br></pre></td></tr></table></figure><h4 id="2-训练"><a href="#2-训练" class="headerlink" title="2.训练"></a>2.训练</h4><p>两层网络，输入层以及输出层（4特征输入  3特征输出）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 定义神经网络中所有可训练参数(初始化的参数权值)</span><br><span class="line">w1 = tf.Variable(tf.random.truncated_normal([4, 3], stddev=0.1, seed=1))</span><br><span class="line">b1 = tf.Variable(tf.random.truncated_normal([3], stddev=0.1, seed=1))</span><br></pre></td></tr></table></figure><p><strong>整体code:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import datasets</span><br><span class="line">from pandas import DataFrame</span><br><span class="line">import pandas as pd</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">x_data = datasets.load_iris().data    # 返回iris数据集所有数据集</span><br><span class="line">y_data = datasets.load_iris().target  # 返回iris数据集所有标签</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">116</span>)  # 使用相同的seed，使输入特征/标签一一对应</span><br><span class="line">np.random.shuffle(x_data)  # 打乱</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_data)</span><br><span class="line"></span><br><span class="line"># 数据集分出永不相见的训练集和测试集</span><br><span class="line">x_train = x_data[:<span class="number">-30</span>]</span><br><span class="line">y_train = y_data[:<span class="number">-30</span>]</span><br><span class="line">x_test = x_data[<span class="number">-30</span>:]</span><br><span class="line">y_test = y_data[<span class="number">-30</span>:]</span><br><span class="line"></span><br><span class="line"># 转换数据类型</span><br><span class="line">x_train = tf.cast(x_train, tf.float32)</span><br><span class="line">x_test = tf.cast(x_test, tf.float32)</span><br><span class="line"></span><br><span class="line"># 配成输入特征，标签对，每次喂入一小撮</span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(<span class="number">32</span>)</span><br><span class="line">test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"># 定义神经网络中所有可训练参数</span><br><span class="line">w1 = tf.Variable(tf.random.truncated_normal([<span class="number">4</span>, <span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line">b1 = tf.Variable(tf.random.truncated_normal([<span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span></span><br><span class="line">train_loss_result = []  # 将每轮loss记录在此列表中，为后续画loss曲线提供数据</span><br><span class="line">test_acc = []</span><br><span class="line">epoch = <span class="number">500</span></span><br><span class="line">loss_all = <span class="number">0</span>  # 每轮分<span class="number">4</span>个step，loss_all记录四个step生成<span class="number">4</span>个loss值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;----------- 嵌套循环迭代，with结构更新参数，显示当前loss -----------&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> epoch in range(epoch):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;-------训练部分--------&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> step, (x_train, y_train) in enumerate(train_db):</span><br><span class="line">        with tf.GradientTape() as tape:  # 记录梯度信息</span><br><span class="line">            # 前向传播过程记录y</span><br><span class="line">            y = tf.matmul(x_train, w1) + b1  # 前向传播计算预测值</span><br><span class="line">            y = tf.nn.softmax(y)  # 使得预测y得分符合概率分布</span><br><span class="line">            # 对预测结果使用softmax()函数之后才可以与实际标签的one_hot进行比较</span><br><span class="line">            y_ = tf.one_hot(y_train, depth=<span class="number">3</span>)  # 将标签值独热编码</span><br><span class="line">            # 记录总loss</span><br><span class="line">            loss = tf.reduce_mean(tf.square(y_ - y))  # 采用均方误差损失值mse</span><br><span class="line">            loss_all += loss.numpy()</span><br><span class="line">        # 计算loss对各个参数的梯度</span><br><span class="line">        grads = tape.gradient(loss, [w1, b1])</span><br><span class="line">        # 实现梯度更新，w1=w1-lr*w1_grad b=b-lr*b_grad</span><br><span class="line">        w1.assign_sub(lr * grads[<span class="number">0</span>])</span><br><span class="line">        b1.assign_sub(lr * grads[<span class="number">1</span>])</span><br><span class="line">    # 每个epoch打印loss信息</span><br><span class="line">    print(<span class="string">&quot;epoch&#123;&#125;,loss&#123;&#125;&quot;</span>.format(epoch, loss_all / <span class="number">4</span>))  # (训练集有<span class="number">120</span>组数据，每个step只能喂入<span class="number">32</span>组数据，需要batch级别循环<span class="number">4</span>次，求每个step的平均loss)</span><br><span class="line">    train_loss_result.append(loss_all / <span class="number">4</span>)  # 将四个step的loss求平均值记录在此变量中</span><br><span class="line">    loss_all = <span class="number">0</span>  # loss_all值归<span class="number">0</span>，为下一个epoch的loss做准备</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;-------测试部分--------&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    # 计算当前参数前向传播后的准确率，显示当前acc</span><br><span class="line">    total_correct, total_number = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_test, y_test in test_db:  # 遍历测试集中所有数据</span><br><span class="line">        y = tf.matmul(x_test, w1) + b1  # 前向传播计算预测值</span><br><span class="line">        y = tf.nn.softmax(y)  <span class="meta"># y符合概率分布</span></span><br><span class="line">        pred = tf.argmax(y, axis=<span class="number">1</span>)  # 返回y中最大值的索引，即预测的分类</span><br><span class="line">        pred = tf.cast(pred, dtype=y_test.dtype)  # 调整数据类型与标签一致</span><br><span class="line">        correct = tf.cast(tf.equal(pred, y_test),</span><br><span class="line">                          dtype=tf.int32)  <span class="meta"># equal，相等的意思。顾名思义，就是判断，x, y 是不是相等，它的判断方法不是整体判断，而是逐个元素进行判断，如果相等就是True，不相等，就是False。由于是逐个元素判断，所以x，y 的维度要一致。</span></span><br><span class="line">        correct = tf.reduce_sum(correct)  # 将所有batch中的correct数加起来</span><br><span class="line">        total_correct += <span class="type">int</span>(correct)  # 将所有batch中的correct数加起来</span><br><span class="line">        total_number += x_test.shape[<span class="number">0</span>]  # 在矩阵中，[<span class="number">0</span>]就表示行数（样本数），[<span class="number">1</span>]则表示列数，[<span class="number">2</span>]代表通道数</span><br><span class="line">    acc = total_correct / total_number</span><br><span class="line">    test_acc.append(acc)</span><br><span class="line">    print(<span class="string">&quot;test_acc&quot;</span>, acc)</span><br><span class="line">    print(<span class="string">&quot;------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;---------------可视化------------&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="meta"># acc/loss可视化</span></span><br><span class="line"># 绘制loss曲线</span><br><span class="line">plt.title(<span class="string">&#x27;loss Curve&#x27;</span>)  # 图片隐私</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="meta"># x轴名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.plot(train_loss_result, label=<span class="string">&quot;$loss$&quot;</span>)  # 逐点画出test_acc值并连线，？epoch?</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># 绘制accuracy曲线</span><br><span class="line">plt.title(<span class="string">&#x27;Acc Curve&#x27;</span>)  # 图片隐私</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="meta"># x轴名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Acc&#x27;</span>)</span><br><span class="line">plt.plot(test_acc, label=<span class="string">&quot;$Accuracy$&quot;</span>)  # 逐点画出test_acc值并连线，？epoch?</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="三、神经网络的优化过程"><a href="#三、神经网络的优化过程" class="headerlink" title="三、神经网络的优化过程"></a>三、神经网络的优化过程</h3><h4 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1.预备知识"></a>1.预备知识</h4><h5 id="（1）tf-where"><a href="#（1）tf-where" class="headerlink" title="（1）tf.where()"></a>（1）tf.where()</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011705991.png" alt="image-20230501170511960"></p><p>示例code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = tf.constant([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">b = tf.constant([<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">c = tf.where(tf.greater(a, b), a, b)  # 若a&gt;b，返回a对应位置的元素，否则返回b对应位置的元素</span><br><span class="line">print(<span class="string">&quot;c：&quot;</span>, c)</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011706202.png" alt="image-20230501170624125"></p><h5 id="（2）np-random-RandomState-rand"><a href="#（2）np-random-RandomState-rand" class="headerlink" title="（2）np.random.RandomState.rand()"></a>（2）np.random.RandomState.rand()</h5><p>产生一个0-1之间的随机数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.RandomState.rand(维度)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">rdm = np.random.RandomState(seed=1)  # 随机数种子 seed为常数导致每一次生成的随机数相同</span><br><span class="line">a = rdm.rand()</span><br><span class="line">b = rdm.rand(2, 3)</span><br><span class="line">print(&quot;a:&quot;, a)</span><br><span class="line">print(&quot;b:&quot;, b)</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011711953.png" alt="image-20230501171105924"></p><h5 id="（3）np-vstack"><a href="#（3）np-vstack" class="headerlink" title="（3）np.vstack()"></a>（3）np.vstack()</h5><p>将两个数组按照垂直方向叠加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.vstack(数组<span class="number">1</span>,数组<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.<span class="built_in">array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.<span class="built_in">array</span>([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">c = np.vstack((a, b))  </span><br><span class="line">print(<span class="string">&quot;c:\n&quot;</span>, c)</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011714125.png" alt="image-20230501171401103"></p><h5 id="（4）np-mgrid-ravel-np-c"><a href="#（4）np-mgrid-ravel-np-c" class="headerlink" title="（4）np.mgrid[]     .ravel()   np.c_[]"></a>（4）np.mgrid[]     .ravel()   np.c_[]</h5><p><strong>np.mgrid[]  返回若干组维度相同的等差数组</strong></p><p><strong>x.ravel()  将x变为一维数组  把<code>.</code>前的变量拉直</strong></p><p><strong>np.c_[]  使返回的间隔数组点配对</strong></p><p>&#96;np.c_[数组1，数组2，…]  </p><p>示例;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># 生成等间隔数值点</span><br><span class="line">x, y = np.mgrid[<span class="number">1</span>:<span class="number">3</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">4</span>:<span class="number">0.5</span>]</span><br><span class="line"># 将x, y拉直，并合并配对为二维张量，生成二维坐标点</span><br><span class="line">grid = np.c_[x.ravel(), y.ravel()]</span><br><span class="line">print(<span class="string">&quot;x:\n&quot;</span>, x)</span><br><span class="line">print(<span class="string">&quot;y:\n&quot;</span>, y)</span><br><span class="line">print(<span class="string">&quot;x.ravel():\n&quot;</span>, x.ravel())</span><br><span class="line">print(<span class="string">&quot;y.ravel():\n&quot;</span>, y.ravel())</span><br><span class="line">print(<span class="string">&#x27;grid:\n&#x27;</span>, grid)</span><br></pre></td></tr></table></figure><p>示例;</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305011727663.png" alt="image-20230501172726637"></p><h4 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2.损失函数"></a>2.损失函数</h4><h5 id="（1）均方损失函数"><a href="#（1）均方损失函数" class="headerlink" title="（1）均方损失函数"></a>（1）均方损失函数</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021027411.png" alt="image-20230502100229116"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOSS_MSE = tf.reduce_mean(tf.square(y_ - y))   <span class="meta"># y 模型前向传播值    y_ 样本标签</span></span><br></pre></td></tr></table></figure><h5 id="（2）交叉熵损失函数"><a href="#（2）交叉熵损失函数" class="headerlink" title="（2）交叉熵损失函数"></a>（2）交叉熵损失函数</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021027538.png" alt="image-20230502100543147"></p><p><strong>y_与y的距离越近(越接近)其交叉熵就越小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOSS_fn = tf.loss.categorical_crossentropy(y_ - y)   <span class="meta"># y 模型前向传播值     </span></span><br></pre></td></tr></table></figure><h6 id="softmax-与交叉熵结合"><a href="#softmax-与交叉熵结合" class="headerlink" title="softmax 与交叉熵结合"></a>softmax 与交叉熵结合</h6><p>输出先过<code>softmax</code>函数，再计算<code>y</code>与<code>y_</code>的交叉熵损失函数</p><p>分步计算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># y已经经过前向传播得到的预测值</span></span><br><span class="line">y_pro = tf.nn.softmax(y)     #  经过 softmax函数，得到概率分布</span><br><span class="line">loss_ce1 = tf.losses.categorical_crossentropy(y_,y_pro)   # y_ 样本标签</span><br></pre></td></tr></table></figure><p>结合计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss_ce2 = tf.softmax_cross_entropy_with_logits(y_,y)</span><br></pre></td></tr></table></figure><h4 id="3-优化器"><a href="#3-优化器" class="headerlink" title="3.优化器"></a>3.优化器</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021027502.png" alt="image-20230502102645614"></p><h5 id="（1）SGD"><a href="#（1）SGD" class="headerlink" title="（1）SGD"></a>（1）SGD</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021030914.png" alt="image-20230502103018837"></p><h5 id="（2）SGDM"><a href="#（2）SGDM" class="headerlink" title="（2）SGDM"></a>（2）SGDM</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021032429.png" alt="image-20230502103205345"></p><p>对于单层网络</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m_w,m_b = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">beta = <span class="number">0.9</span>   # 动量超参数</span><br><span class="line"></span><br><span class="line">m_w = beta * m_w + (<span class="number">1</span> - beta) * grads[<span class="number">0</span>]</span><br><span class="line">m_b = beta * m_b + (<span class="number">1</span> - beta) * grads[<span class="number">1</span>]</span><br><span class="line">w1.assign_sub(lr * m_w)   # 参数自更新</span><br><span class="line">b1.assign_sub(lr * m_b)</span><br></pre></td></tr></table></figure><h5 id="（3）Adagrad"><a href="#（3）Adagrad" class="headerlink" title="（3）Adagrad"></a>（3）Adagrad</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021039514.png" alt="image-20230502103919433"></p><p>Adagrad的一阶动量mt就是当前时刻的梯度，二阶动量是梯度平方的累积和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v_w,v_b = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">v_w += tf.square(grads[<span class="number">0</span>])</span><br><span class="line">v_b += tf.square(grads[<span class="number">1</span>])</span><br><span class="line">w1.assign_sub = (lr *grads[<span class="number">0</span>] / tf.<span class="built_in">sqrt</span>(v_w))</span><br><span class="line">b1.ssign_sub = (lr *grads[<span class="number">1</span>] /tf.<span class="built_in">sqrt</span>(v_b))</span><br></pre></td></tr></table></figure><h5 id="（4）RMSProp"><a href="#（4）RMSProp" class="headerlink" title="（4）RMSProp"></a>（4）RMSProp</h5><p>在SGD的基础上增加二阶动量，二阶动量vt使用指数滑动平均值计算，表征过去一段时间的平均值</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021050499.png" alt="image-20230502105046419"></p><p>一阶动量是当前时刻梯度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v_w,v_b = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">beta = <span class="number">0.9</span></span><br><span class="line">    </span><br><span class="line">v_w = beta * v_w + (<span class="number">1</span>-beta) * tf.square(grads[<span class="number">0</span>])</span><br><span class="line">v_b = beta * v_b + (<span class="number">1</span>-beta) * tf.square(grads[<span class="number">1</span>])</span><br><span class="line">w1.assign_sub = (lr *grads[<span class="number">0</span>] / tf.<span class="built_in">sqrt</span>(v_w))</span><br><span class="line">b1.assign_sub = (lr *grads[<span class="number">1</span>]/  tf.<span class="built_in">sqrt</span>(v_b))</span><br></pre></td></tr></table></figure><h5 id="（5）Adam"><a href="#（5）Adam" class="headerlink" title="（5）Adam"></a>（5）Adam</h5><p>同时结合SGDM一阶动量和RMSProp二阶动量</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021058167.png" alt="image-20230502105816067"></p><h3 id="四、使用八股搭建神经网络"><a href="#四、使用八股搭建神经网络" class="headerlink" title="四、使用八股搭建神经网络"></a>四、使用八股搭建神经网络</h3><h4 id="1-使用Tensorflow-API-tf-keras搭建网络八股"><a href="#1-使用Tensorflow-API-tf-keras搭建网络八股" class="headerlink" title="1.使用Tensorflow API : tf.keras搭建网络八股"></a>1.使用Tensorflow API : tf.keras搭建网络八股</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021101357.png" alt="image-20230502110121291"></p><h5 id="（1）tf-keras-models-Sequential"><a href="#（1）tf-keras-models-Sequential" class="headerlink" title="（1）tf.keras.models.Sequential()"></a>（1）tf.keras.models.Sequential()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.keras.models.Sequential([网络结构])   # 描述各层网络</span><br></pre></td></tr></table></figure><h6 id="拉直层"><a href="#拉直层" class="headerlink" title="拉直层"></a>拉直层</h6><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021104691.png" alt="image-20230502110427660"></p><h6 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h6><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021104758.png" alt="image-20230502110453675"></p><p>卷积层</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021105726.png" alt="image-20230502110506668"></p><p>LSTM层</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021105144.png" alt="image-20230502110522107"></p><h5 id="（2）model-compile"><a href="#（2）model-compile" class="headerlink" title="（2）model.compile()"></a>（2）model.compile()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer = 优化器,loss = 损失函数, metrics = [<span class="string">&quot;准确率&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021109398.png" alt="image-20230502110921320"></p><p><code>from_logits</code>询问是否是原始输出，若神经网络的预测结果经过了softmax概率分布则填写<code>False</code></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021109229.png" alt="image-20230502110938173"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021112574.png" alt="image-20230502111246499"></p><h5 id="（3）model-fit"><a href="#（3）model-fit" class="headerlink" title="（3）model.fit()"></a>（3）model.fit()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model.fit(训练集的属土特征,训练集标签,batch_size= , epochs = ,</span><br><span class="line">          validation_data = (测试集的输入特征,测试集的标签),</span><br><span class="line">          validation_split=从训练集划分多少比例给测试集,</span><br><span class="line">          validation_freq = 多少次epoch测试一次</span><br><span class="line">          )</span><br></pre></td></tr></table></figure><h5 id="（4）model-summary"><a href="#（4）model-summary" class="headerlink" title="（4）model.summary()"></a>（4）model.summary()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.summary() # 打印出网络的结构</span><br></pre></td></tr></table></figure><h4 id="2-使用tf-keras复现鸢尾花分类"><a href="#2-使用tf-keras复现鸢尾花分类" class="headerlink" title="2.使用tf.keras复现鸢尾花分类"></a>2.使用tf.keras复现鸢尾花分类</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    使用tf.keras实现鸢尾花分类</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from sklearn import datasets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 读入鸢尾花数据</span><br><span class="line">x_train = datasets.load_iris().data</span><br><span class="line">y_train = datasets.load_iris().target</span><br><span class="line"></span><br><span class="line"># 数据集乱序</span><br><span class="line">np.random.seed(<span class="number">116</span>)   # 随机种子一致导致后文  标签与对应样本的特征乱序顺序一致</span><br><span class="line">np.random.shuffle(x_train)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_train)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line"># 搭建模型(三分类--单层网络)</span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">3</span>,activation=<span class="string">&#x27;softmax&#x27;</span>,kernel_regularizer=tf.keras.regularizers.l2())</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>),</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"># 训练拟合(validation_split=<span class="number">0.2</span> 从训练集划分<span class="number">20</span>%比例给测试集,validation_freq=<span class="number">20</span> <span class="number">20</span>次epoch测试一次)</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">32</span>,epochs=<span class="number">500</span>,validation_split=<span class="number">0.2</span>,validation_freq=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021138385.png" alt="image-20230502113808342"></p><h4 id="3-自定义class-类搭建网络结构"><a href="#3-自定义class-类搭建网络结构" class="headerlink" title="3.自定义class 类搭建网络结构"></a>3.自定义class 类搭建网络结构</h4><p>用<code>Sequential</code>搭建出上层输出就是下层输入的顺序网络结构</p><p>但是无法写出带有跳连的非顺序网络结构（<strong>此时类<code>class</code>可以</strong>）—类似于pytorch定义自己的网络结构</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021145518.png" alt="image-20230502114506383"></p><p>示例;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    使用class实现鸢尾花分类</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from sklearn import datasets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 读入鸢尾花数据</span><br><span class="line">x_train = datasets.load_iris().data</span><br><span class="line">y_train = datasets.load_iris().target</span><br><span class="line"></span><br><span class="line"># 数据集乱序</span><br><span class="line">np.random.seed(<span class="number">116</span>)   # 随机种子一致导致后文  标签与对应样本的特征乱序顺序一致</span><br><span class="line">np.random.shuffle(x_train)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_train)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line"># 自定义类class搭建模型(三分类--单层网络)</span><br><span class="line">class IrisModel(tf.keras.Model):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(IrisModel,self).__init__()</span><br><span class="line">        self.d1 = tf.keras.layers.Dense(<span class="number">3</span>,activation=<span class="string">&#x27;softmax&#x27;</span>,kernel_regularizer=tf.keras.regularizers.l2())</span><br><span class="line"></span><br><span class="line">    def call(self,x):</span><br><span class="line">        y = self.d1(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">model = IrisModel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>),</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"># 训练拟合(validation_split=<span class="number">0.2</span> 从训练集划分<span class="number">20</span>%比例给测试集,validation_freq=<span class="number">20</span> <span class="number">20</span>次epoch测试一次)</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">32</span>,epochs=<span class="number">500</span>,validation_split=<span class="number">0.2</span>,validation_freq=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><h4 id="4-MNIST数据集"><a href="#4-MNIST数据集" class="headerlink" title="4.MNIST数据集"></a>4.MNIST数据集</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021210767.png" alt="image-20230502121024663"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021210755.png" alt="image-20230502121037702"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021210898.png" alt="image-20230502121050845"></p><p><strong>可视化：</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021212655.png" alt="image-20230502121213615"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021212924.png" alt="image-20230502121233830"></p><h5 id="（1）手写数字识别（Sequential-）"><a href="#（1）手写数字识别（Sequential-）" class="headerlink" title="（1）手写数字识别（Sequential()）"></a>（1）手写数字识别（Sequential()）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    手写识别MNIST</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from sklearn import datasets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 读入MNIST数据</span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train,y_train),(x_test,y_test) = mnist.load_data()</span><br><span class="line"># 将特征皈依化到<span class="number">0</span><span class="number">-1</span> 之间 加快模型收敛</span><br><span class="line">x_train,x_test = x_train / <span class="number">255.0</span> , x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    # 将输入特征展平 <span class="number">28</span> * <span class="number">28</span></span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>,activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    # 输出 <span class="number">10</span> 分类</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">model.compile(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"># 训练拟合(validation_split=<span class="number">0.2</span> 从训练集划分<span class="number">20</span>%比例给测试集,validation_freq=<span class="number">20</span> <span class="number">20</span>次epoch测试一次)</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">32</span>,epochs=<span class="number">5</span>,validation_data=(x_test,y_test),validation_freq=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021222818.png" alt="image-20230502122241785"></p><h5 id="（2）手写数字识别-自定义类class"><a href="#（2）手写数字识别-自定义类class" class="headerlink" title="（2）手写数字识别(自定义类class)"></a>（2）手写数字识别(自定义类class)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    手写识别MNIST---自定义类class</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from sklearn import datasets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 读入MNIST数据</span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train,y_train),(x_test,y_test) = mnist.load_data()</span><br><span class="line"># 将特征皈依化到<span class="number">0</span><span class="number">-1</span> 之间 加快模型收敛</span><br><span class="line">x_train,x_test = x_train / <span class="number">255.0</span> , x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"># 搭建模型</span><br><span class="line">class MnistModel(tf.keras.Model):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(MnistModel,self).__init__()</span><br><span class="line">        self.flatten = tf.keras.layers.Flatten(),</span><br><span class="line">        self.d1 = tf.keras.layers.Dense(<span class="number">128</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d2 = tf.keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    def call(self,x):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.d1(x)</span><br><span class="line">        y = self.d2(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">model = MnistModel()</span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    # 将输入特征展平 <span class="number">28</span> * <span class="number">28</span></span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>,activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    # 输出 <span class="number">10</span> 分类</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">model.compile(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"># 训练拟合(validation_split=<span class="number">0.2</span> 从训练集划分<span class="number">20</span>%比例给测试集,validation_freq=<span class="number">20</span> <span class="number">20</span>次epoch测试一次)</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">32</span>,epochs=<span class="number">5</span>,validation_data=(x_test,y_test),validation_freq=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><h4 id="5-FASHION数据集"><a href="#5-FASHION数据集" class="headerlink" title="5.FASHION数据集"></a>5.FASHION数据集</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021229859.png" alt="image-20230502122907656"></p><h3 id="五、八股进阶"><a href="#五、八股进阶" class="headerlink" title="五、八股进阶"></a>五、八股进阶</h3><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305021231960.png" alt="image-20230502123140865"></p><h4 id="1-自制数据集"><a href="#1-自制数据集" class="headerlink" title="1.自制数据集"></a>1.自制数据集</h4><p>数据结构如下：（图片名 最后的数字即为其标签）</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022136757.png" alt="image-20230502204829177"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    自制数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import tensorflow as tf</span><br><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">train_path = <span class="string">&quot;./data/mnist_image_label/mnist_train_jpg_60000/&quot;</span></span><br><span class="line">train_txt = <span class="string">&quot;./data/mnist_image_label/mnist_train_jpg_60000.txt&quot;</span></span><br><span class="line">x_train_savepath = <span class="string">&quot;./data/mnist_image_label/mnist_x_train.npy&quot;</span></span><br><span class="line">y_train_savepath = <span class="string">&quot;./data/mnist_image_label/mnist_y_train.npy&quot;</span></span><br><span class="line"></span><br><span class="line">test_path = <span class="string">&quot;./data/mnist_image_label/mnist_test_jpg_10000/&quot;</span></span><br><span class="line">test_txt = <span class="string">&quot;./data/mnist_image_label/mnist_train_jpg_10000.txt&quot;</span></span><br><span class="line">x_test_savepath = <span class="string">&quot;./data/mnist_image_label/mnist_x_test.npy&quot;</span></span><br><span class="line">y_test_savepath = <span class="string">&quot;./data/mnist_image_label/mnist_y_test.npy&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate(path,txt):</span><br><span class="line">    f = open(txt,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    contents = f.readlines()   # 读取txt文件中所有行</span><br><span class="line">    f.close()</span><br><span class="line">    x,y_ = [],[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> content in contents:</span><br><span class="line">        value = content.split()  # 以空格分开，图片路径为value[<span class="number">0</span>]  标签文件为value[<span class="number">1</span>]  存入列表</span><br><span class="line">        img_path = path + value[<span class="number">0</span>]  # 拼出图片路径以及文件名</span><br><span class="line">        img = Image.open(img_path)  # 读入图片</span><br><span class="line">        img = np.<span class="built_in">array</span>(img.convert(<span class="string">&#x27;L&#x27;</span>))  # 图片变为<span class="number">8</span>位宽灰度值的np.<span class="built_in">array</span>格式</span><br><span class="line">        img = img / <span class="number">255.</span>   # 皈依化</span><br><span class="line">        x.append(img)</span><br><span class="line">        y_.append(value[<span class="number">1</span>])</span><br><span class="line">        print(<span class="string">&#x27;loading : &#x27;</span> + content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        x = np.<span class="built_in">array</span>(x)  # 变为np.<span class="built_in">array</span>形式</span><br><span class="line">        y_ = np.<span class="built_in">array</span>(y_)</span><br><span class="line"></span><br><span class="line">        y_ = y_.astype(np.int64)   # 变为<span class="number">64</span>位整型</span><br><span class="line">        <span class="keyword">return</span> x,y_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;---数据集---&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(x_train_savepath) and os.path.exists(y_train_savepath) and os.path.exists(x_test_savepath) and os.path.exists(y_test_savepath):</span><br><span class="line">    print(<span class="string">&quot;-----------Load Datasets----------&quot;</span>)</span><br><span class="line">    x_train_save = np.load(x_train_savepath)</span><br><span class="line">    y_train = np.load(y_train_savepath)</span><br><span class="line">    x_test_save = np.load(x_test_savepath)</span><br><span class="line">    y_test = np.load(y_test_savepath)</span><br><span class="line">    x_train = np.reshape(x_train_save,(len(x_train_save),<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">    x_test = np.reshape(x_test_save,(len(x_test_save,),<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;----------Generate Datasets----------&quot;</span>)</span><br><span class="line">    x_train,y_train = generate(train_path,train_txt)</span><br><span class="line">    x_test,y_test = generate(test_path,test_txt)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;---------- Save Datasets----------&quot;</span>)</span><br><span class="line">    x_train_save = np.reshape(x_train,(len(x_train),<span class="number">-1</span>))</span><br><span class="line">    x_test_save = np.reshape(x_test,(len(x_test),<span class="number">-1</span>))</span><br><span class="line">    np.save(x_train_savepath,x_train_save)</span><br><span class="line">    np.save(y_train_savepath,y_train)</span><br><span class="line">    np.save(x_test_savepath, x_test_save)</span><br><span class="line">    np.save(y_test_savepath, y_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    # 输出 <span class="number">10</span> 分类</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">model.compile(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"># 训练拟合(validation_split=<span class="number">0.2</span> 从训练集划分<span class="number">20</span>%比例给测试集,validation_freq=<span class="number">20</span> <span class="number">20</span>次epoch测试一次)</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">32</span>,epochs=<span class="number">5</span>,validation_data=(x_test,y_test),validation_freq=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><h4 id="2-数据增强"><a href="#2-数据增强" class="headerlink" title="2.数据增强"></a>2.数据增强</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022136660.png" alt="image-20230502213605177"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022136351.png" alt="image-20230502213622414"></p><h5 id="（1）注意"><a href="#（1）注意" class="headerlink" title="（1）注意"></a>（1）注意</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image_gen_teain.fit(x_train)</span><br></pre></td></tr></table></figure><p><code>fit()</code>函数需要参数为4D参数，因此需要对数据进行<code>reshape()</code></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022139857.png" alt="image-20230502213949787"></p><p>6000为样本数量，28*28为样本尺寸大小，1为通道数</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022141008.png" alt="image-20230502214156936"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow.keras.preprocessing.image import ImageDataGenerator</span><br><span class="line"></span><br><span class="line"># 加载mnist 数据</span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line">x_train = x_train.reshape(x_train.shape[<span class="number">0</span>], <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)  # 给数据增加一个维度,从(<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>)reshape为(<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"># 数据增强</span><br><span class="line">image_gen_train = ImageDataGenerator(</span><br><span class="line">    rescale=<span class="number">1.</span> / <span class="number">1.</span>,  # 如为图像，分母为<span class="number">255</span>时，可归至<span class="number">0</span>～<span class="number">1</span></span><br><span class="line">    rotation_range=<span class="number">45</span>,  # 随机<span class="number">45</span>度旋转</span><br><span class="line">    width_shift_range=<span class="number">.15</span>,  # 宽度偏移</span><br><span class="line">    height_shift_range=<span class="number">.15</span>,  # 高度偏移</span><br><span class="line">    horizontal_flip=False,  # 水平翻转</span><br><span class="line">    zoom_range=<span class="number">0.5</span>  # 将图像随机缩放阈量<span class="number">50</span>％</span><br><span class="line">)</span><br><span class="line">image_gen_train.fit(x_train)</span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(image_gen_train.flow(x_train, y_train, batch_size=<span class="number">32</span>), epochs=<span class="number">5</span>, validation_data=(x_test, y_test),</span><br><span class="line">          validation_freq=<span class="number">1</span>)</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><h4 id="3-读取保存模型"><a href="#3-读取保存模型" class="headerlink" title="3.读取保存模型"></a>3.读取保存模型</h4><h5 id="（1）读取模型"><a href="#（1）读取模型" class="headerlink" title="（1）读取模型"></a>（1）读取模型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_weights(路径文件名)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checkpoint_save_path = <span class="string">&quot;./mnist.ckpt&quot;</span></span><br><span class="line"># 生成ckpt文件时，会同步生成索引表<span class="string">&#x27;.index&#x27;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;-------load the model--------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br></pre></td></tr></table></figure><h5 id="（2）保存模型"><a href="#（2）保存模型" class="headerlink" title="（2）保存模型"></a>（2）保存模型</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022154400.png" alt="image-20230502215429327"></p><p><code>save_weights_only</code>为是否只保留模型参数、<code>save_best_only</code>为是否只保留最优结果</p><p>执行训练时加入cp_callback选项记录至history中</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022158052.png" alt="image-20230502215806987"></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"># 读取模型</span><br><span class="line">checkpoint_save_path = <span class="string">&quot;./checkpoint/mnist.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    print(<span class="string">&#x27;-------------load the model-----------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br><span class="line"></span><br><span class="line"># 创建callback选项</span><br><span class="line">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,</span><br><span class="line">                                                 save_weights_only=True,</span><br><span class="line">                                                 save_best_only=True)</span><br><span class="line"></span><br><span class="line"># 执行训练时加入cp_callback选项记录至history中</span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>,</span><br><span class="line">                    callbacks=[cp_callback])</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><h4 id="4-参数提取读入文本"><a href="#4-参数提取读入文本" class="headerlink" title="4.参数提取读入文本"></a>4.参数提取读入文本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.trainable_varibles   #  返回模型中可训练的参数</span><br></pre></td></tr></table></figure><p>设置<code>print</code>输出格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold = 超过多少省略显示)</span><br><span class="line"></span><br><span class="line"># 示例  （这样可以将参数全部显示打印出来，而不会出现省略号）</span><br><span class="line">    np.set_printoptions(threshold = np.inf)   <span class="meta"># np.inf 表示无限大</span></span><br></pre></td></tr></table></figure><p><strong>将参数写文本</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prinr(model.trainable_varibles)</span><br><span class="line">file = open(<span class="string">&#x27;./weights.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> v in model.trainable_varibles:</span><br><span class="line">file.write(str(v.name) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(str(v.shape) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(str(v.numpy()) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    参数提取读入文本</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import tensorflow as tf</span><br><span class="line">import os</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 设置参数打印方式 （threshold=np.inf  不出现省略全部打印出来）</span><br><span class="line">np.set_printoptions(threshold=np.inf)</span><br><span class="line"></span><br><span class="line"># 读取数据集</span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"># 网络模型</span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">model.compile(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检查是否存在模型训练参数保存的ckpt文件</span><br><span class="line">checkpoint_save_path = <span class="string">&quot;./checkpoint/mnist.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    print(<span class="string">&#x27;-------------load the model-----------------&#x27;</span>)</span><br><span class="line">    # 若存在则直接加载权重文件</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br><span class="line"></span><br><span class="line"># 若不存在模型训练参数的权重文件---创建回调</span><br><span class="line">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,</span><br><span class="line">                                                 save_weights_only=True,</span><br><span class="line">                                                 save_best_only=True)</span><br><span class="line"></span><br><span class="line"># 训练并且将模型训练参数权重文件进行保存</span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>,</span><br><span class="line">                    callbacks=[cp_callback])</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"># 打印训练权重文件的参数</span><br><span class="line">print(model.trainable_variables)</span><br><span class="line"></span><br><span class="line"># 将参数提取写入txt文件中</span><br><span class="line">file = open(<span class="string">&#x27;./weights.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> v in model.trainable_variables:</span><br><span class="line">    file.write(str(v.name) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(str(v.shape) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(str(v.numpy()) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h4 id="5-acc-以及-loss-的可视化"><a href="#5-acc-以及-loss-的可视化" class="headerlink" title="5.acc 以及 loss 的可视化"></a>5.acc 以及 loss 的可视化</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022249112.png" alt="image-20230502224907025"></p><p>在训练<code>model.fit()</code>的过程中同步记录了以下信息：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022249158.png" alt="image-20230502224952084"></p><p>可用以下代码进行提取：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022250511.png" alt="image-20230502225038439"></p><p>可视化代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">##############################################<span class="meta">#    show   ###############################################</span></span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示训练集和验证集的acc和loss曲线</span><br><span class="line">acc = history.history[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(acc, label=<span class="string">&#x27;Training Accuracy&#x27;</span>)</span><br><span class="line">plt.plot(val_acc, label=<span class="string">&#x27;Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(loss, label=<span class="string">&#x27;Training Loss&#x27;</span>)</span><br><span class="line">plt.plot(val_loss, label=<span class="string">&#x27;Validation Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022252978.png" alt="image-20230502225230915"></p><h4 id="6-使用训练后的模型进行预测"><a href="#6-使用训练后的模型进行预测" class="headerlink" title="6.使用训练后的模型进行预测"></a>6.使用训练后的模型进行预测</h4><p>输入一张手写数字图片  —-&gt;  输出识别结果</p><p><strong>前向传播执行应用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict(输入特征,batch_size = 整数)   # 返回前向传播计算结果</span><br></pre></td></tr></table></figure><p>下面是预测过程：（复现模型—&gt; 加载参数—&gt; 预测结果）</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305022256218.png" alt="image-20230502225644100"></p><p>但是输入的数据需要满足训练的神经网络对于输入数据的要求</p><h3 id="六、CNN"><a href="#六、CNN" class="headerlink" title="六、CNN"></a>六、CNN</h3><p>卷积神经网络的主要模块</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041045891.png" alt="image-20230504104500795"></p><p>卷积就是特征提取器：CBAPD</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041045822.png" alt="image-20230504104556710"></p><h4 id="1-感受野"><a href="#1-感受野" class="headerlink" title="1.感受野"></a>1.感受野</h4><p><strong>卷积神经网络各输出特征图中的每个像素点，在原始输入图片上映射区域的大小</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305030938126.png" alt="image-20230503093858057"></p><p>上图中<code>1</code>是原始输入数据，为<code>5x5</code>，<code>1</code>通过一个<code>3x3</code>的卷积核变为<code>2</code>，则2的感受野是<code>3</code>.</p><p>在对<code>2</code>经过一个<code>3x3</code>的卷积核变为<code>3</code>，则<code>3</code>的感受野是<code>5</code>（原始输入数据为<code>1</code>）</p><p><code>4</code>的感受野也是<code>5</code></p><h4 id="2-卷积层"><a href="#2-卷积层" class="headerlink" title="2.卷积层"></a>2.卷积层</h4><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041018339.png" alt="image-20230504100730776"></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Conv2D(<span class="number">6</span>,<span class="number">5</span>,padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    tf.keras.layers.MaxPool2D(<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">    tf.keras.layers.Conv2D(<span class="number">6</span>,(<span class="number">5</span>,<span class="number">5</span>),padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    tf.keras.layers.MaxPool2D(<span class="number">2</span>,(<span class="number">2</span>,<span class="number">2</span>)),</span><br><span class="line">    tf.keras.layers.Conv2D(filters=<span class="number">6</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>),</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])                     </span><br></pre></td></tr></table></figure><h4 id="3-批量标准化（BN）"><a href="#3-批量标准化（BN）" class="headerlink" title="3.批量标准化（BN）"></a>3.批量标准化（BN）</h4><p>神经网络对于0附近的数据更加敏感，但是随着网络层数的增加，特征数据会出现偏离0均值的情况</p><p>标准化：使得数据符合0均值,1为标准差的分布（将偏移的数据重新拉回到0附近）</p><p>批标准化：对一个batch数据，做标准化处理</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041017685.png" alt="image-20230504101708450"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041018839.png" alt="image-20230504101739435"></p><p><strong>批标准化操作会让每个像素点进行减均值除以标准差的自更新计算</strong></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041018596.png" alt="image-20230504101846539"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041020725.png" alt="image-20230504102055604"></p><p><strong>在反向传播时,缩放因子，与偏移因子会与其他待训练的参数一同被训练优化，使得标准正太分布后的特征数据，通过缩放因子与偏移因子优化了投入特征数据的宽窄与偏移量，保证了网络的非线性表达力</strong></p><p><code>BN</code>层位于卷积层之后，激活层之前</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041025242.png" alt="image-20230504102525166"></p><h5 id="（1）BN操作函数"><a href="#（1）BN操作函数" class="headerlink" title="（1）BN操作函数"></a>（1）BN操作函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.keras.layers.BatchNormalization(),   # BN层操作</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Conv2D(<span class="number">6</span>,<span class="number">5</span>,padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    tf.keras.layers.BatchNormalization(),   # BN层操作</span><br><span class="line">    tf.keras.layers.Activation(<span class="string">&#x27;relu&#x27;</span>),     # 激活层</span><br><span class="line">    tf.keras.layers.MaxPool2D(<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">    tf.keras.layers.Dropout(<span class="number">0.2</span>),           # Dropout()层</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h4 id="4-池化操作"><a href="#4-池化操作" class="headerlink" title="4.池化操作"></a>4.池化操作</h4><p>池化用于减少特征的数据量</p><p><strong>最大池化：</strong>可以提取图片纹理</p><p><strong>均值池化</strong>：可以保留背景特征</p><h5 id="（1）池化函数"><a href="#（1）池化函数" class="headerlink" title="（1）池化函数"></a>（1）池化函数</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041038633.png" alt="image-20230504103811461"></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Conv2D(<span class="number">6</span>,<span class="number">5</span>,padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    tf.keras.layers.BatchNormalization(),   # BN层操作</span><br><span class="line">    tf.keras.layers.Activation(<span class="string">&#x27;relu&#x27;</span>),     # 激活层</span><br><span class="line">    tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>),  # 池化</span><br><span class="line">    tf.keras.layers.Dropout(<span class="number">0.2</span>),           # Dropout()层</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h4 id="5-舍弃"><a href="#5-舍弃" class="headerlink" title="5.舍弃"></a>5.舍弃</h4><p>舍弃（<code>Dropout()</code>）是一种正则化操作，也是为了防止神经网络过拟合</p><p><strong>在神经网络训练时，将一部分神经网络按照一定概率从神经网络中暂时舍弃。神经网络使用时，被舍弃的神经元恢复连接</strong></p><h5 id="（1）Dropout函数"><a href="#（1）Dropout函数" class="headerlink" title="（1）Dropout函数"></a>（1）Dropout函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.keras.layers.Dropout(舍弃的概率)         # Dropout()层</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Conv2D(<span class="number">6</span>,<span class="number">5</span>,padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    tf.keras.layers.BatchNormalization(),   # BN层操作</span><br><span class="line">    tf.keras.layers.Activation(<span class="string">&#x27;relu&#x27;</span>),     # 激活层</span><br><span class="line">    tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>),  # 池化</span><br><span class="line">    tf.keras.layers.Dropout(<span class="number">0.2</span>),           # Dropout()层</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="七、CIFAR10数据集"><a href="#七、CIFAR10数据集" class="headerlink" title="七、CIFAR10数据集"></a>七、CIFAR10数据集</h3><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041048799.png" alt="image-20230504104838723"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041049014.png" alt="image-20230504104901853"></p><h4 id="1-导入数据集"><a href="#1-导入数据集" class="headerlink" title="1.导入数据集"></a>1.导入数据集</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">    </span><br><span class="line">cifar10 = tf.keras.datasets.cifar10</span><br><span class="line">(x_train,y_train),(x_test,y_test) = cifar10.load_data()</span><br></pre></td></tr></table></figure><h5 id="（1）可视化数据集"><a href="#（1）可视化数据集" class="headerlink" title="（1）可视化数据集"></a>（1）可视化数据集</h5><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041051641.png" alt="image-20230504105141527"></p><p>下载的数据集到下面目录（ubuntu下<code>/home/用户名/.kera</code>）   <code>.kera</code>是隐藏用户名</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041116255.png" alt="image-20230504111637223"></p><h4 id="2-使用卷积神经网络训练CIFAR10数据集"><a href="#2-使用卷积神经网络训练CIFAR10数据集" class="headerlink" title="2.使用卷积神经网络训练CIFAR10数据集"></a>2.使用卷积神经网络训练CIFAR10数据集</h4><p>卷积模型如下：（卷积就是CBAPD—卷积–批量归一化—激活—池化—舍弃）</p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041055341.png" alt="image-20230504105534244"></p><p><img src="https://gitee.com/zhou-xuezhi/mypic2/raw/master/img/202305041057960.png" alt="image-20230504105722853"></p><p>示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    搭建卷积神经网络训练 CIFAR10</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">import tensorflow as tf</span><br><span class="line">import os</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">np.set_printoptions(threshold=np.inf)</span><br><span class="line"></span><br><span class="line">cifar10 = tf.keras.datasets.cifar10</span><br><span class="line">(x_train, y_train), (x_test, y_test) = cifar10.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"># 搭建网络模型</span><br><span class="line">class Baseline(tf.keras.Model):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Baseline, self).__init__()</span><br><span class="line">        self.c1 = tf.keras.layers.Conv2D(filters=<span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), padding=<span class="string">&#x27;same&#x27;</span>)  # C卷积层</span><br><span class="line">        self.b1 = tf.keras.layers.BatchNormalization()  # B BN层</span><br><span class="line">        self.a1 = tf.keras.layers.Activation(<span class="string">&#x27;relu&#x27;</span>)  # A 激活层</span><br><span class="line">        self.p1 = tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)  # P 池化层</span><br><span class="line">        self.d1 = tf.keras.layers.Dropout(<span class="number">0.2</span>)  # D dropout层</span><br><span class="line"></span><br><span class="line">        self.flatten = tf.keras.layers.Flatten()  # 展平层</span><br><span class="line">        self.f1 = tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>)  # 线性层</span><br><span class="line">        self.d2 = tf.keras.layers.Dropout(<span class="number">0.2</span>)</span><br><span class="line">        self.f2 = tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)  # 最后<span class="number">10</span>分类，经过softmax变为概率分布</span><br><span class="line"></span><br><span class="line">    def call(self, x):</span><br><span class="line">        x = self.c1(x)</span><br><span class="line">        x = self.b1(x)</span><br><span class="line">        x = self.a1(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line">        x = self.d1(x)</span><br><span class="line"></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.f1(x)</span><br><span class="line">        x = self.d2(x)</span><br><span class="line">        y = self.f2(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"># 创建模型示例</span><br><span class="line">model = Baseline()</span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">model.compile(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              # 损失函数 传入的非原始数据 from_logits=False  (经过了softmax)</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"># 加载模型权重参数</span><br><span class="line">checkpoint_save_path = <span class="string">&quot;./checkpoint/Baseline.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    print(<span class="string">&#x27;-------------load the model-----------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br><span class="line"></span><br><span class="line"># 创建回调（用于训练时，保存模型权重参数）</span><br><span class="line">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,</span><br><span class="line">                                                 save_weights_only=True,</span><br><span class="line">                                                 save_best_only=True)</span><br><span class="line"></span><br><span class="line"># 训练</span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>,</span><br><span class="line">                    callbacks=[cp_callback])</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"># 读取模型训练的权重参数，并进行保存至文本</span><br><span class="line"><span class="meta"># print(model.trainable_variables)</span></span><br><span class="line">file = open(<span class="string">&#x27;./weights.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> v in model.trainable_variables:</span><br><span class="line">    file.write(str(v.name) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(str(v.shape) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(str(v.numpy()) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">##############################################<span class="meta">#    show   ###############################################</span></span><br><span class="line"></span><br><span class="line"># 显示训练集和验证集的acc和loss曲线</span><br><span class="line">acc = history.history[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(acc, label=<span class="string">&#x27;Training Accuracy&#x27;</span>)</span><br><span class="line">plt.plot(val_acc, label=<span class="string">&#x27;Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(loss, label=<span class="string">&#x27;Training Loss&#x27;</span>)</span><br><span class="line">plt.plot(val_loss, label=<span class="string">&#x27;Validation Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> Tensorflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
